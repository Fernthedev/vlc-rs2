/* automatically generated by rust-bindgen 0.59.2 */

pub const libvlc_media_filestat_mtime: u32 = 0;
pub const libvlc_media_filestat_size: u32 = 1;
pub type size_t = libc::c_ulong;
pub type va_list = __builtin_va_list;
pub type __uint16_t = libc::c_ushort;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_instance_t {
    _unused: [u8; 0],
}
pub type libvlc_time_t = i64;
extern "C" {
    #[doc = " A human-readable error message for the last LibVLC error in the calling"]
    #[doc = " thread. The resulting string is valid until another error occurs (at least"]
    #[doc = " until the next LibVLC call)."]
    #[doc = ""]
    #[doc = " @warning"]
    #[doc = " This will be NULL if there was no error."]
    pub fn libvlc_errmsg() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Clears the LibVLC error status for the current thread. This is optional."]
    #[doc = " By default, the error status is automatically overridden when a new error"]
    #[doc = " occurs, and destroyed when the thread exits."]
    pub fn libvlc_clearerr();
}
extern "C" {
    #[doc = " Sets the LibVLC error status and message for the current thread."]
    #[doc = " Any previous error is overridden."]
    #[doc = " \\param fmt the format string"]
    #[doc = " \\param ...  the arguments for the format string"]
    #[doc = " \\return a nul terminated string in any case"]
    pub fn libvlc_printerr(fmt: *const libc::c_char, ...) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Create and initialize a libvlc instance."]
    #[doc = " This functions accept a list of \"command line\" arguments similar to the"]
    #[doc = " main(). These arguments affect the LibVLC instance default configuration."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " LibVLC may create threads. Therefore, any thread-unsafe process"]
    #[doc = " initialization must be performed before calling libvlc_new(). In particular"]
    #[doc = " and where applicable:"]
    #[doc = " - setlocale() and textdomain(),"]
    #[doc = " - setenv(), unsetenv() and putenv(),"]
    #[doc = " - with the X11 display system, XInitThreads()"]
    #[doc = "   (see also libvlc_media_player_set_xwindow()) and"]
    #[doc = " - on Microsoft Windows, SetErrorMode()."]
    #[doc = " - sigprocmask() shall never be invoked; pthread_sigmask() can be used."]
    #[doc = ""]
    #[doc = " On POSIX systems, the SIGCHLD signal <b>must not</b> be ignored, i.e. the"]
    #[doc = " signal handler must set to SIG_DFL or a function pointer, not SIG_IGN."]
    #[doc = " Also while LibVLC is active, the wait() function shall not be called, and"]
    #[doc = " any call to waitpid() shall use a strictly positive value for the first"]
    #[doc = " parameter (i.e. the PID). Failure to follow those rules may lead to a"]
    #[doc = " deadlock or a busy loop."]
    #[doc = " Also on POSIX systems, it is recommended that the SIGPIPE signal be blocked,"]
    #[doc = " even if it is not, in principles, necessary, e.g.:"]
    #[doc = " @code"]
    #[doc = "sigset_t set;"]
    #[doc = ""]
    #[doc = "signal(SIGCHLD, SIG_DFL);"]
    #[doc = "sigemptyset(&set);"]
    #[doc = "sigaddset(&set, SIGPIPE);"]
    #[doc = "pthread_sigmask(SIG_BLOCK, &set, NULL);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " On Microsoft Windows, setting the default DLL directories to SYSTEM32"]
    #[doc = " exclusively is strongly recommended for security reasons:"]
    #[doc = " @code"]
    #[doc = "SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " \\version"]
    #[doc = " Arguments are meant to be passed from the command line to LibVLC, just like"]
    #[doc = " VLC media player does. The list of valid arguments depends on the LibVLC"]
    #[doc = " version, the operating system and platform, and set of available LibVLC"]
    #[doc = " plugins. Invalid or unsupported arguments will cause the function to fail"]
    #[doc = " (i.e. return NULL). Also, some arguments may alter the behaviour or"]
    #[doc = " otherwise interfere with other LibVLC functions."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " There is absolutely no warranty or promise of forward, backward and"]
    #[doc = " cross-platform compatibility with regards to libvlc_new() arguments."]
    #[doc = " We recommend that you do not use them, other than when debugging."]
    #[doc = ""]
    #[doc = " \\param argc the number of arguments (should be 0)"]
    #[doc = " \\param argv list of arguments (should be NULL)"]
    #[doc = " \\return the libvlc instance or NULL in case of error"]
    pub fn libvlc_new(
        argc: libc::c_int,
        argv: *const *const libc::c_char,
    ) -> *mut libvlc_instance_t;
}
extern "C" {
    #[doc = " Decrement the reference count of a libvlc instance, and destroy it"]
    #[doc = " if it reaches zero."]
    #[doc = ""]
    #[doc = " \\param p_instance the instance to destroy"]
    pub fn libvlc_release(p_instance: *mut libvlc_instance_t);
}
extern "C" {
    #[doc = " Increments the reference count of a libvlc instance."]
    #[doc = " The initial reference count is 1 after libvlc_new() returns."]
    #[doc = ""]
    #[doc = " \\param p_instance the instance to reference"]
    pub fn libvlc_retain(p_instance: *mut libvlc_instance_t);
}
extern "C" {
    #[doc = " Try to start a user interface for the libvlc instance."]
    #[doc = ""]
    #[doc = " \\param p_instance the instance"]
    #[doc = " \\param name interface name, or NULL for default"]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn libvlc_add_intf(
        p_instance: *mut libvlc_instance_t,
        name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Registers a callback for the LibVLC exit event. This is mostly useful if"]
    #[doc = " the VLC playlist and/or at least one interface are started with"]
    #[doc = " libvlc_playlist_play() or libvlc_add_intf() respectively."]
    #[doc = " Typically, this function will wake up your application main loop (from"]
    #[doc = " another thread)."]
    #[doc = ""]
    #[doc = " \\note This function should be called before the playlist or interface are"]
    #[doc = " started. Otherwise, there is a small race condition: the exit event could"]
    #[doc = " be raised before the handler is registered."]
    #[doc = ""]
    #[doc = " \\param p_instance LibVLC instance"]
    #[doc = " \\param cb callback to invoke when LibVLC wants to exit,"]
    #[doc = "           or NULL to disable the exit handler (as by default)"]
    #[doc = " \\param opaque data pointer for the callback"]
    pub fn libvlc_set_exit_handler(
        p_instance: *mut libvlc_instance_t,
        cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
        opaque: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Sets the application name. LibVLC passes this as the user agent string"]
    #[doc = " when a protocol requires it."]
    #[doc = ""]
    #[doc = " \\param p_instance LibVLC instance"]
    #[doc = " \\param name human-readable application name, e.g. \"FooBar player 1.2.3\""]
    #[doc = " \\param http HTTP User Agent, e.g. \"FooBar/1.2.3 Python/2.6.0\""]
    #[doc = " \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_set_user_agent(
        p_instance: *mut libvlc_instance_t,
        name: *const libc::c_char,
        http: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " Sets some meta-information about the application."]
    #[doc = " See also libvlc_set_user_agent()."]
    #[doc = ""]
    #[doc = " \\param p_instance LibVLC instance"]
    #[doc = " \\param id Java-style application identifier, e.g. \"com.acme.foobar\""]
    #[doc = " \\param version application version numbers, e.g. \"1.2.3\""]
    #[doc = " \\param icon application icon name, e.g. \"foobar\""]
    #[doc = " \\version LibVLC 2.1.0 or later."]
    pub fn libvlc_set_app_id(
        p_instance: *mut libvlc_instance_t,
        id: *const libc::c_char,
        version: *const libc::c_char,
        icon: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " Retrieve libvlc version."]
    #[doc = ""]
    #[doc = " Example: \"1.1.0-git The Luggage\""]
    #[doc = ""]
    #[doc = " \\return a string containing the libvlc version"]
    pub fn libvlc_get_version() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Retrieve libvlc compiler version."]
    #[doc = ""]
    #[doc = " Example: \"gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)\""]
    #[doc = ""]
    #[doc = " \\return a string containing the libvlc compiler version"]
    pub fn libvlc_get_compiler() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Retrieve libvlc changeset."]
    #[doc = ""]
    #[doc = " Example: \"aa9bce0bc4\""]
    #[doc = ""]
    #[doc = " \\return a string containing the libvlc changeset"]
    pub fn libvlc_get_changeset() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Frees an heap allocation returned by a LibVLC function."]
    #[doc = " If you know you're using the same underlying C run-time as the LibVLC"]
    #[doc = " implementation, then you can call ANSI C free() directly instead."]
    #[doc = ""]
    #[doc = " \\param ptr the pointer"]
    pub fn libvlc_free(ptr: *mut libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_manager_t {
    _unused: [u8; 0],
}
#[doc = " Type of a LibVLC event."]
pub type libvlc_event_type_t = libc::c_int;
#[doc = " Callback function notification"]
#[doc = " \\param p_event the event triggering the callback"]
pub type libvlc_callback_t = ::core::option::Option<
    unsafe extern "C" fn(p_event: *const libvlc_event_t, p_data: *mut libc::c_void),
>;
extern "C" {
    #[doc = " Register for an event notification."]
    #[doc = ""]
    #[doc = " \\param p_event_manager the event manager to which you want to attach to."]
    #[doc = "        Generally it is obtained by vlc_my_object_event_manager() where"]
    #[doc = "        my_object is the object you want to listen to."]
    #[doc = " \\param i_event_type the desired event to which we want to listen"]
    #[doc = " \\param f_callback the function to call when i_event_type occurs"]
    #[doc = " \\param user_data user provided data to carry with the event"]
    #[doc = " \\return 0 on success, ENOMEM on error"]
    pub fn libvlc_event_attach(
        p_event_manager: *mut libvlc_event_manager_t,
        i_event_type: libvlc_event_type_t,
        f_callback: libvlc_callback_t,
        user_data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Unregister an event notification."]
    #[doc = ""]
    #[doc = " \\param p_event_manager the event manager"]
    #[doc = " \\param i_event_type the desired event to which we want to unregister"]
    #[doc = " \\param f_callback the function to call when i_event_type occurs"]
    #[doc = " \\param p_user_data user provided data to carry with the event"]
    pub fn libvlc_event_detach(
        p_event_manager: *mut libvlc_event_manager_t,
        i_event_type: libvlc_event_type_t,
        f_callback: libvlc_callback_t,
        p_user_data: *mut libc::c_void,
    );
}
#[doc = "< Debug message"]
pub const libvlc_log_level_LIBVLC_DEBUG: libvlc_log_level = 0;
#[doc = "< Important informational message"]
pub const libvlc_log_level_LIBVLC_NOTICE: libvlc_log_level = 2;
#[doc = "< Warning (potential error) message"]
pub const libvlc_log_level_LIBVLC_WARNING: libvlc_log_level = 3;
#[doc = "< Error message"]
pub const libvlc_log_level_LIBVLC_ERROR: libvlc_log_level = 4;
#[doc = " Logging messages level."]
#[doc = " \\note Future LibVLC versions may define new levels."]
pub type libvlc_log_level = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlc_log_t {
    _unused: [u8; 0],
}
pub type libvlc_log_t = vlc_log_t;
extern "C" {
    #[doc = " Gets log message debug infos."]
    #[doc = ""]
    #[doc = " This function retrieves self-debug information about a log message:"]
    #[doc = " - the name of the VLC module emitting the message,"]
    #[doc = " - the name of the source code module (i.e. file) and"]
    #[doc = " - the line number within the source code module."]
    #[doc = ""]
    #[doc = " The returned module name and file name will be NULL if unknown."]
    #[doc = " The returned line number will similarly be zero if unknown."]
    #[doc = ""]
    #[doc = " \\param ctx message context (as passed to the @ref libvlc_log_cb callback)"]
    #[doc = " \\param module module name storage (or NULL) [OUT]"]
    #[doc = " \\param file source code file name storage (or NULL) [OUT]"]
    #[doc = " \\param line source code file line number storage (or NULL) [OUT]"]
    #[doc = " \\warning The returned module name and source code file name, if non-NULL,"]
    #[doc = " are only valid until the logging callback returns."]
    #[doc = ""]
    #[doc = " \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_get_context(
        ctx: *const libvlc_log_t,
        module: *mut *const libc::c_char,
        file: *mut *const libc::c_char,
        line: *mut libc::c_uint,
    );
}
extern "C" {
    #[doc = " Gets log message info."]
    #[doc = ""]
    #[doc = " This function retrieves meta-information about a log message:"]
    #[doc = " - the type name of the VLC object emitting the message,"]
    #[doc = " - the object header if any, and"]
    #[doc = " - a temporaly-unique object identifier."]
    #[doc = ""]
    #[doc = " This information is mainly meant for <b>manual</b> troubleshooting."]
    #[doc = ""]
    #[doc = " The returned type name may be \"generic\" if unknown, but it cannot be NULL."]
    #[doc = " The returned header will be NULL if unset; in current versions, the header"]
    #[doc = " is used to distinguish for VLM inputs."]
    #[doc = " The returned object ID will be zero if the message is not associated with"]
    #[doc = " any VLC object."]
    #[doc = ""]
    #[doc = " \\param ctx message context (as passed to the @ref libvlc_log_cb callback)"]
    #[doc = " \\param name object name storage (or NULL) [OUT]"]
    #[doc = " \\param header object header (or NULL) [OUT]"]
    #[doc = " \\param id temporarily-unique object identifier (or 0) [OUT]"]
    #[doc = " \\warning The returned module name and source code file name, if non-NULL,"]
    #[doc = " are only valid until the logging callback returns."]
    #[doc = ""]
    #[doc = " \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_get_object(
        ctx: *const libvlc_log_t,
        name: *mut *const libc::c_char,
        header: *mut *const libc::c_char,
        id: *mut usize,
    );
}
#[doc = " Callback prototype for LibVLC log message handler."]
#[doc = ""]
#[doc = " \\param data data pointer as given to libvlc_log_set()"]
#[doc = " \\param level message level (@ref libvlc_log_level)"]
#[doc = " \\param ctx message context (meta-information about the message)"]
#[doc = " \\param fmt printf() format string (as defined by ISO C11)"]
#[doc = " \\param args variable argument list for the format"]
#[doc = " \\note Log message handlers <b>must</b> be thread-safe."]
#[doc = " \\warning The message context pointer, the format string parameters and the"]
#[doc = "          variable arguments are only valid until the callback returns."]
pub type libvlc_log_cb = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut libc::c_void,
        level: libc::c_int,
        ctx: *const libvlc_log_t,
        fmt: *const libc::c_char,
        args: *mut __va_list_tag,
    ),
>;
extern "C" {
    #[doc = " Unsets the logging callback."]
    #[doc = ""]
    #[doc = " This function deregisters the logging callback for a LibVLC instance."]
    #[doc = " This is rarely needed as the callback is implicitly unset when the instance"]
    #[doc = " is destroyed."]
    #[doc = ""]
    #[doc = " \\note This function will wait for any pending callbacks invocation to"]
    #[doc = " complete (causing a deadlock if called from within the callback)."]
    #[doc = ""]
    #[doc = " \\param p_instance libvlc instance"]
    #[doc = " \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_unset(p_instance: *mut libvlc_instance_t);
}
extern "C" {
    #[doc = " Sets the logging callback for a LibVLC instance."]
    #[doc = ""]
    #[doc = " This function is thread-safe: it will wait for any pending callbacks"]
    #[doc = " invocation to complete."]
    #[doc = ""]
    #[doc = " \\param cb callback function pointer"]
    #[doc = " \\param data opaque data pointer for the callback function"]
    #[doc = ""]
    #[doc = " \\note Some log messages (especially debug) are emitted by LibVLC while"]
    #[doc = " is being initialized. These messages cannot be captured with this interface."]
    #[doc = ""]
    #[doc = " \\warning A deadlock may occur if this function is called from the callback."]
    #[doc = ""]
    #[doc = " \\param p_instance libvlc instance"]
    #[doc = " \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_set(
        p_instance: *mut libvlc_instance_t,
        cb: libvlc_log_cb,
        data: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Sets up logging to a file."]
    #[doc = " \\param p_instance libvlc instance"]
    #[doc = " \\param stream FILE pointer opened for writing"]
    #[doc = "         (the FILE pointer must remain valid until libvlc_log_unset())"]
    #[doc = " \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_set_file(p_instance: *mut libvlc_instance_t, stream: *mut FILE);
}
#[doc = " Description of a module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_module_description_t {
    pub psz_name: *mut libc::c_char,
    pub psz_shortname: *mut libc::c_char,
    pub psz_longname: *mut libc::c_char,
    pub psz_help: *mut libc::c_char,
    pub p_next: *mut libvlc_module_description_t,
}
#[test]
fn bindgen_test_layout_libvlc_module_description_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_module_description_t>(),
        40usize,
        concat!("Size of: ", stringify!(libvlc_module_description_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_module_description_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_module_description_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_module_description_t>())).psz_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_module_description_t),
            "::",
            stringify!(psz_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_module_description_t>())).psz_shortname as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_module_description_t),
            "::",
            stringify!(psz_shortname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_module_description_t>())).psz_longname as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_module_description_t),
            "::",
            stringify!(psz_longname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_module_description_t>())).psz_help as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_module_description_t),
            "::",
            stringify!(psz_help)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_module_description_t>())).p_next as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_module_description_t),
            "::",
            stringify!(p_next)
        )
    );
}
extern "C" {
    #[doc = " Release a list of module descriptions."]
    #[doc = ""]
    #[doc = " \\param p_list the list to be released"]
    pub fn libvlc_module_description_list_release(p_list: *mut libvlc_module_description_t);
}
extern "C" {
    #[doc = " Returns a list of audio filters that are available."]
    #[doc = ""]
    #[doc = " \\param p_instance libvlc instance"]
    #[doc = ""]
    #[doc = " \\return a list of module descriptions. It should be freed with libvlc_module_description_list_release()."]
    #[doc = "         In case of an error, NULL is returned."]
    #[doc = ""]
    #[doc = " \\see libvlc_module_description_t"]
    #[doc = " \\see libvlc_module_description_list_release"]
    pub fn libvlc_audio_filter_list_get(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_module_description_t;
}
extern "C" {
    #[doc = " Returns a list of video filters that are available."]
    #[doc = ""]
    #[doc = " \\param p_instance libvlc instance"]
    #[doc = ""]
    #[doc = " \\return a list of module descriptions. It should be freed with libvlc_module_description_list_release()."]
    #[doc = "         In case of an error, NULL is returned."]
    #[doc = ""]
    #[doc = " \\see libvlc_module_description_t"]
    #[doc = " \\see libvlc_module_description_list_release"]
    pub fn libvlc_video_filter_list_get(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_module_description_t;
}
extern "C" {
    #[doc = " Return the current time as defined by LibVLC. The unit is the microsecond."]
    #[doc = " Time increases monotonically (regardless of time zone changes and RTC"]
    #[doc = " adjustments)."]
    #[doc = " The origin is arbitrary but consistent across the whole system"]
    #[doc = " (e.g. the system uptime, the time since the system was booted)."]
    #[doc = " \\note On systems that support it, the POSIX monotonic clock is used."]
    pub fn libvlc_clock() -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_renderer_discoverer_t {
    _unused: [u8; 0],
}
#[doc = " Renderer discoverer description"]
#[doc = ""]
#[doc = " \\see libvlc_renderer_discoverer_list_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_rd_description_t {
    pub psz_name: *mut libc::c_char,
    pub psz_longname: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_libvlc_rd_description_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_rd_description_t>(),
        16usize,
        concat!("Size of: ", stringify!(libvlc_rd_description_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_rd_description_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_rd_description_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_rd_description_t>())).psz_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_rd_description_t),
            "::",
            stringify!(psz_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_rd_description_t>())).psz_longname as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_rd_description_t),
            "::",
            stringify!(psz_longname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_renderer_item_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Hold a renderer item, i.e. creates a new reference"]
    #[doc = ""]
    #[doc = " This functions need to called from the libvlc_RendererDiscovererItemAdded"]
    #[doc = " callback if the libvlc user wants to use this item after. (for display or"]
    #[doc = " for passing it to the mediaplayer for example)."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\return the current item"]
    pub fn libvlc_renderer_item_hold(
        p_item: *mut libvlc_renderer_item_t,
    ) -> *mut libvlc_renderer_item_t;
}
extern "C" {
    #[doc = " Releases a renderer item, i.e. decrements its reference counter"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_renderer_item_release(p_item: *mut libvlc_renderer_item_t);
}
extern "C" {
    #[doc = " Get the human readable name of a renderer item"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\return the name of the item (can't be NULL, must *not* be freed)"]
    pub fn libvlc_renderer_item_name(p_item: *const libvlc_renderer_item_t) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type (not translated) of a renderer item. For now, the type can only"]
    #[doc = " be \"chromecast\" (\"upnp\", \"airplay\" may come later)."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\return the type of the item (can't be NULL, must *not* be freed)"]
    pub fn libvlc_renderer_item_type(p_item: *const libvlc_renderer_item_t) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the icon uri of a renderer item"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\return the uri of the item's icon (can be NULL, must *not* be freed)"]
    pub fn libvlc_renderer_item_icon_uri(
        p_item: *const libvlc_renderer_item_t,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the flags of a renderer item"]
    #[doc = ""]
    #[doc = " \\see LIBVLC_RENDERER_CAN_AUDIO"]
    #[doc = " \\see LIBVLC_RENDERER_CAN_VIDEO"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\return bitwise flag: capabilities of the renderer, see"]
    pub fn libvlc_renderer_item_flags(p_item: *const libvlc_renderer_item_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a renderer discoverer object by name"]
    #[doc = ""]
    #[doc = " After this object is created, you should attach to events in order to be"]
    #[doc = " notified of the discoverer events."]
    #[doc = ""]
    #[doc = " You need to call libvlc_renderer_discoverer_start() in order to start the"]
    #[doc = " discovery."]
    #[doc = ""]
    #[doc = " \\see libvlc_renderer_discoverer_event_manager()"]
    #[doc = " \\see libvlc_renderer_discoverer_start()"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\param p_inst libvlc instance"]
    #[doc = " \\param psz_name service name; use libvlc_renderer_discoverer_list_get() to"]
    #[doc = " get a list of the discoverer names available in this libVLC instance"]
    #[doc = " \\return media discover object or NULL in case of error"]
    pub fn libvlc_renderer_discoverer_new(
        p_inst: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> *mut libvlc_renderer_discoverer_t;
}
extern "C" {
    #[doc = " Release a renderer discoverer object"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\param p_rd renderer discoverer object"]
    pub fn libvlc_renderer_discoverer_release(p_rd: *mut libvlc_renderer_discoverer_t);
}
extern "C" {
    #[doc = " Start renderer discovery"]
    #[doc = ""]
    #[doc = " To stop it, call libvlc_renderer_discoverer_stop() or"]
    #[doc = " libvlc_renderer_discoverer_release() directly."]
    #[doc = ""]
    #[doc = " \\see libvlc_renderer_discoverer_stop()"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\param p_rd renderer discoverer object"]
    #[doc = " \\return -1 in case of error, 0 otherwise"]
    pub fn libvlc_renderer_discoverer_start(p_rd: *mut libvlc_renderer_discoverer_t)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Stop renderer discovery."]
    #[doc = ""]
    #[doc = " \\see libvlc_renderer_discoverer_start()"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\param p_rd renderer discoverer object"]
    pub fn libvlc_renderer_discoverer_stop(p_rd: *mut libvlc_renderer_discoverer_t);
}
extern "C" {
    #[doc = " Get the event manager of the renderer discoverer"]
    #[doc = ""]
    #[doc = " The possible events to attach are @ref libvlc_RendererDiscovererItemAdded"]
    #[doc = " and @ref libvlc_RendererDiscovererItemDeleted."]
    #[doc = ""]
    #[doc = " The @ref libvlc_renderer_item_t struct passed to event callbacks is owned by"]
    #[doc = " VLC, users should take care of holding/releasing this struct for their"]
    #[doc = " internal usage."]
    #[doc = ""]
    #[doc = " \\see libvlc_event_t.u.renderer_discoverer_item_added.item"]
    #[doc = " \\see libvlc_event_t.u.renderer_discoverer_item_removed.item"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    #[doc = ""]
    #[doc = " \\return a valid event manager (can't fail)"]
    pub fn libvlc_renderer_discoverer_event_manager(
        p_rd: *mut libvlc_renderer_discoverer_t,
    ) -> *mut libvlc_event_manager_t;
}
extern "C" {
    #[doc = " Get media discoverer services"]
    #[doc = ""]
    #[doc = " \\see libvlc_renderer_list_release()"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later"]
    #[doc = ""]
    #[doc = " \\param p_inst libvlc instance"]
    #[doc = " \\param ppp_services address to store an allocated array of renderer"]
    #[doc = " discoverer services (must be freed with libvlc_renderer_list_release() by"]
    #[doc = " the caller) [OUT]"]
    #[doc = ""]
    #[doc = " \\return the number of media discoverer services (0 on error)"]
    pub fn libvlc_renderer_discoverer_list_get(
        p_inst: *mut libvlc_instance_t,
        ppp_services: *mut *mut *mut libvlc_rd_description_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Release an array of media discoverer services"]
    #[doc = ""]
    #[doc = " \\see libvlc_renderer_discoverer_list_get()"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later"]
    #[doc = ""]
    #[doc = " \\param pp_services array to release"]
    #[doc = " \\param i_count number of elements in the array"]
    pub fn libvlc_renderer_discoverer_list_release(
        pp_services: *mut *mut libvlc_rd_description_t,
        i_count: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_picture_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_picture_list_t {
    _unused: [u8; 0],
}
pub const libvlc_picture_type_t_libvlc_picture_Argb: libvlc_picture_type_t = 0;
pub const libvlc_picture_type_t_libvlc_picture_Png: libvlc_picture_type_t = 1;
pub const libvlc_picture_type_t_libvlc_picture_Jpg: libvlc_picture_type_t = 2;
pub type libvlc_picture_type_t = libc::c_uint;
extern "C" {
    #[doc = " Increment the reference count of this picture."]
    #[doc = ""]
    #[doc = " \\see libvlc_picture_release()"]
    #[doc = " \\param pic A picture object"]
    pub fn libvlc_picture_retain(pic: *mut libvlc_picture_t);
}
extern "C" {
    #[doc = " Decrement the reference count of this picture."]
    #[doc = " When the reference count reaches 0, the picture will be released."]
    #[doc = " The picture must not be accessed after calling this function."]
    #[doc = ""]
    #[doc = " \\see libvlc_picture_retain"]
    #[doc = " \\param pic A picture object"]
    pub fn libvlc_picture_release(pic: *mut libvlc_picture_t);
}
extern "C" {
    #[doc = " Saves this picture to a file. The image format is the same as the one"]
    #[doc = " returned by \\link libvlc_picture_type \\endlink"]
    #[doc = ""]
    #[doc = " \\param pic A picture object"]
    #[doc = " \\param path The path to the generated file"]
    #[doc = " \\return 0 in case of success, -1 otherwise"]
    pub fn libvlc_picture_save(
        pic: *const libvlc_picture_t,
        path: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the image internal buffer, including potential padding."]
    #[doc = " The libvlc_picture_t owns the returned buffer, which must not be modified nor"]
    #[doc = " freed."]
    #[doc = ""]
    #[doc = " \\param pic A picture object"]
    #[doc = " \\param size A pointer to a size_t that will hold the size of the buffer [required]"]
    #[doc = " \\return A pointer to the internal buffer."]
    pub fn libvlc_picture_get_buffer(
        pic: *const libvlc_picture_t,
        size: *mut size_t,
    ) -> *const libc::c_uchar;
}
extern "C" {
    #[doc = " Returns the picture type"]
    #[doc = ""]
    #[doc = " \\param pic A picture object"]
    #[doc = " \\see libvlc_picture_type_t"]
    pub fn libvlc_picture_type(pic: *const libvlc_picture_t) -> libvlc_picture_type_t;
}
extern "C" {
    #[doc = " Returns the image stride, ie. the number of bytes per line."]
    #[doc = " This can only be called on images of type libvlc_picture_Argb"]
    #[doc = ""]
    #[doc = " \\param pic A picture object"]
    pub fn libvlc_picture_get_stride(pic: *const libvlc_picture_t) -> libc::c_uint;
}
extern "C" {
    #[doc = " Returns the width of the image in pixels"]
    #[doc = ""]
    #[doc = " \\param pic A picture object"]
    pub fn libvlc_picture_get_width(pic: *const libvlc_picture_t) -> libc::c_uint;
}
extern "C" {
    #[doc = " Returns the height of the image in pixels"]
    #[doc = ""]
    #[doc = " \\param pic A picture object"]
    pub fn libvlc_picture_get_height(pic: *const libvlc_picture_t) -> libc::c_uint;
}
extern "C" {
    #[doc = " Returns the time at which this picture was generated, in milliseconds"]
    #[doc = " \\param pic A picture object"]
    pub fn libvlc_picture_get_time(pic: *const libvlc_picture_t) -> libvlc_time_t;
}
extern "C" {
    #[doc = " Returns the number of pictures in the list"]
    pub fn libvlc_picture_list_count(list: *const libvlc_picture_list_t) -> size_t;
}
extern "C" {
    #[doc = " Returns the picture at the provided index."]
    #[doc = ""]
    #[doc = " If the index is out of bound, the result is undefined."]
    pub fn libvlc_picture_list_at(
        list: *const libvlc_picture_list_t,
        index: size_t,
    ) -> *mut libvlc_picture_t;
}
extern "C" {
    #[doc = " Destroys a picture list and releases the pictures it contains"]
    #[doc = " \\param list The list to destroy"]
    #[doc = ""]
    #[doc = " Calling this function with a NULL list is safe and will return immediately"]
    pub fn libvlc_picture_list_destroy(list: *mut libvlc_picture_list_t);
}
pub const libvlc_track_type_t_libvlc_track_unknown: libvlc_track_type_t = -1;
pub const libvlc_track_type_t_libvlc_track_audio: libvlc_track_type_t = 0;
pub const libvlc_track_type_t_libvlc_track_video: libvlc_track_type_t = 1;
pub const libvlc_track_type_t_libvlc_track_text: libvlc_track_type_t = 2;
#[doc = " \\defgroup libvlc_media_track LibVLC media track"]
#[doc = " \\ingroup libvlc"]
#[doc = " @ref libvlc_media_track_t is an abstract representation of a media track."]
#[doc = " @{"]
#[doc = " \\file"]
#[doc = " LibVLC media track"]
pub type libvlc_track_type_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_audio_track_t {
    pub i_channels: libc::c_uint,
    pub i_rate: libc::c_uint,
}
#[test]
fn bindgen_test_layout_libvlc_audio_track_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_audio_track_t>(),
        8usize,
        concat!("Size of: ", stringify!(libvlc_audio_track_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_audio_track_t>(),
        4usize,
        concat!("Alignment of ", stringify!(libvlc_audio_track_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_audio_track_t>())).i_channels as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_audio_track_t),
            "::",
            stringify!(i_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_audio_track_t>())).i_rate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_audio_track_t),
            "::",
            stringify!(i_rate)
        )
    );
}
#[doc = "< Normal. Top line represents top, left column left."]
pub const libvlc_video_orient_t_libvlc_video_orient_top_left: libvlc_video_orient_t = 0;
#[doc = "< Flipped horizontally"]
pub const libvlc_video_orient_t_libvlc_video_orient_top_right: libvlc_video_orient_t = 1;
#[doc = "< Flipped vertically"]
pub const libvlc_video_orient_t_libvlc_video_orient_bottom_left: libvlc_video_orient_t = 2;
#[doc = "< Rotated 180 degrees"]
pub const libvlc_video_orient_t_libvlc_video_orient_bottom_right: libvlc_video_orient_t = 3;
#[doc = "< Transposed"]
pub const libvlc_video_orient_t_libvlc_video_orient_left_top: libvlc_video_orient_t = 4;
#[doc = "< Rotated 90 degrees clockwise (or 270 anti-clockwise)"]
pub const libvlc_video_orient_t_libvlc_video_orient_left_bottom: libvlc_video_orient_t = 5;
#[doc = "< Rotated 90 degrees anti-clockwise"]
pub const libvlc_video_orient_t_libvlc_video_orient_right_top: libvlc_video_orient_t = 6;
#[doc = "< Anti-transposed"]
pub const libvlc_video_orient_t_libvlc_video_orient_right_bottom: libvlc_video_orient_t = 7;
pub type libvlc_video_orient_t = libc::c_uint;
pub const libvlc_video_projection_t_libvlc_video_projection_rectangular: libvlc_video_projection_t =
    0;
#[doc = "< 360 spherical"]
pub const libvlc_video_projection_t_libvlc_video_projection_equirectangular:
    libvlc_video_projection_t = 1;
pub const libvlc_video_projection_t_libvlc_video_projection_cubemap_layout_standard:
    libvlc_video_projection_t = 256;
pub type libvlc_video_projection_t = libc::c_uint;
#[doc = " Viewpoint"]
#[doc = ""]
#[doc = " \\warning allocate using libvlc_video_new_viewpoint()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_viewpoint_t {
    #[doc = "< view point yaw in degrees  ]-180;180]"]
    pub f_yaw: f32,
    #[doc = "< view point pitch in degrees  ]-90;90]"]
    pub f_pitch: f32,
    #[doc = "< view point roll in degrees ]-180;180]"]
    pub f_roll: f32,
    #[doc = "< field of view in degrees ]0;180[ (default 80.)"]
    pub f_field_of_view: f32,
}
#[test]
fn bindgen_test_layout_libvlc_video_viewpoint_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_viewpoint_t>(),
        16usize,
        concat!("Size of: ", stringify!(libvlc_video_viewpoint_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_viewpoint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(libvlc_video_viewpoint_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_video_viewpoint_t>())).f_yaw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_viewpoint_t),
            "::",
            stringify!(f_yaw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_viewpoint_t>())).f_pitch as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_viewpoint_t),
            "::",
            stringify!(f_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_viewpoint_t>())).f_roll as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_viewpoint_t),
            "::",
            stringify!(f_roll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_viewpoint_t>())).f_field_of_view as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_viewpoint_t),
            "::",
            stringify!(f_field_of_view)
        )
    );
}
#[doc = "< No stereoscopy: 2D picture."]
pub const libvlc_video_multiview_t_libvlc_video_multiview_2d: libvlc_video_multiview_t = 0;
#[doc = "< Side-by-side"]
pub const libvlc_video_multiview_t_libvlc_video_multiview_stereo_sbs: libvlc_video_multiview_t = 1;
#[doc = "< Top-bottom"]
pub const libvlc_video_multiview_t_libvlc_video_multiview_stereo_tb: libvlc_video_multiview_t = 2;
#[doc = "< Row sequential"]
pub const libvlc_video_multiview_t_libvlc_video_multiview_stereo_row: libvlc_video_multiview_t = 3;
#[doc = "< Column sequential"]
pub const libvlc_video_multiview_t_libvlc_video_multiview_stereo_col: libvlc_video_multiview_t = 4;
#[doc = "< Frame sequential"]
pub const libvlc_video_multiview_t_libvlc_video_multiview_stereo_frame: libvlc_video_multiview_t =
    5;
#[doc = "< Checkerboard pattern"]
pub const libvlc_video_multiview_t_libvlc_video_multiview_stereo_checkerboard:
    libvlc_video_multiview_t = 6;
pub type libvlc_video_multiview_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_track_t {
    pub i_height: libc::c_uint,
    pub i_width: libc::c_uint,
    pub i_sar_num: libc::c_uint,
    pub i_sar_den: libc::c_uint,
    pub i_frame_rate_num: libc::c_uint,
    pub i_frame_rate_den: libc::c_uint,
    pub i_orientation: libvlc_video_orient_t,
    pub i_projection: libvlc_video_projection_t,
    #[doc = "< Initial view point"]
    pub pose: libvlc_video_viewpoint_t,
    pub i_multiview: libvlc_video_multiview_t,
}
#[test]
fn bindgen_test_layout_libvlc_video_track_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_track_t>(),
        52usize,
        concat!("Size of: ", stringify!(libvlc_video_track_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_track_t>(),
        4usize,
        concat!("Alignment of ", stringify!(libvlc_video_track_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_video_track_t>())).i_height as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_video_track_t>())).i_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_video_track_t>())).i_sar_num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_sar_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_video_track_t>())).i_sar_den as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_sar_den)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_track_t>())).i_frame_rate_num as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_frame_rate_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_track_t>())).i_frame_rate_den as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_frame_rate_den)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_track_t>())).i_orientation as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_orientation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_track_t>())).i_projection as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_projection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_video_track_t>())).pose as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(pose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_track_t>())).i_multiview as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_track_t),
            "::",
            stringify!(i_multiview)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_subtitle_track_t {
    pub psz_encoding: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_libvlc_subtitle_track_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_subtitle_track_t>(),
        8usize,
        concat!("Size of: ", stringify!(libvlc_subtitle_track_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_subtitle_track_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_subtitle_track_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_subtitle_track_t>())).psz_encoding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_subtitle_track_t),
            "::",
            stringify!(psz_encoding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libvlc_media_track_t {
    pub i_codec: u32,
    pub i_original_fourcc: u32,
    pub i_id: libc::c_int,
    pub i_type: libvlc_track_type_t,
    pub i_profile: libc::c_int,
    pub i_level: libc::c_int,
    pub __bindgen_anon_1: libvlc_media_track_t__bindgen_ty_1,
    pub i_bitrate: libc::c_uint,
    pub psz_language: *mut libc::c_char,
    pub psz_description: *mut libc::c_char,
    #[doc = " String identifier of track, can be used to save the track preference"]
    #[doc = " from an other LibVLC run, only valid when the track is fetch from a"]
    #[doc = " media_player"]
    pub psz_id: *const libc::c_char,
    #[doc = " A string identifier is stable when it is certified to be the same"]
    #[doc = " across different playback instances for the same track, only valid when"]
    #[doc = " the track is fetch from a media_player"]
    pub id_stable: bool,
    #[doc = " Name of the track, only valid when the track is fetch from a"]
    #[doc = " media_player"]
    pub psz_name: *mut libc::c_char,
    #[doc = " true if the track is selected, only valid when the track is fetch from"]
    #[doc = " a media_player"]
    pub selected: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union libvlc_media_track_t__bindgen_ty_1 {
    pub audio: *mut libvlc_audio_track_t,
    pub video: *mut libvlc_video_track_t,
    pub subtitle: *mut libvlc_subtitle_track_t,
}
#[test]
fn bindgen_test_layout_libvlc_media_track_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_media_track_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(libvlc_media_track_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_media_track_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_media_track_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_track_t__bindgen_ty_1>())).audio as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t__bindgen_ty_1),
            "::",
            stringify!(audio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_track_t__bindgen_ty_1>())).video as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t__bindgen_ty_1),
            "::",
            stringify!(video)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_track_t__bindgen_ty_1>())).subtitle as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t__bindgen_ty_1),
            "::",
            stringify!(subtitle)
        )
    );
}
#[test]
fn bindgen_test_layout_libvlc_media_track_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_media_track_t>(),
        88usize,
        concat!("Size of: ", stringify!(libvlc_media_track_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_media_track_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_media_track_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).i_codec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(i_codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_track_t>())).i_original_fourcc as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(i_original_fourcc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).i_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(i_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).i_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(i_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).i_profile as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(i_profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).i_level as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(i_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).i_bitrate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(i_bitrate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_track_t>())).psz_language as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(psz_language)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_track_t>())).psz_description as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(psz_description)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).psz_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(psz_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).id_stable as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(id_stable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).psz_name as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(psz_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_track_t>())).selected as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_track_t),
            "::",
            stringify!(selected)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_tracklist_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the number of tracks in a tracklist"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param list valid tracklist"]
    #[doc = ""]
    #[doc = " \\return number of tracks, or 0 if the list is empty"]
    pub fn libvlc_media_tracklist_count(list: *const libvlc_media_tracklist_t) -> size_t;
}
extern "C" {
    #[doc = " Get a track at a specific index"]
    #[doc = ""]
    #[doc = " \\warning The behaviour is undefined if the index is not valid."]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param list valid tracklist"]
    #[doc = " \\param index valid index in the range [0; count["]
    #[doc = ""]
    #[doc = " \\return a valid track (can't be NULL if libvlc_media_tracklist_count()"]
    #[doc = " returned a valid count)"]
    pub fn libvlc_media_tracklist_at(
        list: *mut libvlc_media_tracklist_t,
        index: size_t,
    ) -> *mut libvlc_media_track_t;
}
extern "C" {
    #[doc = " Release a tracklist"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_get_tracklist"]
    #[doc = " \\see libvlc_media_player_get_tracklist"]
    #[doc = ""]
    #[doc = " \\param list valid tracklist"]
    pub fn libvlc_media_tracklist_delete(list: *mut libvlc_media_tracklist_t);
}
extern "C" {
    #[doc = " Hold a single track reference"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " This function can be used to hold a track from a tracklist. In that case,"]
    #[doc = " the track can outlive its tracklist."]
    #[doc = ""]
    #[doc = " \\param track valid track"]
    #[doc = " \\return the same track, need to be released with libvlc_media_track_release()"]
    pub fn libvlc_media_track_hold(track: *mut libvlc_media_track_t) -> *mut libvlc_media_track_t;
}
extern "C" {
    #[doc = " Release a single track"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\warning Tracks from a tracklist are released alongside the list with"]
    #[doc = " libvlc_media_tracklist_delete()."]
    #[doc = ""]
    #[doc = " \\note You only need to release tracks previously held with"]
    #[doc = " libvlc_media_track_hold() or returned by"]
    #[doc = " libvlc_media_player_get_selected_track() and"]
    #[doc = " libvlc_media_player_get_track_from_id()"]
    #[doc = ""]
    #[doc = " \\param track valid track"]
    pub fn libvlc_media_track_release(track: *mut libvlc_media_track_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_t {
    _unused: [u8; 0],
}
pub const libvlc_meta_t_libvlc_meta_Title: libvlc_meta_t = 0;
pub const libvlc_meta_t_libvlc_meta_Artist: libvlc_meta_t = 1;
pub const libvlc_meta_t_libvlc_meta_Genre: libvlc_meta_t = 2;
pub const libvlc_meta_t_libvlc_meta_Copyright: libvlc_meta_t = 3;
pub const libvlc_meta_t_libvlc_meta_Album: libvlc_meta_t = 4;
pub const libvlc_meta_t_libvlc_meta_TrackNumber: libvlc_meta_t = 5;
pub const libvlc_meta_t_libvlc_meta_Description: libvlc_meta_t = 6;
pub const libvlc_meta_t_libvlc_meta_Rating: libvlc_meta_t = 7;
pub const libvlc_meta_t_libvlc_meta_Date: libvlc_meta_t = 8;
pub const libvlc_meta_t_libvlc_meta_Setting: libvlc_meta_t = 9;
pub const libvlc_meta_t_libvlc_meta_URL: libvlc_meta_t = 10;
pub const libvlc_meta_t_libvlc_meta_Language: libvlc_meta_t = 11;
pub const libvlc_meta_t_libvlc_meta_NowPlaying: libvlc_meta_t = 12;
pub const libvlc_meta_t_libvlc_meta_Publisher: libvlc_meta_t = 13;
pub const libvlc_meta_t_libvlc_meta_EncodedBy: libvlc_meta_t = 14;
pub const libvlc_meta_t_libvlc_meta_ArtworkURL: libvlc_meta_t = 15;
pub const libvlc_meta_t_libvlc_meta_TrackID: libvlc_meta_t = 16;
pub const libvlc_meta_t_libvlc_meta_TrackTotal: libvlc_meta_t = 17;
pub const libvlc_meta_t_libvlc_meta_Director: libvlc_meta_t = 18;
pub const libvlc_meta_t_libvlc_meta_Season: libvlc_meta_t = 19;
pub const libvlc_meta_t_libvlc_meta_Episode: libvlc_meta_t = 20;
pub const libvlc_meta_t_libvlc_meta_ShowName: libvlc_meta_t = 21;
pub const libvlc_meta_t_libvlc_meta_Actors: libvlc_meta_t = 22;
pub const libvlc_meta_t_libvlc_meta_AlbumArtist: libvlc_meta_t = 23;
pub const libvlc_meta_t_libvlc_meta_DiscNumber: libvlc_meta_t = 24;
pub const libvlc_meta_t_libvlc_meta_DiscTotal: libvlc_meta_t = 25;
#[doc = " Meta data types"]
pub type libvlc_meta_t = libc::c_uint;
pub const libvlc_state_t_libvlc_NothingSpecial: libvlc_state_t = 0;
pub const libvlc_state_t_libvlc_Opening: libvlc_state_t = 1;
pub const libvlc_state_t_libvlc_Buffering: libvlc_state_t = 2;
pub const libvlc_state_t_libvlc_Playing: libvlc_state_t = 3;
pub const libvlc_state_t_libvlc_Paused: libvlc_state_t = 4;
pub const libvlc_state_t_libvlc_Stopped: libvlc_state_t = 5;
pub const libvlc_state_t_libvlc_Stopping: libvlc_state_t = 6;
pub const libvlc_state_t_libvlc_Error: libvlc_state_t = 7;
#[doc = " libvlc media or media_player state"]
pub type libvlc_state_t = libc::c_uint;
pub const libvlc_media_option_trusted: libc::c_uint = 2;
pub const libvlc_media_option_unique: libc::c_uint = 256;
pub type _bindgen_ty_1 = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_stats_t {
    pub i_read_bytes: libc::c_int,
    pub f_input_bitrate: f32,
    pub i_demux_read_bytes: libc::c_int,
    pub f_demux_bitrate: f32,
    pub i_demux_corrupted: libc::c_int,
    pub i_demux_discontinuity: libc::c_int,
    pub i_decoded_video: libc::c_int,
    pub i_decoded_audio: libc::c_int,
    pub i_displayed_pictures: libc::c_int,
    pub i_late_pictures: libc::c_int,
    pub i_lost_pictures: libc::c_int,
    pub i_played_abuffers: libc::c_int,
    pub i_lost_abuffers: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_media_stats_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_media_stats_t>(),
        52usize,
        concat!("Size of: ", stringify!(libvlc_media_stats_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_media_stats_t>(),
        4usize,
        concat!("Alignment of ", stringify!(libvlc_media_stats_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_read_bytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_read_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).f_input_bitrate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(f_input_bitrate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_demux_read_bytes as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_demux_read_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).f_demux_bitrate as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(f_demux_bitrate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_demux_corrupted as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_demux_corrupted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_demux_discontinuity as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_demux_discontinuity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_decoded_video as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_decoded_video)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_decoded_audio as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_decoded_audio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_displayed_pictures as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_displayed_pictures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_late_pictures as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_late_pictures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_lost_pictures as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_lost_pictures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_played_abuffers as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_played_abuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_stats_t>())).i_lost_abuffers as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_stats_t),
            "::",
            stringify!(i_lost_abuffers)
        )
    );
}
pub const libvlc_media_type_t_libvlc_media_type_unknown: libvlc_media_type_t = 0;
pub const libvlc_media_type_t_libvlc_media_type_file: libvlc_media_type_t = 1;
pub const libvlc_media_type_t_libvlc_media_type_directory: libvlc_media_type_t = 2;
pub const libvlc_media_type_t_libvlc_media_type_disc: libvlc_media_type_t = 3;
pub const libvlc_media_type_t_libvlc_media_type_stream: libvlc_media_type_t = 4;
pub const libvlc_media_type_t_libvlc_media_type_playlist: libvlc_media_type_t = 5;
#[doc = " Media type"]
#[doc = ""]
#[doc = " \\see libvlc_media_get_type"]
pub type libvlc_media_type_t = libc::c_uint;
#[doc = " Parse media if it's a local file"]
pub const libvlc_media_parse_flag_t_libvlc_media_parse_local: libvlc_media_parse_flag_t = 0;
#[doc = " Parse media even if it's a network file"]
pub const libvlc_media_parse_flag_t_libvlc_media_parse_network: libvlc_media_parse_flag_t = 1;
#[doc = " Fetch meta and cover art using local resources"]
pub const libvlc_media_parse_flag_t_libvlc_media_fetch_local: libvlc_media_parse_flag_t = 2;
#[doc = " Fetch meta and cover art using network resources"]
pub const libvlc_media_parse_flag_t_libvlc_media_fetch_network: libvlc_media_parse_flag_t = 4;
#[doc = " Interact with the user (via libvlc_dialog_cbs) when preparsing this item"]
#[doc = " (and not its sub items). Set this flag in order to receive a callback"]
#[doc = " when the input is asking for credentials."]
pub const libvlc_media_parse_flag_t_libvlc_media_do_interact: libvlc_media_parse_flag_t = 8;
#[doc = " Parse flags used by libvlc_media_parse_with_options()"]
#[doc = ""]
#[doc = " \\see libvlc_media_parse_with_options"]
pub type libvlc_media_parse_flag_t = libc::c_uint;
pub const libvlc_media_parsed_status_t_libvlc_media_parsed_status_skipped:
    libvlc_media_parsed_status_t = 1;
pub const libvlc_media_parsed_status_t_libvlc_media_parsed_status_failed:
    libvlc_media_parsed_status_t = 2;
pub const libvlc_media_parsed_status_t_libvlc_media_parsed_status_timeout:
    libvlc_media_parsed_status_t = 3;
pub const libvlc_media_parsed_status_t_libvlc_media_parsed_status_done:
    libvlc_media_parsed_status_t = 4;
#[doc = " Parse status used sent by libvlc_media_parse_with_options() or returned by"]
#[doc = " libvlc_media_get_parsed_status()"]
#[doc = ""]
#[doc = " \\see libvlc_media_parse_with_options"]
#[doc = " \\see libvlc_media_get_parsed_status"]
pub type libvlc_media_parsed_status_t = libc::c_uint;
pub const libvlc_media_slave_type_t_libvlc_media_slave_type_subtitle: libvlc_media_slave_type_t = 0;
pub const libvlc_media_slave_type_t_libvlc_media_slave_type_generic: libvlc_media_slave_type_t = 1;
pub const libvlc_media_slave_type_t_libvlc_media_slave_type_audio: libvlc_media_slave_type_t = 1;
#[doc = " Type of a media slave: subtitle or audio."]
pub type libvlc_media_slave_type_t = libc::c_uint;
#[doc = " A slave of a libvlc_media_t"]
#[doc = " \\see libvlc_media_slaves_get"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_slave_t {
    pub psz_uri: *mut libc::c_char,
    pub i_type: libvlc_media_slave_type_t,
    pub i_priority: libc::c_uint,
}
#[test]
fn bindgen_test_layout_libvlc_media_slave_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_media_slave_t>(),
        16usize,
        concat!("Size of: ", stringify!(libvlc_media_slave_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_media_slave_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_media_slave_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_slave_t>())).psz_uri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_slave_t),
            "::",
            stringify!(psz_uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_media_slave_t>())).i_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_slave_t),
            "::",
            stringify!(i_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_slave_t>())).i_priority as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_slave_t),
            "::",
            stringify!(i_priority)
        )
    );
}
#[doc = " Callback prototype to open a custom bitstream input media."]
#[doc = ""]
#[doc = " The same media item can be opened multiple times. Each time, this callback"]
#[doc = " is invoked. It should allocate and initialize any instance-specific"]
#[doc = " resources, then store them in *datap. The instance resources can be freed"]
#[doc = " in the @ref libvlc_media_close_cb callback."]
#[doc = ""]
#[doc = " \\param opaque private pointer as passed to libvlc_media_new_callbacks()"]
#[doc = " \\param datap storage space for a private data pointer [OUT]"]
#[doc = " \\param sizep byte length of the bitstream or UINT64_MAX if unknown [OUT]"]
#[doc = ""]
#[doc = " \\note For convenience, *datap is initially NULL and *sizep is initially 0."]
#[doc = ""]
#[doc = " \\return 0 on success, non-zero on error. In case of failure, the other"]
#[doc = " callbacks will not be invoked and any value stored in *datap and *sizep is"]
#[doc = " discarded."]
pub type libvlc_media_open_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        datap: *mut *mut libc::c_void,
        sizep: *mut u64,
    ) -> libc::c_int,
>;
#[doc = " Callback prototype to read data from a custom bitstream input media."]
#[doc = ""]
#[doc = " \\param opaque private pointer as set by the @ref libvlc_media_open_cb"]
#[doc = "               callback"]
#[doc = " \\param buf start address of the buffer to read data into"]
#[doc = " \\param len bytes length of the buffer"]
#[doc = ""]
#[doc = " \\return strictly positive number of bytes read, 0 on end-of-stream,"]
#[doc = "         or -1 on non-recoverable error"]
#[doc = ""]
#[doc = " \\note If no data is immediately available, then the callback should sleep."]
#[doc = " \\warning The application is responsible for avoiding deadlock situations."]
pub type libvlc_media_read_cb = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, buf: *mut libc::c_uchar, len: size_t) -> isize,
>;
#[doc = " Callback prototype to seek a custom bitstream input media."]
#[doc = ""]
#[doc = " \\param opaque private pointer as set by the @ref libvlc_media_open_cb"]
#[doc = "               callback"]
#[doc = " \\param offset absolute byte offset to seek to"]
#[doc = " \\return 0 on success, -1 on error."]
pub type libvlc_media_seek_cb = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, offset: u64) -> libc::c_int,
>;
#[doc = " Callback prototype to close a custom bitstream input media."]
#[doc = ""]
#[doc = " \\param opaque private pointer as set by the @ref libvlc_media_open_cb"]
#[doc = "               callback"]
pub type libvlc_media_close_cb =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>;
extern "C" {
    #[doc = " Create a media with a certain given media resource location,"]
    #[doc = " for instance a valid URL."]
    #[doc = ""]
    #[doc = " \\note To refer to a local file with this function,"]
    #[doc = " the file://... URI syntax <b>must</b> be used (see IETF RFC3986)."]
    #[doc = " We recommend using libvlc_media_new_path() instead when dealing with"]
    #[doc = " local files."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_release"]
    #[doc = ""]
    #[doc = " \\param p_instance the instance"]
    #[doc = " \\param psz_mrl the media location"]
    #[doc = " \\return the newly created media or NULL on error"]
    pub fn libvlc_media_new_location(
        p_instance: *mut libvlc_instance_t,
        psz_mrl: *const libc::c_char,
    ) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Create a media for a certain file path."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_release"]
    #[doc = ""]
    #[doc = " \\param p_instance the instance"]
    #[doc = " \\param path local filesystem path"]
    #[doc = " \\return the newly created media or NULL on error"]
    pub fn libvlc_media_new_path(
        p_instance: *mut libvlc_instance_t,
        path: *const libc::c_char,
    ) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Create a media for an already open file descriptor."]
    #[doc = " The file descriptor shall be open for reading (or reading and writing)."]
    #[doc = ""]
    #[doc = " Regular file descriptors, pipe read descriptors and character device"]
    #[doc = " descriptors (including TTYs) are supported on all platforms."]
    #[doc = " Block device descriptors are supported where available."]
    #[doc = " Directory descriptors are supported on systems that provide fdopendir()."]
    #[doc = " Sockets are supported on all platforms where they are file descriptors,"]
    #[doc = " i.e. all except Windows."]
    #[doc = ""]
    #[doc = " \\note This library will <b>not</b> automatically close the file descriptor"]
    #[doc = " under any circumstance. Nevertheless, a file descriptor can usually only be"]
    #[doc = " rendered once in a media player. To render it a second time, the file"]
    #[doc = " descriptor should probably be rewound to the beginning with lseek()."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_release"]
    #[doc = ""]
    #[doc = " \\version LibVLC 1.1.5 and later."]
    #[doc = ""]
    #[doc = " \\param p_instance the instance"]
    #[doc = " \\param fd open file descriptor"]
    #[doc = " \\return the newly created media or NULL on error"]
    pub fn libvlc_media_new_fd(
        p_instance: *mut libvlc_instance_t,
        fd: libc::c_int,
    ) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Create a media with custom callbacks to read the data from."]
    #[doc = ""]
    #[doc = " \\param instance LibVLC instance"]
    #[doc = " \\param open_cb callback to open the custom bitstream input media"]
    #[doc = " \\param read_cb callback to read data (must not be NULL)"]
    #[doc = " \\param seek_cb callback to seek, or NULL if seeking is not supported"]
    #[doc = " \\param close_cb callback to close the media, or NULL if unnecessary"]
    #[doc = " \\param opaque data pointer for the open callback"]
    #[doc = ""]
    #[doc = " \\return the newly created media or NULL on error"]
    #[doc = ""]
    #[doc = " \\note If open_cb is NULL, the opaque pointer will be passed to read_cb,"]
    #[doc = " seek_cb and close_cb, and the stream size will be treated as unknown."]
    #[doc = ""]
    #[doc = " \\note The callbacks may be called asynchronously (from another thread)."]
    #[doc = " A single stream instance need not be reentrant. However the open_cb needs to"]
    #[doc = " be reentrant if the media is used by multiple player instances."]
    #[doc = ""]
    #[doc = " \\warning The callbacks may be used until all or any player instances"]
    #[doc = " that were supplied the media item are stopped."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_release"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    pub fn libvlc_media_new_callbacks(
        instance: *mut libvlc_instance_t,
        open_cb: libvlc_media_open_cb,
        read_cb: libvlc_media_read_cb,
        seek_cb: libvlc_media_seek_cb,
        close_cb: libvlc_media_close_cb,
        opaque: *mut libc::c_void,
    ) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Create a media as an empty node with a given name."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_release"]
    #[doc = ""]
    #[doc = " \\param p_instance the instance"]
    #[doc = " \\param psz_name the name of the node"]
    #[doc = " \\return the new empty media or NULL on error"]
    pub fn libvlc_media_new_as_node(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Add an option to the media."]
    #[doc = ""]
    #[doc = " This option will be used to determine how the media_player will"]
    #[doc = " read the media. This allows to use VLC's advanced"]
    #[doc = " reading/streaming options on a per-media basis."]
    #[doc = ""]
    #[doc = " \\note The options are listed in 'vlc --longhelp' from the command line,"]
    #[doc = " e.g. \"--sout-all\". Keep in mind that available options and their semantics"]
    #[doc = " vary across LibVLC versions and builds."]
    #[doc = " \\warning Not all options affects libvlc_media_t objects:"]
    #[doc = " Specifically, due to architectural issues most audio and video options,"]
    #[doc = " such as text renderer options, have no effects on an individual media."]
    #[doc = " These options must be set through libvlc_new() instead."]
    #[doc = ""]
    #[doc = " \\param p_md the media descriptor"]
    #[doc = " \\param psz_options the options (as a string)"]
    pub fn libvlc_media_add_option(p_md: *mut libvlc_media_t, psz_options: *const libc::c_char);
}
extern "C" {
    #[doc = " Add an option to the media with configurable flags."]
    #[doc = ""]
    #[doc = " This option will be used to determine how the media_player will"]
    #[doc = " read the media. This allows to use VLC's advanced"]
    #[doc = " reading/streaming options on a per-media basis."]
    #[doc = ""]
    #[doc = " The options are detailed in vlc --longhelp, for instance"]
    #[doc = " \"--sout-all\". Note that all options are not usable on medias:"]
    #[doc = " specifically, due to architectural issues, video-related options"]
    #[doc = " such as text renderer options cannot be set on a single media. They"]
    #[doc = " must be set on the whole libvlc instance instead."]
    #[doc = ""]
    #[doc = " \\param p_md the media descriptor"]
    #[doc = " \\param psz_options the options (as a string)"]
    #[doc = " \\param i_flags the flags for this option"]
    pub fn libvlc_media_add_option_flag(
        p_md: *mut libvlc_media_t,
        psz_options: *const libc::c_char,
        i_flags: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Retain a reference to a media descriptor object (libvlc_media_t). Use"]
    #[doc = " libvlc_media_release() to decrement the reference count of a"]
    #[doc = " media descriptor object."]
    #[doc = ""]
    #[doc = " \\param p_md the media descriptor"]
    pub fn libvlc_media_retain(p_md: *mut libvlc_media_t);
}
extern "C" {
    #[doc = " Decrement the reference count of a media descriptor object. If the"]
    #[doc = " reference count is 0, then libvlc_media_release() will release the"]
    #[doc = " media descriptor object. If the media descriptor object has been released it"]
    #[doc = " should not be used again."]
    #[doc = ""]
    #[doc = " \\param p_md the media descriptor"]
    pub fn libvlc_media_release(p_md: *mut libvlc_media_t);
}
extern "C" {
    #[doc = " Get the media resource locator (mrl) from a media descriptor object"]
    #[doc = ""]
    #[doc = " \\param p_md a media descriptor object"]
    #[doc = " \\return string with mrl of media descriptor object"]
    pub fn libvlc_media_get_mrl(p_md: *mut libvlc_media_t) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Duplicate a media descriptor object."]
    #[doc = ""]
    #[doc = " \\warning the duplicated media won't share forthcoming updates from the"]
    #[doc = " original one."]
    #[doc = ""]
    #[doc = " \\param p_md a media descriptor object."]
    pub fn libvlc_media_duplicate(p_md: *mut libvlc_media_t) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Read the meta of the media."]
    #[doc = ""]
    #[doc = " Note, you need to call libvlc_media_parse_with_options() or play the media"]
    #[doc = " at least once before calling this function."]
    #[doc = " If the media has not yet been parsed this will return NULL."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_parse_with_options"]
    #[doc = " \\see libvlc_MediaMetaChanged"]
    #[doc = ""]
    #[doc = " \\param p_md the media descriptor"]
    #[doc = " \\param e_meta the meta to read"]
    #[doc = " \\return the media's meta"]
    pub fn libvlc_media_get_meta(
        p_md: *mut libvlc_media_t,
        e_meta: libvlc_meta_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Set the meta of the media (this function will not save the meta, call"]
    #[doc = " libvlc_media_save_meta in order to save the meta)"]
    #[doc = ""]
    #[doc = " \\param p_md the media descriptor"]
    #[doc = " \\param e_meta the meta to write"]
    #[doc = " \\param psz_value the media's meta"]
    pub fn libvlc_media_set_meta(
        p_md: *mut libvlc_media_t,
        e_meta: libvlc_meta_t,
        psz_value: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " Save the meta previously set"]
    #[doc = ""]
    #[doc = " \\param p_md the media descriptor"]
    #[doc = " \\return true if the write operation was successful"]
    pub fn libvlc_media_save_meta(p_md: *mut libvlc_media_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current statistics about the media"]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\param p_stats structure that contain the statistics about the media"]
    #[doc = "                 (this structure must be allocated by the caller)"]
    #[doc = " \\retval true statistics are available"]
    #[doc = " \\retval false otherwise"]
    pub fn libvlc_media_get_stats(
        p_md: *mut libvlc_media_t,
        p_stats: *mut libvlc_media_stats_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_list_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get subitems of media descriptor object. This will increment"]
    #[doc = " the reference count of supplied media descriptor object. Use"]
    #[doc = " libvlc_media_list_release() to decrement the reference counting."]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\return list of media descriptor subitems or NULL"]
    pub fn libvlc_media_subitems(p_md: *mut libvlc_media_t) -> *mut libvlc_media_list_t;
}
extern "C" {
    #[doc = " Get event manager from media descriptor object."]
    #[doc = " NOTE: this function doesn't increment reference counting."]
    #[doc = ""]
    #[doc = " \\param p_md a media descriptor object"]
    #[doc = " \\return event manager object"]
    pub fn libvlc_media_event_manager(p_md: *mut libvlc_media_t) -> *mut libvlc_event_manager_t;
}
extern "C" {
    #[doc = " Get duration (in ms) of media descriptor object item."]
    #[doc = ""]
    #[doc = " Note, you need to call libvlc_media_parse_with_options() or play the media"]
    #[doc = " at least once before calling this function."]
    #[doc = " Not doing this will result in an undefined result."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_parse_with_options"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\return duration of media item or -1 on error"]
    pub fn libvlc_media_get_duration(p_md: *mut libvlc_media_t) -> libvlc_time_t;
}
extern "C" {
    #[doc = " Get a 'stat' value of media descriptor object item."]
    #[doc = ""]
    #[doc = " \\note 'stat' values are currently only parsed by directory accesses. This"]
    #[doc = " mean that only sub medias of a directory media, parsed with"]
    #[doc = " libvlc_media_parse_with_options() can have valid 'stat' properties."]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\param type a valid libvlc_media_stat_ define"]
    #[doc = " \\param out field in which the value will be stored"]
    #[doc = " \\return 1 on success, 0 if not found, -1 on error."]
    pub fn libvlc_media_get_filestat(
        p_md: *mut libvlc_media_t,
        type_: libc::c_uint,
        out: *mut u64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse the media asynchronously with options."]
    #[doc = ""]
    #[doc = " This fetches (local or network) art, meta data and/or tracks information."]
    #[doc = ""]
    #[doc = " To track when this is over you can listen to libvlc_MediaParsedChanged"]
    #[doc = " event. However if this functions returns an error, you will not receive any"]
    #[doc = " events."]
    #[doc = ""]
    #[doc = " It uses a flag to specify parse options (see libvlc_media_parse_flag_t). All"]
    #[doc = " these flags can be combined. By default, media is parsed if it's a local"]
    #[doc = " file."]
    #[doc = ""]
    #[doc = " \\note Parsing can be aborted with libvlc_media_parse_stop()."]
    #[doc = ""]
    #[doc = " \\see libvlc_MediaParsedChanged"]
    #[doc = " \\see libvlc_media_get_meta"]
    #[doc = " \\see libvlc_media_get_tracklist"]
    #[doc = " \\see libvlc_media_get_parsed_status"]
    #[doc = " \\see libvlc_media_parse_flag_t"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\param parse_flag parse options:"]
    #[doc = " \\param timeout maximum time allowed to preparse the media. If -1, the"]
    #[doc = " default \"preparse-timeout\" option will be used as a timeout. If 0, it will"]
    #[doc = " wait indefinitely. If > 0, the timeout will be used (in milliseconds)."]
    #[doc = " \\return -1 in case of error, 0 otherwise"]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_parse_with_options(
        p_md: *mut libvlc_media_t,
        parse_flag: libvlc_media_parse_flag_t,
        timeout: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop the parsing of the media"]
    #[doc = ""]
    #[doc = " When the media parsing is stopped, the libvlc_MediaParsedChanged event will"]
    #[doc = " be sent with the libvlc_media_parsed_status_timeout status."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_parse_with_options"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_parse_stop(p_md: *mut libvlc_media_t);
}
extern "C" {
    #[doc = " Get Parsed status for media descriptor object."]
    #[doc = ""]
    #[doc = " \\see libvlc_MediaParsedChanged"]
    #[doc = " \\see libvlc_media_parsed_status_t"]
    #[doc = " \\see libvlc_media_parse_with_options"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\return a value of the libvlc_media_parsed_status_t enum"]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_get_parsed_status(
        p_md: *mut libvlc_media_t,
    ) -> libvlc_media_parsed_status_t;
}
extern "C" {
    #[doc = " Sets media descriptor's user_data. user_data is specialized data"]
    #[doc = " accessed by the host application, VLC.framework uses it as a pointer to"]
    #[doc = " an native object that references a libvlc_media_t pointer"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\param p_new_user_data pointer to user data"]
    pub fn libvlc_media_set_user_data(
        p_md: *mut libvlc_media_t,
        p_new_user_data: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Get media descriptor's user_data. user_data is specialized data"]
    #[doc = " accessed by the host application, VLC.framework uses it as a pointer to"]
    #[doc = " an native object that references a libvlc_media_t pointer"]
    #[doc = ""]
    #[doc = " \\see libvlc_media_set_user_data"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    pub fn libvlc_media_get_user_data(p_md: *mut libvlc_media_t) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the track list for one type"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\note You need to call libvlc_media_parse_with_options() or play the media"]
    #[doc = " at least once before calling this function.  Not doing this will result in"]
    #[doc = " an empty list."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_parse_with_options"]
    #[doc = " \\see libvlc_media_tracklist_count"]
    #[doc = " \\see libvlc_media_tracklist_at"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\param type type of the track list to request"]
    #[doc = ""]
    #[doc = " \\return a valid libvlc_media_tracklist_t or NULL in case of error, if there"]
    #[doc = " is no track for a category, the returned list will have a size of 0, delete"]
    #[doc = " with libvlc_media_tracklist_delete()"]
    pub fn libvlc_media_get_tracklist(
        p_md: *mut libvlc_media_t,
        type_: libvlc_track_type_t,
    ) -> *mut libvlc_media_tracklist_t;
}
extern "C" {
    #[doc = " Get codec description from media elementary stream"]
    #[doc = ""]
    #[doc = " Note, you need to call libvlc_media_parse_with_options() or play the media"]
    #[doc = " at least once before calling this function."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_track_t"]
    #[doc = " \\see libvlc_media_parse_with_options"]
    #[doc = ""]
    #[doc = " \\param i_type i_type from libvlc_media_track_t"]
    #[doc = " \\param i_codec i_codec or i_original_fourcc from libvlc_media_track_t"]
    #[doc = ""]
    #[doc = " \\return codec description"]
    pub fn libvlc_media_get_codec_description(
        i_type: libvlc_track_type_t,
        i_codec: u32,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the media type of the media descriptor object"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_type_t"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = ""]
    #[doc = " \\return media type"]
    pub fn libvlc_media_get_type(p_md: *mut libvlc_media_t) -> libvlc_media_type_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_thumbnail_request_t {
    _unused: [u8; 0],
}
pub const libvlc_thumbnailer_seek_speed_t_libvlc_media_thumbnail_seek_precise:
    libvlc_thumbnailer_seek_speed_t = 0;
pub const libvlc_thumbnailer_seek_speed_t_libvlc_media_thumbnail_seek_fast:
    libvlc_thumbnailer_seek_speed_t = 1;
pub type libvlc_thumbnailer_seek_speed_t = libc::c_uint;
extern "C" {
    #[doc = " \\brief libvlc_media_request_thumbnail_by_time Start an asynchronous thumbnail generation"]
    #[doc = ""]
    #[doc = " If the request is successfully queued, the libvlc_MediaThumbnailGenerated"]
    #[doc = " is guaranteed to be emitted."]
    #[doc = " The resulting thumbnail size can either be:"]
    #[doc = " - Hardcoded by providing both width & height. In which case, the image will"]
    #[doc = "   be stretched to match the provided aspect ratio, or cropped if crop is true."]
    #[doc = " - Derived from the media aspect ratio if only width or height is provided and"]
    #[doc = "   the other one is set to 0."]
    #[doc = ""]
    #[doc = " \\param md media descriptor object"]
    #[doc = " \\param time The time at which the thumbnail should be generated"]
    #[doc = " \\param speed The seeking speed \\sa{libvlc_thumbnailer_seek_speed_t}"]
    #[doc = " \\param width The thumbnail width"]
    #[doc = " \\param height the thumbnail height"]
    #[doc = " \\param crop Should the picture be cropped to preserve source aspect ratio"]
    #[doc = " \\param picture_type The thumbnail picture type \\sa{libvlc_picture_type_t}"]
    #[doc = " \\param timeout A timeout value in ms, or 0 to disable timeout"]
    #[doc = ""]
    #[doc = " \\return A valid opaque request object, or NULL in case of failure."]
    #[doc = " It may be cancelled by libvlc_media_thumbnail_request_cancel()."]
    #[doc = " It must be released by libvlc_media_thumbnail_request_destroy()."]
    #[doc = ""]
    #[doc = " \\version libvlc 4.0 or later"]
    #[doc = ""]
    #[doc = " \\see libvlc_picture_t"]
    #[doc = " \\see libvlc_picture_type_t"]
    pub fn libvlc_media_thumbnail_request_by_time(
        md: *mut libvlc_media_t,
        time: libvlc_time_t,
        speed: libvlc_thumbnailer_seek_speed_t,
        width: libc::c_uint,
        height: libc::c_uint,
        crop: bool,
        picture_type: libvlc_picture_type_t,
        timeout: libvlc_time_t,
    ) -> *mut libvlc_media_thumbnail_request_t;
}
extern "C" {
    #[doc = " \\brief libvlc_media_request_thumbnail_by_pos Start an asynchronous thumbnail generation"]
    #[doc = ""]
    #[doc = " If the request is successfully queued, the libvlc_MediaThumbnailGenerated"]
    #[doc = " is guaranteed to be emitted."]
    #[doc = " The resulting thumbnail size can either be:"]
    #[doc = " - Hardcoded by providing both width & height. In which case, the image will"]
    #[doc = "   be stretched to match the provided aspect ratio, or cropped if crop is true."]
    #[doc = " - Derived from the media aspect ratio if only width or height is provided and"]
    #[doc = "   the other one is set to 0."]
    #[doc = ""]
    #[doc = " \\param md media descriptor object"]
    #[doc = " \\param pos The position at which the thumbnail should be generated"]
    #[doc = " \\param speed The seeking speed \\sa{libvlc_thumbnailer_seek_speed_t}"]
    #[doc = " \\param width The thumbnail width"]
    #[doc = " \\param height the thumbnail height"]
    #[doc = " \\param crop Should the picture be cropped to preserve source aspect ratio"]
    #[doc = " \\param picture_type The thumbnail picture type \\sa{libvlc_picture_type_t}"]
    #[doc = " \\param timeout A timeout value in ms, or 0 to disable timeout"]
    #[doc = ""]
    #[doc = " \\return A valid opaque request object, or NULL in case of failure."]
    #[doc = " It may be cancelled by libvlc_media_thumbnail_request_cancel()."]
    #[doc = " It must be released by libvlc_media_thumbnail_request_destroy()."]
    #[doc = ""]
    #[doc = " \\version libvlc 4.0 or later"]
    #[doc = ""]
    #[doc = " \\see libvlc_picture_t"]
    #[doc = " \\see libvlc_picture_type_t"]
    pub fn libvlc_media_thumbnail_request_by_pos(
        md: *mut libvlc_media_t,
        pos: f32,
        speed: libvlc_thumbnailer_seek_speed_t,
        width: libc::c_uint,
        height: libc::c_uint,
        crop: bool,
        picture_type: libvlc_picture_type_t,
        timeout: libvlc_time_t,
    ) -> *mut libvlc_media_thumbnail_request_t;
}
extern "C" {
    #[doc = " @brief libvlc_media_thumbnail_cancel cancels a thumbnailing request"]
    #[doc = " @param p_req An opaque thumbnail request object."]
    #[doc = ""]
    #[doc = " Cancelling the request will still cause libvlc_MediaThumbnailGenerated event"]
    #[doc = " to be emitted, with a NULL libvlc_picture_t"]
    #[doc = " If the request is cancelled after its completion, the behavior is undefined."]
    pub fn libvlc_media_thumbnail_request_cancel(p_req: *mut libvlc_media_thumbnail_request_t);
}
extern "C" {
    #[doc = " @brief libvlc_media_thumbnail_destroy destroys a thumbnail request"]
    #[doc = " @param p_req An opaque thumbnail request object."]
    #[doc = ""]
    #[doc = " If the request has not completed or hasn't been cancelled yet, the behavior"]
    #[doc = " is undefined"]
    pub fn libvlc_media_thumbnail_request_destroy(p_req: *mut libvlc_media_thumbnail_request_t);
}
extern "C" {
    #[doc = " Add a slave to the current media."]
    #[doc = ""]
    #[doc = " A slave is an external input source that may contains an additional subtitle"]
    #[doc = " track (like a .srt) or an additional audio track (like a .ac3)."]
    #[doc = ""]
    #[doc = " \\note This function must be called before the media is parsed (via"]
    #[doc = " libvlc_media_parse_with_options()) or before the media is played (via"]
    #[doc = " libvlc_media_player_play())"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\param i_type subtitle or audio"]
    #[doc = " \\param i_priority from 0 (low priority) to 4 (high priority)"]
    #[doc = " \\param psz_uri Uri of the slave (should contain a valid scheme)."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn libvlc_media_slaves_add(
        p_md: *mut libvlc_media_t,
        i_type: libvlc_media_slave_type_t,
        i_priority: libc::c_uint,
        psz_uri: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Clear all slaves previously added by libvlc_media_slaves_add() or"]
    #[doc = " internally."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    pub fn libvlc_media_slaves_clear(p_md: *mut libvlc_media_t);
}
extern "C" {
    #[doc = " Get a media descriptor's slave list"]
    #[doc = ""]
    #[doc = " The list will contain slaves parsed by VLC or previously added by"]
    #[doc = " libvlc_media_slaves_add(). The typical use case of this function is to save"]
    #[doc = " a list of slave in a database for a later use."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_slaves_add"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\param ppp_slaves address to store an allocated array of slaves (must be"]
    #[doc = " freed with libvlc_media_slaves_release()) [OUT]"]
    #[doc = ""]
    #[doc = " \\return the number of slaves (zero on error)"]
    pub fn libvlc_media_slaves_get(
        p_md: *mut libvlc_media_t,
        ppp_slaves: *mut *mut *mut libvlc_media_slave_t,
    ) -> libc::c_uint;
}
extern "C" {
    #[doc = " Release a media descriptor's slave list"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param pp_slaves slave array to release"]
    #[doc = " \\param i_count number of elements in the array"]
    pub fn libvlc_media_slaves_release(
        pp_slaves: *mut *mut libvlc_media_slave_t,
        i_count: libc::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_player_t {
    _unused: [u8; 0],
}
pub const libvlc_title_menu: libc::c_uint = 1;
pub const libvlc_title_interactive: libc::c_uint = 2;
#[doc = " Description for titles"]
pub type _bindgen_ty_2 = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_title_description_t {
    #[doc = "< duration in milliseconds"]
    pub i_duration: i64,
    #[doc = "< title name"]
    pub psz_name: *mut libc::c_char,
    #[doc = "< info if item was recognized as a menu, interactive or plain content by the demuxer"]
    pub i_flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout_libvlc_title_description_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_title_description_t>(),
        24usize,
        concat!("Size of: ", stringify!(libvlc_title_description_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_title_description_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_title_description_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_title_description_t>())).i_duration as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_title_description_t),
            "::",
            stringify!(i_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_title_description_t>())).psz_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_title_description_t),
            "::",
            stringify!(psz_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_title_description_t>())).i_flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_title_description_t),
            "::",
            stringify!(i_flags)
        )
    );
}
#[doc = " Description for chapters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_chapter_description_t {
    #[doc = "< time-offset of the chapter in milliseconds"]
    pub i_time_offset: i64,
    #[doc = "< duration of the chapter in milliseconds"]
    pub i_duration: i64,
    #[doc = "< chapter name"]
    pub psz_name: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_libvlc_chapter_description_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_chapter_description_t>(),
        24usize,
        concat!("Size of: ", stringify!(libvlc_chapter_description_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_chapter_description_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_chapter_description_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_chapter_description_t>())).i_time_offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_chapter_description_t),
            "::",
            stringify!(i_time_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_chapter_description_t>())).i_duration as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_chapter_description_t),
            "::",
            stringify!(i_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_chapter_description_t>())).psz_name as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_chapter_description_t),
            "::",
            stringify!(psz_name)
        )
    );
}
#[doc = " Description for audio output. It contains"]
#[doc = " name, description and pointer to next record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_audio_output_t {
    pub psz_name: *mut libc::c_char,
    pub psz_description: *mut libc::c_char,
    pub p_next: *mut libvlc_audio_output_t,
}
#[test]
fn bindgen_test_layout_libvlc_audio_output_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_audio_output_t>(),
        24usize,
        concat!("Size of: ", stringify!(libvlc_audio_output_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_audio_output_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_audio_output_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_audio_output_t>())).psz_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_audio_output_t),
            "::",
            stringify!(psz_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_audio_output_t>())).psz_description as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_audio_output_t),
            "::",
            stringify!(psz_description)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_audio_output_t>())).p_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_audio_output_t),
            "::",
            stringify!(p_next)
        )
    );
}
#[doc = " Description for audio output device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_audio_output_device_t {
    #[doc = "< Next entry in list"]
    pub p_next: *mut libvlc_audio_output_device_t,
    #[doc = "< Device identifier string"]
    pub psz_device: *mut libc::c_char,
    #[doc = "< User-friendly device description"]
    pub psz_description: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_libvlc_audio_output_device_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_audio_output_device_t>(),
        24usize,
        concat!("Size of: ", stringify!(libvlc_audio_output_device_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_audio_output_device_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_audio_output_device_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_audio_output_device_t>())).p_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_audio_output_device_t),
            "::",
            stringify!(p_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_audio_output_device_t>())).psz_device as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_audio_output_device_t),
            "::",
            stringify!(psz_device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_audio_output_device_t>())).psz_description as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_audio_output_device_t),
            "::",
            stringify!(psz_description)
        )
    );
}
pub const libvlc_video_marquee_option_t_libvlc_marquee_Enable: libvlc_video_marquee_option_t = 0;
pub const libvlc_video_marquee_option_t_libvlc_marquee_Text: libvlc_video_marquee_option_t = 1;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Color: libvlc_video_marquee_option_t = 2;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Opacity: libvlc_video_marquee_option_t = 3;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Position: libvlc_video_marquee_option_t = 4;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Refresh: libvlc_video_marquee_option_t = 5;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Size: libvlc_video_marquee_option_t = 6;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Timeout: libvlc_video_marquee_option_t = 7;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_X: libvlc_video_marquee_option_t = 8;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Y: libvlc_video_marquee_option_t = 9;
#[doc = " Marq options definition"]
pub type libvlc_video_marquee_option_t = libc::c_uint;
pub const libvlc_navigate_mode_t_libvlc_navigate_activate: libvlc_navigate_mode_t = 0;
pub const libvlc_navigate_mode_t_libvlc_navigate_up: libvlc_navigate_mode_t = 1;
pub const libvlc_navigate_mode_t_libvlc_navigate_down: libvlc_navigate_mode_t = 2;
pub const libvlc_navigate_mode_t_libvlc_navigate_left: libvlc_navigate_mode_t = 3;
pub const libvlc_navigate_mode_t_libvlc_navigate_right: libvlc_navigate_mode_t = 4;
pub const libvlc_navigate_mode_t_libvlc_navigate_popup: libvlc_navigate_mode_t = 5;
#[doc = " Navigation mode"]
pub type libvlc_navigate_mode_t = libc::c_uint;
pub const libvlc_position_t_libvlc_position_disable: libvlc_position_t = -1;
pub const libvlc_position_t_libvlc_position_center: libvlc_position_t = 0;
pub const libvlc_position_t_libvlc_position_left: libvlc_position_t = 1;
pub const libvlc_position_t_libvlc_position_right: libvlc_position_t = 2;
pub const libvlc_position_t_libvlc_position_top: libvlc_position_t = 3;
pub const libvlc_position_t_libvlc_position_top_left: libvlc_position_t = 4;
pub const libvlc_position_t_libvlc_position_top_right: libvlc_position_t = 5;
pub const libvlc_position_t_libvlc_position_bottom: libvlc_position_t = 6;
pub const libvlc_position_t_libvlc_position_bottom_left: libvlc_position_t = 7;
pub const libvlc_position_t_libvlc_position_bottom_right: libvlc_position_t = 8;
#[doc = " Enumeration of values used to set position (e.g. of video title)."]
pub type libvlc_position_t = libc::c_int;
pub const libvlc_teletext_key_t_libvlc_teletext_key_red: libvlc_teletext_key_t = 7471104;
pub const libvlc_teletext_key_t_libvlc_teletext_key_green: libvlc_teletext_key_t = 6750208;
pub const libvlc_teletext_key_t_libvlc_teletext_key_yellow: libvlc_teletext_key_t = 7929856;
pub const libvlc_teletext_key_t_libvlc_teletext_key_blue: libvlc_teletext_key_t = 6422528;
pub const libvlc_teletext_key_t_libvlc_teletext_key_index: libvlc_teletext_key_t = 6881280;
#[doc = " Enumeration of teletext keys than can be passed via"]
#[doc = " libvlc_video_set_teletext()"]
pub type libvlc_teletext_key_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_equalizer_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create an empty Media Player object"]
    #[doc = ""]
    #[doc = " \\param p_libvlc_instance the libvlc instance in which the Media Player"]
    #[doc = "        should be created."]
    #[doc = " \\return a new media player object, or NULL on error."]
    #[doc = " It must be released by libvlc_media_player_release()."]
    pub fn libvlc_media_player_new(
        p_libvlc_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_media_player_t;
}
extern "C" {
    #[doc = " Create a Media Player object from a Media"]
    #[doc = ""]
    #[doc = " \\param p_md the media. Afterwards the p_md can be safely"]
    #[doc = "        destroyed."]
    #[doc = " \\return a new media player object, or NULL on error."]
    #[doc = " It must be released by libvlc_media_player_release()."]
    pub fn libvlc_media_player_new_from_media(
        p_md: *mut libvlc_media_t,
    ) -> *mut libvlc_media_player_t;
}
extern "C" {
    #[doc = " Release a media_player after use"]
    #[doc = " Decrement the reference count of a media player object. If the"]
    #[doc = " reference count is 0, then libvlc_media_player_release() will"]
    #[doc = " release the media player object. If the media player object"]
    #[doc = " has been released, then it should not be used again."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player to free"]
    pub fn libvlc_media_player_release(p_mi: *mut libvlc_media_player_t);
}
extern "C" {
    #[doc = " Retain a reference to a media player object. Use"]
    #[doc = " libvlc_media_player_release() to decrement reference count."]
    #[doc = ""]
    #[doc = " \\param p_mi media player object"]
    pub fn libvlc_media_player_retain(p_mi: *mut libvlc_media_player_t);
}
extern "C" {
    #[doc = " Set the media that will be used by the media_player. If any,"]
    #[doc = " previous md will be released."]
    #[doc = ""]
    #[doc = " \\note The user should listen to the libvlc_MediaPlayerMediaChanged event, to"]
    #[doc = " know when the new media is actually used by the player (or to known that the"]
    #[doc = " older media is no longer used)."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param p_md the Media. Afterwards the p_md can be safely"]
    #[doc = "        destroyed."]
    pub fn libvlc_media_player_set_media(
        p_mi: *mut libvlc_media_player_t,
        p_md: *mut libvlc_media_t,
    );
}
extern "C" {
    #[doc = " Get the media used by the media_player."]
    #[doc = ""]
    #[doc = " \\warning Calling this function just after libvlc_media_player_set_media()"]
    #[doc = " will return the media that was just set, but this media might not be"]
    #[doc = " currently used internally by the player. To detect such case, the user"]
    #[doc = " should listen to the libvlc_MediaPlayerMediaChanged event."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return the media associated with p_mi, or NULL if no"]
    #[doc = "         media is associated"]
    pub fn libvlc_media_player_get_media(p_mi: *mut libvlc_media_player_t) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Get the Event Manager from which the media player send event."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return the event manager associated with p_mi"]
    pub fn libvlc_media_player_event_manager(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_event_manager_t;
}
extern "C" {
    #[doc = " is_playing"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\retval true media player is playing"]
    #[doc = " \\retval false media player is not playing"]
    pub fn libvlc_media_player_is_playing(p_mi: *mut libvlc_media_player_t) -> bool;
}
extern "C" {
    #[doc = " Play"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return 0 if playback started (and was already started), or -1 on error."]
    pub fn libvlc_media_player_play(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Pause or resume (no effect if there is no media)"]
    #[doc = ""]
    #[doc = " \\param mp the Media Player"]
    #[doc = " \\param do_pause play/resume if zero, pause if non-zero"]
    #[doc = " \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_media_player_set_pause(mp: *mut libvlc_media_player_t, do_pause: libc::c_int);
}
extern "C" {
    #[doc = " Toggle pause (no effect if there is no media)"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    pub fn libvlc_media_player_pause(p_mi: *mut libvlc_media_player_t);
}
extern "C" {
    #[doc = " Stop asynchronously"]
    #[doc = ""]
    #[doc = " \\note This function is asynchronous. In case of success, the user should"]
    #[doc = " wait for the libvlc_MediaPlayerStopped event to know when the stop is"]
    #[doc = " finished."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return 0 if the player is being stopped, -1 otherwise (no-op)"]
    #[doc = " \\version LibVLC 4.0.0 or later"]
    pub fn libvlc_media_player_stop_async(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a renderer to the media player"]
    #[doc = ""]
    #[doc = " \\note must be called before the first call of libvlc_media_player_play() to"]
    #[doc = " take effect."]
    #[doc = ""]
    #[doc = " \\see libvlc_renderer_discoverer_new"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param p_item an item discovered by libvlc_renderer_discoverer_start()"]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_player_set_renderer(
        p_mi: *mut libvlc_media_player_t,
        p_item: *mut libvlc_renderer_item_t,
    ) -> libc::c_int;
}
pub const libvlc_video_color_primaries_t_libvlc_video_primaries_BT601_525:
    libvlc_video_color_primaries_t = 1;
pub const libvlc_video_color_primaries_t_libvlc_video_primaries_BT601_625:
    libvlc_video_color_primaries_t = 2;
pub const libvlc_video_color_primaries_t_libvlc_video_primaries_BT709:
    libvlc_video_color_primaries_t = 3;
pub const libvlc_video_color_primaries_t_libvlc_video_primaries_BT2020:
    libvlc_video_color_primaries_t = 4;
pub const libvlc_video_color_primaries_t_libvlc_video_primaries_DCI_P3:
    libvlc_video_color_primaries_t = 5;
pub const libvlc_video_color_primaries_t_libvlc_video_primaries_BT470_M:
    libvlc_video_color_primaries_t = 6;
#[doc = " Enumeration of the Video color primaries."]
pub type libvlc_video_color_primaries_t = libc::c_uint;
pub const libvlc_video_color_space_t_libvlc_video_colorspace_BT601: libvlc_video_color_space_t = 1;
pub const libvlc_video_color_space_t_libvlc_video_colorspace_BT709: libvlc_video_color_space_t = 2;
pub const libvlc_video_color_space_t_libvlc_video_colorspace_BT2020: libvlc_video_color_space_t = 3;
#[doc = " Enumeration of the Video color spaces."]
pub type libvlc_video_color_space_t = libc::c_uint;
pub const libvlc_video_transfer_func_t_libvlc_video_transfer_func_LINEAR:
    libvlc_video_transfer_func_t = 1;
pub const libvlc_video_transfer_func_t_libvlc_video_transfer_func_SRGB:
    libvlc_video_transfer_func_t = 2;
pub const libvlc_video_transfer_func_t_libvlc_video_transfer_func_BT470_BG:
    libvlc_video_transfer_func_t = 3;
pub const libvlc_video_transfer_func_t_libvlc_video_transfer_func_BT470_M:
    libvlc_video_transfer_func_t = 4;
pub const libvlc_video_transfer_func_t_libvlc_video_transfer_func_BT709:
    libvlc_video_transfer_func_t = 5;
pub const libvlc_video_transfer_func_t_libvlc_video_transfer_func_PQ: libvlc_video_transfer_func_t =
    6;
pub const libvlc_video_transfer_func_t_libvlc_video_transfer_func_SMPTE_240:
    libvlc_video_transfer_func_t = 7;
pub const libvlc_video_transfer_func_t_libvlc_video_transfer_func_HLG:
    libvlc_video_transfer_func_t = 8;
#[doc = " Enumeration of the Video transfer functions."]
pub type libvlc_video_transfer_func_t = libc::c_uint;
#[doc = " Callback prototype to allocate and lock a picture buffer."]
#[doc = ""]
#[doc = " Whenever a new video frame needs to be decoded, the lock callback is"]
#[doc = " invoked. Depending on the video chroma, one or three pixel planes of"]
#[doc = " adequate dimensions must be returned via the second parameter. Those"]
#[doc = " planes must be aligned on 32-bytes boundaries."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer as passed to libvlc_video_set_callbacks()"]
#[doc = " \\param[out] planes start address of the pixel planes (LibVLC allocates the array"]
#[doc = "             of void pointers, this callback must initialize the array)"]
#[doc = " \\return a private pointer for the display and unlock callbacks to identify"]
#[doc = "         the picture buffers"]
pub type libvlc_video_lock_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        planes: *mut *mut libc::c_void,
    ) -> *mut libc::c_void,
>;
#[doc = " Callback prototype to unlock a picture buffer."]
#[doc = ""]
#[doc = " When the video frame decoding is complete, the unlock callback is invoked."]
#[doc = " This callback might not be needed at all. It is only an indication that the"]
#[doc = " application can now read the pixel values if it needs to."]
#[doc = ""]
#[doc = " \\note A picture buffer is unlocked after the picture is decoded,"]
#[doc = " but before the picture is displayed."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer as passed to libvlc_video_set_callbacks()"]
#[doc = " \\param[in] picture private pointer returned from the @ref libvlc_video_lock_cb"]
#[doc = "                callback"]
#[doc = " \\param[in] planes pixel planes as defined by the @ref libvlc_video_lock_cb"]
#[doc = "               callback (this parameter is only for convenience)"]
pub type libvlc_video_unlock_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        picture: *mut libc::c_void,
        planes: *const *mut libc::c_void,
    ),
>;
#[doc = " Callback prototype to display a picture."]
#[doc = ""]
#[doc = " When the video frame needs to be shown, as determined by the media playback"]
#[doc = " clock, the display callback is invoked."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer as passed to libvlc_video_set_callbacks()"]
#[doc = " \\param[in] picture private pointer returned from the @ref libvlc_video_lock_cb"]
#[doc = "                callback"]
pub type libvlc_video_display_cb = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, picture: *mut libc::c_void),
>;
#[doc = " Callback prototype to configure picture buffers format."]
#[doc = " This callback gets the format of the video as output by the video decoder"]
#[doc = " and the chain of video filters (if any). It can opt to change any parameter"]
#[doc = " as it needs. In that case, LibVLC will attempt to convert the video format"]
#[doc = " (rescaling and chroma conversion) but these operations can be CPU intensive."]
#[doc = ""]
#[doc = " \\param[in,out] opaque pointer to the private pointer passed to"]
#[doc = "                libvlc_video_set_callbacks()"]
#[doc = " \\param[in,out] chroma pointer to the 4 bytes video format identifier"]
#[doc = " \\param[in,out] width pointer to the buffer width in pixels"]
#[doc = " \\param[in,out] height pointer to the buffer height in pixels"]
#[doc = " \\param[out] pitches table of scanline pitches in bytes for each pixel plane"]
#[doc = "                (the table is allocated by LibVLC)"]
#[doc = " \\param[out] lines table of scanlines count for each plane"]
#[doc = " \\return the number of picture buffers allocated, 0 indicates failure"]
#[doc = ""]
#[doc = " \\version LibVLC 4.0.0 and later."]
#[doc = " \\param[in] (width+1) - pointer to display width in pixels"]
#[doc = " \\param[in] (height+1) - pointer to display height in pixels"]
#[doc = ""]
#[doc = " \\note"]
#[doc = " For each pixels plane, the scanline pitch must be bigger than or equal to"]
#[doc = " the number of bytes per pixel multiplied by the pixel width."]
#[doc = " Similarly, the number of scanlines must be bigger than of equal to"]
#[doc = " the pixel height."]
#[doc = " Furthermore, we recommend that pitches and lines be multiple of 32"]
#[doc = " to not break assumptions that might be held by optimized code"]
#[doc = " in the video decoders, video filters and/or video converters."]
pub type libvlc_video_format_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut *mut libc::c_void,
        chroma: *mut libc::c_char,
        width: *mut libc::c_uint,
        height: *mut libc::c_uint,
        pitches: *mut libc::c_uint,
        lines: *mut libc::c_uint,
    ) -> libc::c_uint,
>;
#[doc = " Callback prototype to configure picture buffers format."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer as passed to libvlc_video_set_format_callbacks()"]
#[doc = "               (and possibly modified by @ref libvlc_video_format_cb)"]
pub type libvlc_video_cleanup_cb =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>;
extern "C" {
    #[doc = " Set callbacks and private data to render decoded video to a custom area"]
    #[doc = " in memory."]
    #[doc = " Use libvlc_video_set_format() or libvlc_video_set_format_callbacks()"]
    #[doc = " to configure the decoded format."]
    #[doc = ""]
    #[doc = " \\warning Rendering video into custom memory buffers is considerably less"]
    #[doc = " efficient than rendering in a custom window as normal."]
    #[doc = ""]
    #[doc = " For optimal perfomances, VLC media player renders into a custom window, and"]
    #[doc = " does not use this function and associated callbacks. It is <b>highly"]
    #[doc = " recommended</b> that other LibVLC-based application do likewise."]
    #[doc = " To embed video in a window, use libvlc_media_player_set_xwindow() or"]
    #[doc = " equivalent depending on the operating system."]
    #[doc = ""]
    #[doc = " If window embedding does not fit the application use case, then a custom"]
    #[doc = " LibVLC video output display plugin is required to maintain optimal video"]
    #[doc = " rendering performances."]
    #[doc = ""]
    #[doc = " The following limitations affect performance:"]
    #[doc = " - Hardware video decoding acceleration will either be disabled completely,"]
    #[doc = "   or require (relatively slow) copy from video/DSP memory to main memory."]
    #[doc = " - Sub-pictures (subtitles, on-screen display, etc.) must be blent into the"]
    #[doc = "   main picture by the CPU instead of the GPU."]
    #[doc = " - Depending on the video format, pixel format conversion, picture scaling,"]
    #[doc = "   cropping and/or picture re-orientation, must be performed by the CPU"]
    #[doc = "   instead of the GPU."]
    #[doc = " - Memory copying is required between LibVLC reference picture buffers and"]
    #[doc = "   application buffers (between lock and unlock callbacks)."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param lock callback to lock video memory (must not be NULL)"]
    #[doc = " \\param unlock callback to unlock video memory (or NULL if not needed)"]
    #[doc = " \\param display callback to display video (or NULL if not needed)"]
    #[doc = " \\param opaque private pointer for the three callbacks (as first parameter)"]
    #[doc = " \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_video_set_callbacks(
        mp: *mut libvlc_media_player_t,
        lock: libvlc_video_lock_cb,
        unlock: libvlc_video_unlock_cb,
        display: libvlc_video_display_cb,
        opaque: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Set decoded video chroma and dimensions."]
    #[doc = " This only works in combination with libvlc_video_set_callbacks(),"]
    #[doc = " and is mutually exclusive with libvlc_video_set_format_callbacks()."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param chroma a four-characters string identifying the chroma"]
    #[doc = "               (e.g. \"RV32\" or \"YUYV\")"]
    #[doc = " \\param width pixel width"]
    #[doc = " \\param height pixel height"]
    #[doc = " \\param pitch line pitch (in bytes)"]
    #[doc = " \\version LibVLC 1.1.1 or later"]
    #[doc = " \\bug All pixel planes are expected to have the same pitch."]
    #[doc = " To use the YCbCr color space with chrominance subsampling,"]
    #[doc = " consider using libvlc_video_set_format_callbacks() instead."]
    pub fn libvlc_video_set_format(
        mp: *mut libvlc_media_player_t,
        chroma: *const libc::c_char,
        width: libc::c_uint,
        height: libc::c_uint,
        pitch: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Set decoded video chroma and dimensions. This only works in combination with"]
    #[doc = " libvlc_video_set_callbacks()."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param setup callback to select the video format (cannot be NULL)"]
    #[doc = " \\param cleanup callback to release any allocated resources (or NULL)"]
    #[doc = " \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_video_set_format_callbacks(
        mp: *mut libvlc_media_player_t,
        setup: libvlc_video_format_cb,
        cleanup: libvlc_video_cleanup_cb,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_setup_device_cfg_t {
    pub hardware_decoding: bool,
}
#[test]
fn bindgen_test_layout_libvlc_video_setup_device_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_setup_device_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(libvlc_video_setup_device_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_setup_device_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(libvlc_video_setup_device_cfg_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_setup_device_cfg_t>())).hardware_decoding
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_setup_device_cfg_t),
            "::",
            stringify!(hardware_decoding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libvlc_video_setup_device_info_t {
    pub __bindgen_anon_1: libvlc_video_setup_device_info_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union libvlc_video_setup_device_info_t__bindgen_ty_1 {
    pub d3d11: libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1,
    pub d3d9: libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1 {
    pub device_context: *mut libc::c_void,
    #[doc = " ID3D11DeviceContext*"]
    pub context_mutex: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .device_context as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(device_context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .context_mutex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(context_mutex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2 {
    pub device: *mut libc::c_void,
    #[doc = " IDirect3D9*"]
    pub adapter: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2>(
            )))
            .device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2>(
            )))
            .adapter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(adapter)
        )
    );
}
#[test]
fn bindgen_test_layout_libvlc_video_setup_device_info_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_setup_device_info_t__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_setup_device_info_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_setup_device_info_t__bindgen_ty_1>())).d3d11
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1),
            "::",
            stringify!(d3d11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_setup_device_info_t__bindgen_ty_1>())).d3d9
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_setup_device_info_t__bindgen_ty_1),
            "::",
            stringify!(d3d9)
        )
    );
}
#[test]
fn bindgen_test_layout_libvlc_video_setup_device_info_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_setup_device_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(libvlc_video_setup_device_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_setup_device_info_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_video_setup_device_info_t)
        )
    );
}
#[doc = " Callback prototype called to initialize user data."]
#[doc = " Setup the rendering environment."]
#[doc = ""]
#[doc = " \\param[in,out] opaque private pointer passed to the @a libvlc_video_set_output_callbacks()"]
#[doc = "               on input. The callback can change this value on output to be"]
#[doc = "               passed to all the other callbacks set on @a libvlc_video_set_output_callbacks()."]
#[doc = " \\param[in] cfg requested configuration of the video device"]
#[doc = " \\param[out] out libvlc_video_setup_device_info_t* to fill"]
#[doc = " \\return true on success"]
#[doc = " \\version LibVLC 4.0.0 or later"]
#[doc = ""]
#[doc = " For \\ref libvlc_video_engine_d3d9 the output must be a IDirect3D9*."]
#[doc = " A reference to this object is held until the \\ref libvlc_video_output_cleanup_cb is called."]
#[doc = " the device must be created with D3DPRESENT_PARAMETERS.hDeviceWindow set to 0."]
#[doc = ""]
#[doc = " For \\ref libvlc_video_engine_d3d11 the output must be a ID3D11DeviceContext*."]
#[doc = " A reference to this object is held until the \\ref libvlc_video_output_cleanup_cb is called."]
#[doc = " The ID3D11Device used to create ID3D11DeviceContext must have multithreading enabled."]
#[doc = ""]
#[doc = " If the ID3D11DeviceContext is used outside of the callbacks called by libvlc, the host"]
#[doc = " MUST use a mutex to protect the access to the ID3D11DeviceContext of libvlc. This mutex"]
#[doc = " value is set on d3d11.context_mutex. If the ID3D11DeviceContext is not used outside of"]
#[doc = " the callbacks, the mutex d3d11.context_mutex may be NULL."]
pub type libvlc_video_output_setup_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut *mut libc::c_void,
        cfg: *const libvlc_video_setup_device_cfg_t,
        out: *mut libvlc_video_setup_device_info_t,
    ) -> bool,
>;
#[doc = " Callback prototype called to release user data"]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer set on the opaque parameter of @a libvlc_video_output_setup_cb()"]
#[doc = " \\version LibVLC 4.0.0 or later"]
pub type libvlc_video_output_cleanup_cb =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_render_cfg_t {
    #[doc = " rendering video width in pixel"]
    pub width: libc::c_uint,
    #[doc = " rendering video height in pixel"]
    pub height: libc::c_uint,
    #[doc = " rendering video bit depth in bits per channel"]
    pub bitdepth: libc::c_uint,
    #[doc = " video is full range or studio/limited range"]
    pub full_range: bool,
    #[doc = " video color space"]
    pub colorspace: libvlc_video_color_space_t,
    #[doc = " video color primaries"]
    pub primaries: libvlc_video_color_primaries_t,
    #[doc = " video transfer function"]
    pub transfer: libvlc_video_transfer_func_t,
    #[doc = " device used for rendering, IDirect3DDevice9* for D3D9"]
    pub device: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_libvlc_video_render_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_render_cfg_t>(),
        40usize,
        concat!("Size of: ", stringify!(libvlc_video_render_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_render_cfg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_video_render_cfg_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_render_cfg_t>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_render_cfg_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_render_cfg_t>())).height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_render_cfg_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_render_cfg_t>())).bitdepth as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_render_cfg_t),
            "::",
            stringify!(bitdepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_render_cfg_t>())).full_range as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_render_cfg_t),
            "::",
            stringify!(full_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_render_cfg_t>())).colorspace as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_render_cfg_t),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_render_cfg_t>())).primaries as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_render_cfg_t),
            "::",
            stringify!(primaries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_render_cfg_t>())).transfer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_render_cfg_t),
            "::",
            stringify!(transfer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_render_cfg_t>())).device as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_render_cfg_t),
            "::",
            stringify!(device)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libvlc_video_output_cfg_t {
    pub __bindgen_anon_1: libvlc_video_output_cfg_t__bindgen_ty_1,
    #[doc = " Video is full range or studio/limited range."]
    pub full_range: bool,
    #[doc = " video color space"]
    pub colorspace: libvlc_video_color_space_t,
    #[doc = " video color primaries"]
    pub primaries: libvlc_video_color_primaries_t,
    #[doc = " video transfer function"]
    pub transfer: libvlc_video_transfer_func_t,
    #[doc = " video surface orientation"]
    pub orientation: libvlc_video_orient_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union libvlc_video_output_cfg_t__bindgen_ty_1 {
    #[doc = " The rendering DXGI_FORMAT for \\ref libvlc_video_engine_d3d11."]
    pub dxgi_format: libc::c_int,
    #[doc = " The rendering D3DFORMAT for \\ref libvlc_video_engine_d3d9."]
    pub d3d9_format: u32,
    #[doc = " The rendering GLint GL_RGBA or GL_RGB for"]
    #[doc = " \\ref libvlc_video_engine_opengl and for"]
    #[doc = " \\ref libvlc_video_engine_gles2."]
    pub opengl_format: libc::c_int,
    #[doc = " currently unused"]
    pub p_surface: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_libvlc_video_output_cfg_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_output_cfg_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_video_output_cfg_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_output_cfg_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_video_output_cfg_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t__bindgen_ty_1>())).dxgi_format
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t__bindgen_ty_1),
            "::",
            stringify!(dxgi_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t__bindgen_ty_1>())).d3d9_format
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t__bindgen_ty_1),
            "::",
            stringify!(d3d9_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t__bindgen_ty_1>())).opengl_format
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t__bindgen_ty_1),
            "::",
            stringify!(opengl_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t__bindgen_ty_1>())).p_surface
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t__bindgen_ty_1),
            "::",
            stringify!(p_surface)
        )
    );
}
#[test]
fn bindgen_test_layout_libvlc_video_output_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_output_cfg_t>(),
        32usize,
        concat!("Size of: ", stringify!(libvlc_video_output_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_output_cfg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_video_output_cfg_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t>())).full_range as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t),
            "::",
            stringify!(full_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t>())).colorspace as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t>())).primaries as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t),
            "::",
            stringify!(primaries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t>())).transfer as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t),
            "::",
            stringify!(transfer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_output_cfg_t>())).orientation as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_output_cfg_t),
            "::",
            stringify!(orientation)
        )
    );
}
#[doc = " Callback prototype called on video size changes."]
#[doc = " Update the rendering output setup."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer set on the opaque parameter of @a libvlc_video_output_setup_cb()"]
#[doc = " \\param[in] cfg configuration of the video that will be rendered"]
#[doc = " \\param[out] output configuration describing with how the rendering is setup"]
#[doc = " \\version LibVLC 4.0.0 or later"]
#[doc = ""]
#[doc = " \\note the configuration device for Direct3D9 is the IDirect3DDevice9 that VLC"]
#[doc = "       uses to render. The host must set a Render target and call Present()"]
#[doc = "       when it needs the drawing from VLC to be done. This object is not valid"]
#[doc = "       anymore after Cleanup is called."]
#[doc = ""]
#[doc = " Tone mapping, range and color conversion will be done depending on the values"]
#[doc = " set in the output structure."]
pub type libvlc_video_update_output_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        cfg: *const libvlc_video_render_cfg_t,
        output: *mut libvlc_video_output_cfg_t,
    ) -> bool,
>;
#[doc = " Callback prototype called after performing drawing calls."]
#[doc = ""]
#[doc = " This callback is called outside of libvlc_video_makeCurrent_cb current/not-current"]
#[doc = " calls."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer set on the opaque parameter of @a libvlc_video_output_setup_cb()"]
#[doc = " \\version LibVLC 4.0.0 or later"]
pub type libvlc_video_swap_cb =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>;
#[doc = " Callback prototype to set up the OpenGL context for rendering."]
#[doc = " Tell the host the rendering is about to start/has finished."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer set on the opaque parameter of @a libvlc_video_output_setup_cb()"]
#[doc = " \\param[in] enter true to set the context as current, false to unset it"]
#[doc = " \\return true on success"]
#[doc = " \\version LibVLC 4.0.0 or later"]
#[doc = ""]
#[doc = " On Direct3D11 the following may change on the provided ID3D11DeviceContext*"]
#[doc = " between \\p enter being true and \\p enter being false:"]
#[doc = " - IASetPrimitiveTopology()"]
#[doc = " - IASetInputLayout()"]
#[doc = " - IASetVertexBuffers()"]
#[doc = " - IASetIndexBuffer()"]
#[doc = " - VSSetConstantBuffers()"]
#[doc = " - VSSetShader()"]
#[doc = " - PSSetSamplers()"]
#[doc = " - PSSetConstantBuffers()"]
#[doc = " - PSSetShaderResources()"]
#[doc = " - PSSetShader()"]
#[doc = " - RSSetViewports()"]
#[doc = " - DrawIndexed()"]
pub type libvlc_video_makeCurrent_cb =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void, enter: bool) -> bool>;
#[doc = " Callback prototype to load opengl functions"]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer set on the opaque parameter of @a libvlc_video_output_setup_cb()"]
#[doc = " \\param fct_name name of the opengl function to load"]
#[doc = " \\return a pointer to the named OpenGL function the NULL otherwise"]
#[doc = " \\version LibVLC 4.0.0 or later"]
pub type libvlc_video_getProcAddress_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        fct_name: *const libc::c_char,
    ) -> *mut libc::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_frame_hdr10_metadata_t {
    pub RedPrimary: [u16; 2usize],
    pub GreenPrimary: [u16; 2usize],
    pub BluePrimary: [u16; 2usize],
    pub WhitePoint: [u16; 2usize],
    pub MaxMasteringLuminance: libc::c_uint,
    pub MinMasteringLuminance: libc::c_uint,
    pub MaxContentLightLevel: u16,
    pub MaxFrameAverageLightLevel: u16,
}
#[test]
fn bindgen_test_layout_libvlc_video_frame_hdr10_metadata_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_video_frame_hdr10_metadata_t>(),
        28usize,
        concat!("Size of: ", stringify!(libvlc_video_frame_hdr10_metadata_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_video_frame_hdr10_metadata_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_video_frame_hdr10_metadata_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_frame_hdr10_metadata_t>())).RedPrimary as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_frame_hdr10_metadata_t),
            "::",
            stringify!(RedPrimary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_frame_hdr10_metadata_t>())).GreenPrimary
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_frame_hdr10_metadata_t),
            "::",
            stringify!(GreenPrimary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_frame_hdr10_metadata_t>())).BluePrimary as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_frame_hdr10_metadata_t),
            "::",
            stringify!(BluePrimary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_frame_hdr10_metadata_t>())).WhitePoint as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_frame_hdr10_metadata_t),
            "::",
            stringify!(WhitePoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_frame_hdr10_metadata_t>())).MaxMasteringLuminance
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_frame_hdr10_metadata_t),
            "::",
            stringify!(MaxMasteringLuminance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_frame_hdr10_metadata_t>())).MinMasteringLuminance
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_frame_hdr10_metadata_t),
            "::",
            stringify!(MinMasteringLuminance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_frame_hdr10_metadata_t>())).MaxContentLightLevel
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_frame_hdr10_metadata_t),
            "::",
            stringify!(MaxContentLightLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_video_frame_hdr10_metadata_t>()))
                .MaxFrameAverageLightLevel as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_video_frame_hdr10_metadata_t),
            "::",
            stringify!(MaxFrameAverageLightLevel)
        )
    );
}
#[doc = "< libvlc_video_frame_hdr10_metadata_t"]
pub const libvlc_video_metadata_type_t_libvlc_video_metadata_frame_hdr10:
    libvlc_video_metadata_type_t = 0;
pub type libvlc_video_metadata_type_t = libc::c_uint;
#[doc = " Callback prototype to receive metadata before rendering."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer passed to the @a libvlc_video_set_output_callbacks()"]
#[doc = " \\param[in] type type of data passed in metadata"]
#[doc = " \\param[in] metadata the type of metadata"]
#[doc = " \\version LibVLC 4.0.0 or later"]
pub type libvlc_video_frameMetadata_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        type_: libvlc_video_metadata_type_t,
        metadata: *const libc::c_void,
    ),
>;
#[doc = " Disable rendering engine"]
pub const libvlc_video_engine_t_libvlc_video_engine_disable: libvlc_video_engine_t = 0;
#[doc = " Disable rendering engine"]
pub const libvlc_video_engine_t_libvlc_video_engine_opengl: libvlc_video_engine_t = 1;
#[doc = " Disable rendering engine"]
pub const libvlc_video_engine_t_libvlc_video_engine_gles2: libvlc_video_engine_t = 2;
#[doc = " Direct3D11 rendering engine"]
pub const libvlc_video_engine_t_libvlc_video_engine_d3d11: libvlc_video_engine_t = 3;
#[doc = " Direct3D9 rendering engine"]
pub const libvlc_video_engine_t_libvlc_video_engine_d3d9: libvlc_video_engine_t = 4;
#[doc = " Enumeration of the Video engine to be used on output."]
#[doc = " can be passed to @a libvlc_video_set_output_callbacks"]
pub type libvlc_video_engine_t = libc::c_uint;
#[doc = " Callback type that can be called to request a render size changes."]
#[doc = ""]
#[doc = " libvlc will provide a callback of this type when calling \\ref libvlc_video_output_set_resize_cb."]
#[doc = ""]
#[doc = " \\param report_opaque parameter passed to \\ref libvlc_video_output_set_resize_cb. [IN]"]
#[doc = " \\param width new rendering width requested. [IN]"]
#[doc = " \\param height new rendering height requested. [IN]"]
pub type libvlc_video_output_resize_cb = ::core::option::Option<
    unsafe extern "C" fn(
        report_opaque: *mut libc::c_void,
        width: libc::c_uint,
        height: libc::c_uint,
    ),
>;
#[doc = " Set the callback to call when the host app resizes the rendering area."]
#[doc = ""]
#[doc = " This allows text rendering and aspect ratio to be handled properly when the host"]
#[doc = " rendering size changes."]
#[doc = ""]
#[doc = " It may be called before the \\ref libvlc_video_output_setup_cb callback."]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer set on the opaque parameter of @a libvlc_video_output_setup_cb()"]
#[doc = " \\param[in] report_size_change callback which must be called when the host size changes."]
#[doc = "            The callback is valid until another call to \\ref libvlc_video_output_set_resize_cb"]
#[doc = "            is done. This may be called from any thread."]
#[doc = " \\param[in] report_opaque private pointer to pass to the \\ref report_size_change callback."]
pub type libvlc_video_output_set_resize_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        report_size_change: libvlc_video_output_resize_cb,
        report_opaque: *mut libc::c_void,
    ),
>;
#[doc = " Tell the host the rendering for the given plane is about to start"]
#[doc = ""]
#[doc = " \\param[in] opaque private pointer set on the opaque parameter of @a libvlc_video_output_setup_cb()"]
#[doc = " \\param plane number of the rendering plane to select"]
#[doc = " \\param output handle of the rendering output for the given plane"]
#[doc = " \\return true on success"]
#[doc = " \\version LibVLC 4.0.0 or later"]
#[doc = ""]
#[doc = " \\note This is only used with \\ref libvlc_video_engine_d3d11."]
#[doc = ""]
#[doc = " The output parameter receives the ID3D11RenderTargetView* to use for rendering"]
#[doc = " the plane."]
#[doc = ""]
#[doc = " If this callback is not used (set to NULL in @a libvlc_video_set_output_callbacks())"]
#[doc = " OMSetRenderTargets has to be set during the @a libvlc_video_makeCurrent_cb()"]
#[doc = " entering call."]
#[doc = ""]
#[doc = " The number of planes depend on the DXGI_FORMAT returned during the"]
#[doc = " @a libvlc_video_update_output_cb() call. It's usually one plane except for"]
#[doc = " semi-planar formats like DXGI_FORMAT_NV12 or DXGI_FORMAT_P010."]
#[doc = ""]
#[doc = " This callback is called between libvlc_video_makeCurrent_cb current/not-current"]
#[doc = " calls."]
pub type libvlc_video_output_select_plane_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        plane: size_t,
        output: *mut libc::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Set callbacks and data to render decoded video to a custom texture"]
    #[doc = ""]
    #[doc = " \\warning VLC will perform video rendering in its own thread and at its own rate,"]
    #[doc = " You need to provide your own synchronisation mechanism."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param engine the GPU engine to use"]
    #[doc = " \\param setup_cb callback called to initialize user data"]
    #[doc = " \\param cleanup_cb callback called to clean up user data"]
    #[doc = " \\param resize_cb callback to set the resize callback"]
    #[doc = " \\param update_output_cb callback to get the rendering format of the host (cannot be NULL)"]
    #[doc = " \\param swap_cb callback called after rendering a video frame (cannot be NULL)"]
    #[doc = " \\param makeCurrent_cb callback called to enter/leave the rendering context (cannot be NULL)"]
    #[doc = " \\param getProcAddress_cb opengl function loading callback (cannot be NULL for \\ref libvlc_video_engine_opengl and for \\ref libvlc_video_engine_gles2)"]
    #[doc = " \\param metadata_cb callback to provide frame metadata (D3D11 only)"]
    #[doc = " \\param select_plane_cb callback to select different D3D11 rendering targets"]
    #[doc = " \\param opaque private pointer passed to callbacks"]
    #[doc = ""]
    #[doc = " \\note the \\p setup_cb and \\p cleanup_cb may be called more than once per"]
    #[doc = " playback."]
    #[doc = ""]
    #[doc = " \\retval true engine selected and callbacks set"]
    #[doc = " \\retval false engine type unknown, callbacks not set"]
    #[doc = " \\version LibVLC 4.0.0 or later"]
    pub fn libvlc_video_set_output_callbacks(
        mp: *mut libvlc_media_player_t,
        engine: libvlc_video_engine_t,
        setup_cb: libvlc_video_output_setup_cb,
        cleanup_cb: libvlc_video_output_cleanup_cb,
        resize_cb: libvlc_video_output_set_resize_cb,
        update_output_cb: libvlc_video_update_output_cb,
        swap_cb: libvlc_video_swap_cb,
        makeCurrent_cb: libvlc_video_makeCurrent_cb,
        getProcAddress_cb: libvlc_video_getProcAddress_cb,
        metadata_cb: libvlc_video_frameMetadata_cb,
        select_plane_cb: libvlc_video_output_select_plane_cb,
        opaque: *mut libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the NSView handler where the media player should render its video output."]
    #[doc = ""]
    #[doc = " Use the vout called \"macosx\"."]
    #[doc = ""]
    #[doc = " The drawable is an NSObject that follow the VLCVideoViewEmbedding"]
    #[doc = " protocol:"]
    #[doc = ""]
    #[doc = " @code{.m}"]
    #[doc = " @protocol VLCVideoViewEmbedding <NSObject>"]
    #[doc = " - (void)addVoutSubview:(NSView *)view;"]
    #[doc = " - (void)removeVoutSubview:(NSView *)view;"]
    #[doc = " @end"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " Or it can be an NSView object."]
    #[doc = ""]
    #[doc = " If you want to use it along with Qt see the QMacCocoaViewContainer. Then"]
    #[doc = " the following code should work:"]
    #[doc = " @code{.mm}"]
    #[doc = " {"]
    #[doc = "     NSView *video = [[NSView alloc] init];"]
    #[doc = "     QMacCocoaViewContainer *container = new QMacCocoaViewContainer(video, parent);"]
    #[doc = "     libvlc_media_player_set_nsobject(mp, video);"]
    #[doc = "     [video release];"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " You can find a live example in VLCVideoView in VLCKit.framework."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param drawable the drawable that is either an NSView or an object following"]
    #[doc = " the VLCVideoViewEmbedding protocol."]
    pub fn libvlc_media_player_set_nsobject(
        p_mi: *mut libvlc_media_player_t,
        drawable: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Get the NSView handler previously set with libvlc_media_player_set_nsobject()."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return the NSView handler or 0 if none where set"]
    pub fn libvlc_media_player_get_nsobject(p_mi: *mut libvlc_media_player_t) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set an X Window System drawable where the media player should render its"]
    #[doc = " video output. The call takes effect when the playback starts. If it is"]
    #[doc = " already started, it might need to be stopped before changes apply."]
    #[doc = " If LibVLC was built without X11 output support, then this function has no"]
    #[doc = " effects."]
    #[doc = ""]
    #[doc = " By default, LibVLC will capture input events on the video rendering area."]
    #[doc = " Use libvlc_video_set_mouse_input() and libvlc_video_set_key_input() to"]
    #[doc = " disable that and deliver events to the parent window / to the application"]
    #[doc = " instead. By design, the X11 protocol delivers input events to only one"]
    #[doc = " recipient."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " The application must call the XInitThreads() function from Xlib before"]
    #[doc = " libvlc_new(), and before any call to XOpenDisplay() directly or via any"]
    #[doc = " other library. Failure to call XInitThreads() will seriously impede LibVLC"]
    #[doc = " performance. Calling XOpenDisplay() before XInitThreads() will eventually"]
    #[doc = " crash the process. That is a limitation of Xlib."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param drawable X11 window ID"]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " The specified identifier must correspond to an existing Input/Output class"]
    #[doc = " X11 window. Pixmaps are <b>not</b> currently supported. The default X11"]
    #[doc = " server is assumed, i.e. that specified in the DISPLAY environment variable."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " LibVLC can deal with invalid X11 handle errors, however some display drivers"]
    #[doc = " (EGL, GLX, VA and/or VDPAU) can unfortunately not. Thus the window handle"]
    #[doc = " must remain valid until playback is stopped, otherwise the process may"]
    #[doc = " abort or crash."]
    #[doc = ""]
    #[doc = " \\bug"]
    #[doc = " No more than one window handle per media player instance can be specified."]
    #[doc = " If the media has multiple simultaneously active video tracks, extra tracks"]
    #[doc = " will be rendered into external windows beyond the control of the"]
    #[doc = " application."]
    pub fn libvlc_media_player_set_xwindow(p_mi: *mut libvlc_media_player_t, drawable: u32);
}
extern "C" {
    #[doc = " Get the X Window System window identifier previously set with"]
    #[doc = " libvlc_media_player_set_xwindow(). Note that this will return the identifier"]
    #[doc = " even if VLC is not currently using it (for instance if it is playing an"]
    #[doc = " audio-only input)."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return an X window ID, or 0 if none where set."]
    pub fn libvlc_media_player_get_xwindow(p_mi: *mut libvlc_media_player_t) -> u32;
}
extern "C" {
    #[doc = " Set a Win32/Win64 API window handle (HWND) where the media player should"]
    #[doc = " render its video output. If LibVLC was built without Win32/Win64 API output"]
    #[doc = " support, then this has no effects."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param drawable windows handle of the drawable"]
    pub fn libvlc_media_player_set_hwnd(
        p_mi: *mut libvlc_media_player_t,
        drawable: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Get the Windows API window handle (HWND) previously set with"]
    #[doc = " libvlc_media_player_set_hwnd(). The handle will be returned even if LibVLC"]
    #[doc = " is not currently outputting any video to it."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return a window handle or NULL if there are none."]
    pub fn libvlc_media_player_get_hwnd(p_mi: *mut libvlc_media_player_t) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set the android context."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param p_awindow_handler org.videolan.libvlc.AWindow jobject owned by the"]
    #[doc = "        org.videolan.libvlc.MediaPlayer class from the libvlc-android project."]
    pub fn libvlc_media_player_set_android_context(
        p_mi: *mut libvlc_media_player_t,
        p_awindow_handler: *mut libc::c_void,
    );
}
#[doc = " Callback prototype for audio playback."]
#[doc = ""]
#[doc = " The LibVLC media player decodes and post-processes the audio signal"]
#[doc = " asynchronously (in an internal thread). Whenever audio samples are ready"]
#[doc = " to be queued to the output, this callback is invoked."]
#[doc = ""]
#[doc = " The number of samples provided per invocation may depend on the file format,"]
#[doc = " the audio coding algorithm, the decoder plug-in, the post-processing"]
#[doc = " filters and timing. Application must not assume a certain number of samples."]
#[doc = ""]
#[doc = " The exact format of audio samples is determined by libvlc_audio_set_format()"]
#[doc = " or libvlc_audio_set_format_callbacks() as is the channels layout."]
#[doc = ""]
#[doc = " Note that the number of samples is per channel. For instance, if the audio"]
#[doc = " track sampling rate is 48000 Hz, then 1200 samples represent 25 milliseconds"]
#[doc = " of audio signal - regardless of the number of audio channels."]
#[doc = ""]
#[doc = " \\param[in] data data pointer as passed to libvlc_audio_set_callbacks()"]
#[doc = " \\param[in] samples pointer to a table of audio samples to play back"]
#[doc = " \\param count number of audio samples to play back"]
#[doc = " \\param pts expected play time stamp (see libvlc_delay())"]
pub type libvlc_audio_play_cb = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut libc::c_void,
        samples: *const libc::c_void,
        count: libc::c_uint,
        pts: i64,
    ),
>;
#[doc = " Callback prototype for audio pause."]
#[doc = ""]
#[doc = " LibVLC invokes this callback to pause audio playback."]
#[doc = ""]
#[doc = " \\note The pause callback is never called if the audio is already paused."]
#[doc = " \\param[in] data data pointer as passed to libvlc_audio_set_callbacks()"]
#[doc = " \\param pts time stamp of the pause request (should be elapsed already)"]
pub type libvlc_audio_pause_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void, pts: i64)>;
#[doc = " Callback prototype for audio resumption."]
#[doc = ""]
#[doc = " LibVLC invokes this callback to resume audio playback after it was"]
#[doc = " previously paused."]
#[doc = ""]
#[doc = " \\note The resume callback is never called if the audio is not paused."]
#[doc = " \\param[in] data data pointer as passed to libvlc_audio_set_callbacks()"]
#[doc = " \\param pts time stamp of the resumption request (should be elapsed already)"]
pub type libvlc_audio_resume_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void, pts: i64)>;
#[doc = " Callback prototype for audio buffer flush."]
#[doc = ""]
#[doc = " LibVLC invokes this callback if it needs to discard all pending buffers and"]
#[doc = " stop playback as soon as possible. This typically occurs when the media is"]
#[doc = " stopped."]
#[doc = ""]
#[doc = " \\param[in] data data pointer as passed to libvlc_audio_set_callbacks()"]
pub type libvlc_audio_flush_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void, pts: i64)>;
#[doc = " Callback prototype for audio buffer drain."]
#[doc = ""]
#[doc = " LibVLC may invoke this callback when the decoded audio track is ending."]
#[doc = " There will be no further decoded samples for the track, but playback should"]
#[doc = " nevertheless continue until all already pending buffers are rendered."]
#[doc = ""]
#[doc = " \\param[in] data data pointer as passed to libvlc_audio_set_callbacks()"]
pub type libvlc_audio_drain_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
#[doc = " Callback prototype for audio volume change."]
#[doc = " \\param[in] data data pointer as passed to libvlc_audio_set_callbacks()"]
#[doc = " \\param volume software volume (1. = nominal, 0. = mute)"]
#[doc = " \\param mute muted flag"]
pub type libvlc_audio_set_volume_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void, volume: f32, mute: bool)>;
extern "C" {
    #[doc = " Sets callbacks and private data for decoded audio."]
    #[doc = ""]
    #[doc = " Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()"]
    #[doc = " to configure the decoded audio format."]
    #[doc = ""]
    #[doc = " \\note The audio callbacks override any other audio output mechanism."]
    #[doc = " If the callbacks are set, LibVLC will <b>not</b> output audio in any way."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param play callback to play audio samples (must not be NULL)"]
    #[doc = " \\param pause callback to pause playback (or NULL to ignore)"]
    #[doc = " \\param resume callback to resume playback (or NULL to ignore)"]
    #[doc = " \\param flush callback to flush audio buffers (or NULL to ignore)"]
    #[doc = " \\param drain callback to drain audio buffers (or NULL to ignore)"]
    #[doc = " \\param opaque private pointer for the audio callbacks (as first parameter)"]
    #[doc = " \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_audio_set_callbacks(
        mp: *mut libvlc_media_player_t,
        play: libvlc_audio_play_cb,
        pause: libvlc_audio_pause_cb,
        resume: libvlc_audio_resume_cb,
        flush: libvlc_audio_flush_cb,
        drain: libvlc_audio_drain_cb,
        opaque: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Set callbacks and private data for decoded audio. This only works in"]
    #[doc = " combination with libvlc_audio_set_callbacks()."]
    #[doc = " Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()"]
    #[doc = " to configure the decoded audio format."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param set_volume callback to apply audio volume,"]
    #[doc = "                   or NULL to apply volume in software"]
    #[doc = " \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_audio_set_volume_callback(
        mp: *mut libvlc_media_player_t,
        set_volume: libvlc_audio_set_volume_cb,
    );
}
#[doc = " Callback prototype to setup the audio playback."]
#[doc = ""]
#[doc = " This is called when the media player needs to create a new audio output."]
#[doc = " \\param[in,out] opaque pointer to the data pointer passed to"]
#[doc = "               libvlc_audio_set_callbacks()"]
#[doc = " \\param[in,out] format 4 bytes sample format"]
#[doc = " \\param[in,out] rate sample rate"]
#[doc = " \\param[in,out] channels channels count"]
#[doc = " \\return 0 on success, anything else to skip audio playback"]
pub type libvlc_audio_setup_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut *mut libc::c_void,
        format: *mut libc::c_char,
        rate: *mut libc::c_uint,
        channels: *mut libc::c_uint,
    ) -> libc::c_int,
>;
#[doc = " Callback prototype for audio playback cleanup."]
#[doc = ""]
#[doc = " This is called when the media player no longer needs an audio output."]
#[doc = " \\param[in] opaque data pointer as passed to libvlc_audio_set_callbacks()"]
pub type libvlc_audio_cleanup_cb =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>;
extern "C" {
    #[doc = " Sets decoded audio format via callbacks."]
    #[doc = ""]
    #[doc = " This only works in combination with libvlc_audio_set_callbacks()."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param setup callback to select the audio format (cannot be NULL)"]
    #[doc = " \\param cleanup callback to release any allocated resources (or NULL)"]
    #[doc = " \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_audio_set_format_callbacks(
        mp: *mut libvlc_media_player_t,
        setup: libvlc_audio_setup_cb,
        cleanup: libvlc_audio_cleanup_cb,
    );
}
extern "C" {
    #[doc = " Sets a fixed decoded audio format."]
    #[doc = ""]
    #[doc = " This only works in combination with libvlc_audio_set_callbacks(),"]
    #[doc = " and is mutually exclusive with libvlc_audio_set_format_callbacks()."]
    #[doc = ""]
    #[doc = " The supported formats are:"]
    #[doc = " - \"S16N\" for signed 16-bit PCM"]
    #[doc = " - \"S32N\" for signed 32-bit PCM"]
    #[doc = " - \"FL32\" for single precision IEEE 754"]
    #[doc = ""]
    #[doc = " All supported formats use the native endianess."]
    #[doc = " If there are more than one channel, samples are interleaved."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param format a four-characters string identifying the sample format"]
    #[doc = " \\param rate sample rate (expressed in Hz)"]
    #[doc = " \\param channels channels count"]
    #[doc = " \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_audio_set_format(
        mp: *mut libvlc_media_player_t,
        format: *const libc::c_char,
        rate: libc::c_uint,
        channels: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Get the current movie length (in ms)."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return the movie length (in ms), or -1 if there is no media."]
    pub fn libvlc_media_player_get_length(p_mi: *mut libvlc_media_player_t) -> libvlc_time_t;
}
extern "C" {
    #[doc = " Get the current movie time (in ms)."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return the movie time (in ms), or -1 if there is no media."]
    pub fn libvlc_media_player_get_time(p_mi: *mut libvlc_media_player_t) -> libvlc_time_t;
}
extern "C" {
    #[doc = " Set the movie time (in ms). This has no effect if no media is being played."]
    #[doc = " Not all formats and protocols support this."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param b_fast prefer fast seeking or precise seeking"]
    #[doc = " \\param i_time the movie time (in ms)."]
    #[doc = " \\return 0 on success, -1 on error"]
    pub fn libvlc_media_player_set_time(
        p_mi: *mut libvlc_media_player_t,
        i_time: libvlc_time_t,
        b_fast: bool,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get movie position as percentage between 0.0 and 1.0."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return movie position, or -1. in case of error"]
    pub fn libvlc_media_player_get_position(p_mi: *mut libvlc_media_player_t) -> f32;
}
extern "C" {
    #[doc = " Set movie position as percentage between 0.0 and 1.0."]
    #[doc = " This has no effect if playback is not enabled."]
    #[doc = " This might not work depending on the underlying input format and protocol."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param b_fast prefer fast seeking or precise seeking"]
    #[doc = " \\param f_pos the position"]
    #[doc = " \\return 0 on success, -1 on error"]
    pub fn libvlc_media_player_set_position(
        p_mi: *mut libvlc_media_player_t,
        f_pos: f32,
        b_fast: bool,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set movie chapter (if applicable)."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param i_chapter chapter number to play"]
    pub fn libvlc_media_player_set_chapter(
        p_mi: *mut libvlc_media_player_t,
        i_chapter: libc::c_int,
    );
}
extern "C" {
    #[doc = " Get movie chapter."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return chapter number currently playing, or -1 if there is no media."]
    pub fn libvlc_media_player_get_chapter(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Get movie chapter count"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return number of chapters in movie, or -1."]
    pub fn libvlc_media_player_get_chapter_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Get title chapter count"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param i_title title"]
    #[doc = " \\return number of chapters in title, or -1"]
    pub fn libvlc_media_player_get_chapter_count_for_title(
        p_mi: *mut libvlc_media_player_t,
        i_title: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set movie title"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param i_title title number to play"]
    pub fn libvlc_media_player_set_title(p_mi: *mut libvlc_media_player_t, i_title: libc::c_int);
}
extern "C" {
    #[doc = " Get movie title"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return title number currently playing, or -1"]
    pub fn libvlc_media_player_get_title(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Get movie title count"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return title number count, or -1"]
    pub fn libvlc_media_player_get_title_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Set previous chapter (if applicable)"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    pub fn libvlc_media_player_previous_chapter(p_mi: *mut libvlc_media_player_t);
}
extern "C" {
    #[doc = " Set next chapter (if applicable)"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    pub fn libvlc_media_player_next_chapter(p_mi: *mut libvlc_media_player_t);
}
extern "C" {
    #[doc = " Get the requested movie play rate."]
    #[doc = " @warning Depending on the underlying media, the requested rate may be"]
    #[doc = " different from the real playback rate."]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return movie play rate"]
    pub fn libvlc_media_player_get_rate(p_mi: *mut libvlc_media_player_t) -> f32;
}
extern "C" {
    #[doc = " Set movie play rate"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param rate movie play rate to set"]
    #[doc = " \\return -1 if an error was detected, 0 otherwise (but even then, it might"]
    #[doc = " not actually work depending on the underlying media protocol)"]
    pub fn libvlc_media_player_set_rate(p_mi: *mut libvlc_media_player_t, rate: f32)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Get current movie state"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\return the current state of the media player (playing, paused, ...) \\see libvlc_state_t"]
    pub fn libvlc_media_player_get_state(p_mi: *mut libvlc_media_player_t) -> libvlc_state_t;
}
extern "C" {
    #[doc = " How many video outputs does this media player have?"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\return the number of video outputs"]
    pub fn libvlc_media_player_has_vout(p_mi: *mut libvlc_media_player_t) -> libc::c_uint;
}
extern "C" {
    #[doc = " Is this media player seekable?"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\retval true media player can seek"]
    #[doc = " \\retval false media player cannot seek"]
    pub fn libvlc_media_player_is_seekable(p_mi: *mut libvlc_media_player_t) -> bool;
}
extern "C" {
    #[doc = " Can this media player be paused?"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\retval true media player can be paused"]
    #[doc = " \\retval false media player cannot be paused"]
    pub fn libvlc_media_player_can_pause(p_mi: *mut libvlc_media_player_t) -> bool;
}
extern "C" {
    #[doc = " Check if the current program is scrambled"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\retval true current program is scrambled"]
    #[doc = " \\retval false current program is not scrambled"]
    #[doc = ""]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_media_player_program_scrambled(p_mi: *mut libvlc_media_player_t) -> bool;
}
extern "C" {
    #[doc = " Display the next frame (if supported)"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    pub fn libvlc_media_player_next_frame(p_mi: *mut libvlc_media_player_t);
}
extern "C" {
    #[doc = " Navigate through DVD Menu"]
    #[doc = ""]
    #[doc = " \\param p_mi the Media Player"]
    #[doc = " \\param navigate the Navigation mode"]
    #[doc = " \\version libVLC 2.0.0 or later"]
    pub fn libvlc_media_player_navigate(p_mi: *mut libvlc_media_player_t, navigate: libc::c_uint);
}
extern "C" {
    #[doc = " Set if, and how, the video title will be shown when media is played."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param position position at which to display the title, or libvlc_position_disable to prevent the title from being displayed"]
    #[doc = " \\param timeout title display timeout in milliseconds (ignored if libvlc_position_disable)"]
    #[doc = " \\version libVLC 2.1.0 or later"]
    pub fn libvlc_media_player_set_video_title_display(
        p_mi: *mut libvlc_media_player_t,
        position: libvlc_position_t,
        timeout: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Get the track list for one type"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\note You need to call libvlc_media_parse_with_options() or play the media"]
    #[doc = " at least once before calling this function.  Not doing this will result in"]
    #[doc = " an empty list."]
    #[doc = ""]
    #[doc = " \\note This track list is a snapshot of the current tracks when this function"]
    #[doc = " is called. If a track is updated after this call, the user will need to call"]
    #[doc = " this function again to get the updated track."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " The track list can be used to get track information and to select specific"]
    #[doc = " tracks."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param type type of the track list to request"]
    #[doc = ""]
    #[doc = " \\return a valid libvlc_media_tracklist_t or NULL in case of error, if there"]
    #[doc = " is no track for a category, the returned list will have a size of 0, delete"]
    #[doc = " with libvlc_media_tracklist_delete()"]
    pub fn libvlc_media_player_get_tracklist(
        p_mi: *mut libvlc_media_player_t,
        type_: libvlc_track_type_t,
    ) -> *mut libvlc_media_tracklist_t;
}
extern "C" {
    #[doc = " Get the selected track for one type"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\warning More than one tracks can be selected for one type. In that case,"]
    #[doc = " libvlc_media_player_get_tracklist() should be used."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param type type of the selected track"]
    #[doc = ""]
    #[doc = " \\return a valid track or NULL if there is no selected tracks for this type,"]
    #[doc = " release it with libvlc_media_track_release()."]
    pub fn libvlc_media_player_get_selected_track(
        p_mi: *mut libvlc_media_player_t,
        type_: libvlc_track_type_t,
    ) -> *mut libvlc_media_track_t;
}
extern "C" {
    pub fn libvlc_media_player_get_track_from_id(
        p_mi: *mut libvlc_media_player_t,
        psz_id: *const libc::c_char,
    ) -> *mut libvlc_media_track_t;
}
extern "C" {
    #[doc = " Select a track"]
    #[doc = ""]
    #[doc = " This will unselected the current track."]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\note Use libvlc_media_player_select_tracks() for multiple selection"]
    #[doc = ""]
    #[doc = " \\warning Only use a \\ref libvlc_media_track_t retrieved with \\ref libvlc_media_player_get_tracklist"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param track track to select, can't be NULL"]
    pub fn libvlc_media_player_select_track(
        p_mi: *mut libvlc_media_player_t,
        track: *const libvlc_media_track_t,
    );
}
extern "C" {
    #[doc = " Unselect all tracks for a given type"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param type type to unselect"]
    pub fn libvlc_media_player_unselect_track_type(
        p_mi: *mut libvlc_media_player_t,
        type_: libvlc_track_type_t,
    );
}
extern "C" {
    #[doc = " Select multiple tracks for one type"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\note The internal track list can change between the calls of"]
    #[doc = " libvlc_media_player_get_tracklist() and"]
    #[doc = " libvlc_media_player_set_tracks(). If a track selection change but the"]
    #[doc = " track is not present anymore, the player will just ignore it."]
    #[doc = ""]
    #[doc = " \\note selecting multiple audio tracks is currently not supported."]
    #[doc = ""]
    #[doc = " \\warning Only use a \\ref libvlc_media_track_t retrieved with \\ref libvlc_media_player_get_tracklist"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param type type of the selected track"]
    #[doc = " \\param tracks pointer to the track array, or NULL if track_count is 0"]
    #[doc = " \\param track_count number of tracks in the track array"]
    pub fn libvlc_media_player_select_tracks(
        p_mi: *mut libvlc_media_player_t,
        type_: libvlc_track_type_t,
        tracks: *mut *const libvlc_media_track_t,
        track_count: size_t,
    );
}
extern "C" {
    #[doc = " Select tracks by their string identifier"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " This function can be used pre-select a list of tracks before starting the"]
    #[doc = " player. It has only effect for the current media. It can also be used when"]
    #[doc = " the player is already started."]
    #[doc = ""]
    #[doc = " 'str_ids' can contain more than one track id, delimited with ','. \"\" or any"]
    #[doc = " invalid track id will cause the player to unselect all tracks of that"]
    #[doc = " category. NULL will disable the preference for newer tracks without"]
    #[doc = " unselecting any current tracks."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = " - (libvlc_track_video, \"video/1,video/2\") will select these 2 video tracks."]
    #[doc = " If there is only one video track with the id \"video/0\", no tracks will be"]
    #[doc = " selected."]
    #[doc = " - (libvlc_track_type_t, \"${slave_url_md5sum}/spu/0) will select one spu"]
    #[doc = " added by an input slave with the corresponding url."]
    #[doc = ""]
    #[doc = " \\note The string identifier of a track can be found via psz_id from \\ref"]
    #[doc = " libvlc_media_track_t"]
    #[doc = ""]
    #[doc = " \\note selecting multiple audio tracks is currently not supported."]
    #[doc = ""]
    #[doc = " \\warning Only use a \\ref libvlc_media_track_t id retrieved with \\ref libvlc_media_player_get_tracklist"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param type type to select"]
    #[doc = " \\param psz_ids list of string identifier or NULL"]
    pub fn libvlc_media_player_select_tracks_by_ids(
        p_mi: *mut libvlc_media_player_t,
        type_: libvlc_track_type_t,
        psz_ids: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " Add a slave to the current media player."]
    #[doc = ""]
    #[doc = " \\note If the player is playing, the slave will be added directly. This call"]
    #[doc = " will also update the slave list of the attached libvlc_media_t."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_slaves_add"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param i_type subtitle or audio"]
    #[doc = " \\param psz_uri Uri of the slave (should contain a valid scheme)."]
    #[doc = " \\param b_select True if this slave should be selected when it's loaded"]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn libvlc_media_player_add_slave(
        p_mi: *mut libvlc_media_player_t,
        i_type: libvlc_media_slave_type_t,
        psz_uri: *const libc::c_char,
        b_select: bool,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_player_program_t {
    #[doc = " Id used for libvlc_media_player_select_program()"]
    pub i_group_id: libc::c_int,
    #[doc = " Program name, always valid"]
    pub psz_name: *mut libc::c_char,
    #[doc = " True if the program is selected"]
    pub b_selected: bool,
    #[doc = " True if the program is scrambled"]
    pub b_scrambled: bool,
}
#[test]
fn bindgen_test_layout_libvlc_player_program_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_player_program_t>(),
        24usize,
        concat!("Size of: ", stringify!(libvlc_player_program_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_player_program_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_player_program_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_player_program_t>())).i_group_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_player_program_t),
            "::",
            stringify!(i_group_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_player_program_t>())).psz_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_player_program_t),
            "::",
            stringify!(psz_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_player_program_t>())).b_selected as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_player_program_t),
            "::",
            stringify!(b_selected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_player_program_t>())).b_scrambled as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_player_program_t),
            "::",
            stringify!(b_scrambled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_player_programlist_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Delete a program struct"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param program returned by libvlc_media_player_get_selected_program() or"]
    #[doc = " libvlc_media_player_get_program_from_id()"]
    #[doc = ""]
    pub fn libvlc_player_program_delete(program: *mut libvlc_player_program_t);
}
extern "C" {
    #[doc = " Get the number of programs in a programlist"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param list valid programlist"]
    #[doc = ""]
    #[doc = " \\return number of programs, or 0 if the list is empty"]
    pub fn libvlc_player_programlist_count(list: *const libvlc_player_programlist_t) -> size_t;
}
extern "C" {
    #[doc = " Get a program at a specific index"]
    #[doc = ""]
    #[doc = " \\warning The behaviour is undefined if the index is not valid."]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param list valid programlist"]
    #[doc = " \\param index valid index in the range [0; count["]
    #[doc = ""]
    #[doc = " \\return a valid program (can't be NULL if libvlc_player_programlist_count()"]
    #[doc = " returned a valid count)"]
    pub fn libvlc_player_programlist_at(
        list: *mut libvlc_player_programlist_t,
        index: size_t,
    ) -> *mut libvlc_player_program_t;
}
extern "C" {
    #[doc = " Release a programlist"]
    #[doc = ""]
    #[doc = " \\note program structs from the list are also deleted."]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_player_get_programlist"]
    #[doc = ""]
    #[doc = " \\param list valid programlist"]
    pub fn libvlc_player_programlist_delete(list: *mut libvlc_player_programlist_t);
}
extern "C" {
    #[doc = " Select program with a given program id."]
    #[doc = ""]
    #[doc = " \\note program ids are sent via the libvlc_MediaPlayerProgramAdded event or"]
    #[doc = " can be fetch via libvlc_media_player_get_programlist()"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 or later"]
    #[doc = ""]
    #[doc = " \\param p_mi opaque media player handle"]
    #[doc = " \\param i_group_id program id"]
    pub fn libvlc_media_player_select_program_id(
        p_mi: *mut libvlc_media_player_t,
        i_group_id: libc::c_int,
    );
}
extern "C" {
    #[doc = " Get the selected program"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 or later"]
    #[doc = ""]
    #[doc = " \\param p_mi opaque media player handle"]
    #[doc = ""]
    #[doc = " \\return a valid program struct or NULL if no programs are selected. The"]
    #[doc = " program need to be freed with libvlc_player_program_delete()."]
    pub fn libvlc_media_player_get_selected_program(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_player_program_t;
}
extern "C" {
    #[doc = " Get a program struct from a program id"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 or later"]
    #[doc = ""]
    #[doc = " \\param p_mi opaque media player handle"]
    #[doc = " \\param i_group_id program id"]
    #[doc = ""]
    #[doc = " \\return a valid program struct or NULL if the i_group_id is not found. The"]
    #[doc = " program need to be freed with libvlc_player_program_delete()."]
    pub fn libvlc_media_player_get_program_from_id(
        p_mi: *mut libvlc_media_player_t,
        i_group_id: libc::c_int,
    ) -> *mut libvlc_player_program_t;
}
extern "C" {
    #[doc = " Get the program list"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later."]
    #[doc = " \\note This program list is a snapshot of the current programs when this"]
    #[doc = " function is called. If a program is updated after this call, the user will"]
    #[doc = " need to call this function again to get the updated program."]
    #[doc = ""]
    #[doc = " The program list can be used to get program information and to select"]
    #[doc = " specific programs."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = ""]
    #[doc = " \\return a valid libvlc_media_programlist_t or NULL in case of error or empty"]
    #[doc = " list, delete with libvlc_media_programlist_delete()"]
    pub fn libvlc_media_player_get_programlist(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_player_programlist_t;
}
extern "C" {
    #[doc = " Toggle fullscreen status on non-embedded video outputs."]
    #[doc = ""]
    #[doc = " @warning The same limitations applies to this function"]
    #[doc = " as to libvlc_set_fullscreen()."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    pub fn libvlc_toggle_fullscreen(p_mi: *mut libvlc_media_player_t);
}
extern "C" {
    #[doc = " Enable or disable fullscreen."]
    #[doc = ""]
    #[doc = " @warning With most window managers, only a top-level windows can be in"]
    #[doc = " full-screen mode. Hence, this function will not operate properly if"]
    #[doc = " libvlc_media_player_set_xwindow() was used to embed the video in a"]
    #[doc = " non-top-level window. In that case, the embedding window must be reparented"]
    #[doc = " to the root window <b>before</b> fullscreen mode is enabled. You will want"]
    #[doc = " to reparent it back to its normal parent when disabling fullscreen."]
    #[doc = ""]
    #[doc = " \\note This setting applies to any and all current or future active video"]
    #[doc = " tracks and windows for the given media player. The choice of fullscreen"]
    #[doc = " output for each window is left to the operating system."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param b_fullscreen boolean for fullscreen status"]
    pub fn libvlc_set_fullscreen(p_mi: *mut libvlc_media_player_t, b_fullscreen: bool);
}
extern "C" {
    #[doc = " Get current fullscreen status."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\return the fullscreen status (boolean)"]
    #[doc = ""]
    #[doc = " \\retval false media player is windowed"]
    #[doc = " \\retval true media player is in fullscreen mode"]
    pub fn libvlc_get_fullscreen(p_mi: *mut libvlc_media_player_t) -> bool;
}
extern "C" {
    #[doc = " Enable or disable key press events handling, according to the LibVLC hotkeys"]
    #[doc = " configuration. By default and for historical reasons, keyboard events are"]
    #[doc = " handled by the LibVLC video widget."]
    #[doc = ""]
    #[doc = " \\note On X11, there can be only one subscriber for key press and mouse"]
    #[doc = " click events per window. If your application has subscribed to those events"]
    #[doc = " for the X window ID of the video widget, then LibVLC will not be able to"]
    #[doc = " handle key presses and mouse clicks in any case."]
    #[doc = ""]
    #[doc = " \\warning This function is only implemented for X11 and Win32 at the moment."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param on true to handle key press events, false to ignore them."]
    pub fn libvlc_video_set_key_input(p_mi: *mut libvlc_media_player_t, on: libc::c_uint);
}
extern "C" {
    #[doc = " Enable or disable mouse click events handling. By default, those events are"]
    #[doc = " handled. This is needed for DVD menus to work, as well as a few video"]
    #[doc = " filters such as \"puzzle\"."]
    #[doc = ""]
    #[doc = " \\see libvlc_video_set_key_input()."]
    #[doc = ""]
    #[doc = " \\warning This function is only implemented for X11 and Win32 at the moment."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param on true to handle mouse click events, false to ignore them."]
    pub fn libvlc_video_set_mouse_input(p_mi: *mut libvlc_media_player_t, on: libc::c_uint);
}
extern "C" {
    #[doc = " Get the pixel dimensions of a video."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param num number of the video (starting from, and most commonly 0)"]
    #[doc = " \\param[out] px pointer to get the pixel width"]
    #[doc = " \\param[out] py pointer to get the pixel height"]
    #[doc = " \\return 0 on success, -1 if the specified video does not exist"]
    pub fn libvlc_video_get_size(
        p_mi: *mut libvlc_media_player_t,
        num: libc::c_uint,
        px: *mut libc::c_uint,
        py: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the mouse pointer coordinates over a video."]
    #[doc = " Coordinates are expressed in terms of the decoded video resolution,"]
    #[doc = " <b>not</b> in terms of pixels on the screen/viewport (to get the latter,"]
    #[doc = " you can query your windowing system directly)."]
    #[doc = ""]
    #[doc = " Either of the coordinates may be negative or larger than the corresponding"]
    #[doc = " dimension of the video, if the cursor is outside the rendering area."]
    #[doc = ""]
    #[doc = " @warning The coordinates may be out-of-date if the pointer is not located"]
    #[doc = " on the video rendering area. LibVLC does not track the pointer if it is"]
    #[doc = " outside of the video widget."]
    #[doc = ""]
    #[doc = " @note LibVLC does not support multiple pointers (it does of course support"]
    #[doc = " multiple input devices sharing the same pointer) at the moment."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param num number of the video (starting from, and most commonly 0)"]
    #[doc = " \\param[out] px pointer to get the abscissa"]
    #[doc = " \\param[out] py pointer to get the ordinate"]
    #[doc = " \\return 0 on success, -1 if the specified video does not exist"]
    pub fn libvlc_video_get_cursor(
        p_mi: *mut libvlc_media_player_t,
        num: libc::c_uint,
        px: *mut libc::c_int,
        py: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current video scaling factor."]
    #[doc = " See also libvlc_video_set_scale()."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\return the currently configured zoom factor, or 0. if the video is set"]
    #[doc = " to fit to the output window/drawable automatically."]
    pub fn libvlc_video_get_scale(p_mi: *mut libvlc_media_player_t) -> f32;
}
extern "C" {
    #[doc = " Set the video scaling factor. That is the ratio of the number of pixels on"]
    #[doc = " screen to the number of pixels in the original decoded video in each"]
    #[doc = " dimension. Zero is a special value; it will adjust the video to the output"]
    #[doc = " window/drawable (in windowed mode) or the entire screen."]
    #[doc = ""]
    #[doc = " Note that not all video outputs support scaling."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param f_factor the scaling factor, or zero"]
    pub fn libvlc_video_set_scale(p_mi: *mut libvlc_media_player_t, f_factor: f32);
}
extern "C" {
    #[doc = " Get current video aspect ratio."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\return the video aspect ratio or NULL if unspecified"]
    #[doc = " (the result must be released with free() or libvlc_free())."]
    pub fn libvlc_video_get_aspect_ratio(p_mi: *mut libvlc_media_player_t) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Set new video aspect ratio."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param psz_aspect new video aspect-ratio or NULL to reset to default"]
    #[doc = " \\note Invalid aspect ratios are ignored."]
    pub fn libvlc_video_set_aspect_ratio(
        p_mi: *mut libvlc_media_player_t,
        psz_aspect: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " Create a video viewpoint structure."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later"]
    #[doc = ""]
    #[doc = " \\return video viewpoint or NULL"]
    #[doc = "         (the result must be released with free())."]
    pub fn libvlc_video_new_viewpoint() -> *mut libvlc_video_viewpoint_t;
}
extern "C" {
    #[doc = " Update the video viewpoint information."]
    #[doc = ""]
    #[doc = " \\note It is safe to call this function before the media player is started."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later"]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param p_viewpoint video viewpoint allocated via libvlc_video_new_viewpoint()"]
    #[doc = " \\param b_absolute if true replace the old viewpoint with the new one. If"]
    #[doc = " false, increase/decrease it."]
    #[doc = " \\return -1 in case of error, 0 otherwise"]
    #[doc = ""]
    #[doc = " \\note the values are set asynchronously, it will be used by the next frame displayed."]
    pub fn libvlc_video_update_viewpoint(
        p_mi: *mut libvlc_media_player_t,
        p_viewpoint: *const libvlc_video_viewpoint_t,
        b_absolute: bool,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current subtitle delay. Positive values means subtitles are being"]
    #[doc = " displayed later, negative values earlier."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return time (in microseconds) the display of subtitles is being delayed"]
    #[doc = " \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_video_get_spu_delay(p_mi: *mut libvlc_media_player_t) -> i64;
}
extern "C" {
    #[doc = " Get the current subtitle text scale"]
    #[doc = ""]
    #[doc = " The scale factor is expressed as a percentage of the default size, where"]
    #[doc = " 1.0 represents 100 percent."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\version LibVLC 4.0.0 or later"]
    pub fn libvlc_video_get_spu_text_scale(p_mi: *mut libvlc_media_player_t) -> f32;
}
extern "C" {
    #[doc = " Set the subtitle text scale."]
    #[doc = ""]
    #[doc = " The scale factor is expressed as a percentage of the default size, where"]
    #[doc = " 1.0 represents 100 percent."]
    #[doc = ""]
    #[doc = " A value of 0.5 would result in text half the normal size, and a value of 2.0"]
    #[doc = " would result in text twice the normal size."]
    #[doc = ""]
    #[doc = " The minimum acceptable value for the scale factor is 0.1."]
    #[doc = ""]
    #[doc = " The maximum is 5.0 (five times normal size)."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param f_scale scale factor in the range [0.1;5.0] (default: 1.0)"]
    #[doc = " \\version LibVLC 4.0.0 or later"]
    pub fn libvlc_video_set_spu_text_scale(p_mi: *mut libvlc_media_player_t, f_scale: f32);
}
extern "C" {
    #[doc = " Set the subtitle delay. This affects the timing of when the subtitle will"]
    #[doc = " be displayed. Positive values result in subtitles being displayed later,"]
    #[doc = " while negative values will result in subtitles being displayed earlier."]
    #[doc = ""]
    #[doc = " The subtitle delay will be reset to zero each time the media changes."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param i_delay time (in microseconds) the display of subtitles should be delayed"]
    #[doc = " \\return 0 on success, -1 on error"]
    #[doc = " \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_video_set_spu_delay(
        p_mi: *mut libvlc_media_player_t,
        i_delay: i64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the full description of available titles"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param[out] titles address to store an allocated array of title descriptions"]
    #[doc = "             descriptions (must be freed with libvlc_title_descriptions_release()"]
    #[doc = "             by the caller)"]
    #[doc = ""]
    #[doc = " \\return the number of titles (-1 on error)"]
    pub fn libvlc_media_player_get_full_title_descriptions(
        p_mi: *mut libvlc_media_player_t,
        titles: *mut *mut *mut libvlc_title_description_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Release a title description"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later"]
    #[doc = ""]
    #[doc = " \\param p_titles title description array to release"]
    #[doc = " \\param i_count number of title descriptions to release"]
    pub fn libvlc_title_descriptions_release(
        p_titles: *mut *mut libvlc_title_description_t,
        i_count: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Get the full description of available chapters"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param i_chapters_of_title index of the title to query for chapters (uses current title if set to -1)"]
    #[doc = " \\param[out] pp_chapters address to store an allocated array of chapter descriptions"]
    #[doc = "             descriptions (must be freed with libvlc_chapter_descriptions_release()"]
    #[doc = "             by the caller)"]
    #[doc = ""]
    #[doc = " \\return the number of chapters (-1 on error)"]
    pub fn libvlc_media_player_get_full_chapter_descriptions(
        p_mi: *mut libvlc_media_player_t,
        i_chapters_of_title: libc::c_int,
        pp_chapters: *mut *mut *mut libvlc_chapter_description_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Release a chapter description"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later"]
    #[doc = ""]
    #[doc = " \\param p_chapters chapter description array to release"]
    #[doc = " \\param i_count number of chapter descriptions to release"]
    pub fn libvlc_chapter_descriptions_release(
        p_chapters: *mut *mut libvlc_chapter_description_t,
        i_count: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Set/unset the video crop ratio."]
    #[doc = ""]
    #[doc = " This function forces a crop ratio on any and all video tracks rendered by"]
    #[doc = " the media player. If the display aspect ratio of a video does not match the"]
    #[doc = " crop ratio, either the top and bottom, or the left and right of the video"]
    #[doc = " will be cut out to fit the crop ratio."]
    #[doc = ""]
    #[doc = " For instance, a ratio of 1:1 will force the video to a square shape."]
    #[doc = ""]
    #[doc = " To disable video crop, set a crop ratio with zero as denominator."]
    #[doc = ""]
    #[doc = " A call to this function overrides any previous call to any of"]
    #[doc = " libvlc_video_set_crop_ratio(), libvlc_video_set_crop_border() and/or"]
    #[doc = " libvlc_video_set_crop_window()."]
    #[doc = ""]
    #[doc = " \\see libvlc_video_set_aspect_ratio()"]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param num crop ratio numerator (ignored if denominator is 0)"]
    #[doc = " \\param den crop ratio denominator (or 0 to unset the crop ratio)"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later"]
    pub fn libvlc_video_set_crop_ratio(
        mp: *mut libvlc_media_player_t,
        num: libc::c_uint,
        den: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Set the video crop window."]
    #[doc = ""]
    #[doc = " This function selects a sub-rectangle of video to show. Any pixels outside"]
    #[doc = " the rectangle will not be shown."]
    #[doc = ""]
    #[doc = " To unset the video crop window, use libvlc_video_set_crop_ratio() or"]
    #[doc = " libvlc_video_set_crop_border()."]
    #[doc = ""]
    #[doc = " A call to this function overrides any previous call to any of"]
    #[doc = " libvlc_video_set_crop_ratio(), libvlc_video_set_crop_border() and/or"]
    #[doc = " libvlc_video_set_crop_window()."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param x abscissa (i.e. leftmost sample column offset) of the crop window"]
    #[doc = " \\param y ordinate (i.e. topmost sample row offset) of the crop window"]
    #[doc = " \\param width sample width of the crop window (cannot be zero)"]
    #[doc = " \\param height sample height of the crop window (cannot be zero)"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later"]
    pub fn libvlc_video_set_crop_window(
        mp: *mut libvlc_media_player_t,
        x: libc::c_uint,
        y: libc::c_uint,
        width: libc::c_uint,
        height: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Set the video crop borders."]
    #[doc = ""]
    #[doc = " This function selects the size of video edges to be cropped out."]
    #[doc = ""]
    #[doc = " To unset the video crop borders, set all borders to zero."]
    #[doc = ""]
    #[doc = " A call to this function overrides any previous call to any of"]
    #[doc = " libvlc_video_set_crop_ratio(), libvlc_video_set_crop_border() and/or"]
    #[doc = " libvlc_video_set_crop_window()."]
    #[doc = ""]
    #[doc = " \\param mp the media player"]
    #[doc = " \\param left number of sample columns to crop on the left"]
    #[doc = " \\param right number of sample columns to crop on the right"]
    #[doc = " \\param top number of sample rows to crop on the top"]
    #[doc = " \\param bottom number of sample rows to corp on the bottom"]
    #[doc = ""]
    #[doc = " \\version LibVLC 4.0.0 and later"]
    pub fn libvlc_video_set_crop_border(
        mp: *mut libvlc_media_player_t,
        left: libc::c_uint,
        right: libc::c_uint,
        top: libc::c_uint,
        bottom: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Get current teletext page requested or 0 if it's disabled."]
    #[doc = ""]
    #[doc = " Teletext is disabled by default, call libvlc_video_set_teletext() to enable"]
    #[doc = " it."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\return the current teletext page requested."]
    pub fn libvlc_video_get_teletext(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Set new teletext page to retrieve."]
    #[doc = ""]
    #[doc = " This function can also be used to send a teletext key."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param i_page teletex page number requested. This value can be 0 to disable"]
    #[doc = " teletext, a number in the range ]0;1000[ to show the requested page, or a"]
    #[doc = " \\ref libvlc_teletext_key_t. 100 is the default teletext page."]
    pub fn libvlc_video_set_teletext(p_mi: *mut libvlc_media_player_t, i_page: libc::c_int);
}
extern "C" {
    #[doc = " Take a snapshot of the current video window."]
    #[doc = ""]
    #[doc = " If i_width AND i_height is 0, original size is used."]
    #[doc = " If i_width XOR i_height is 0, original aspect-ratio is preserved."]
    #[doc = ""]
    #[doc = " \\param p_mi media player instance"]
    #[doc = " \\param num number of video output (typically 0 for the first/only one)"]
    #[doc = " \\param psz_filepath the path of a file or a folder to save the screenshot into"]
    #[doc = " \\param i_width the snapshot's width"]
    #[doc = " \\param i_height the snapshot's height"]
    #[doc = " \\return 0 on success, -1 if the video was not found"]
    pub fn libvlc_video_take_snapshot(
        p_mi: *mut libvlc_media_player_t,
        num: libc::c_uint,
        psz_filepath: *const libc::c_char,
        i_width: libc::c_uint,
        i_height: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Enable or disable deinterlace filter"]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player"]
    #[doc = " \\param deinterlace state -1: auto (default), 0: disabled, 1: enabled"]
    #[doc = " \\param psz_mode type of deinterlace filter, NULL for current/default filter"]
    #[doc = " \\version LibVLC 4.0.0 and later"]
    pub fn libvlc_video_set_deinterlace(
        p_mi: *mut libvlc_media_player_t,
        deinterlace: libc::c_int,
        psz_mode: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " Get an integer marquee option value"]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player"]
    #[doc = " \\param option marq option to get \\see libvlc_video_marquee_option_t"]
    pub fn libvlc_video_get_marquee_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Enable, disable or set an integer marquee option"]
    #[doc = ""]
    #[doc = " Setting libvlc_marquee_Enable has the side effect of enabling (arg !0)"]
    #[doc = " or disabling (arg 0) the marq filter."]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player"]
    #[doc = " \\param option marq option to set \\see libvlc_video_marquee_option_t"]
    #[doc = " \\param i_val marq option value"]
    pub fn libvlc_video_set_marquee_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        i_val: libc::c_int,
    );
}
extern "C" {
    #[doc = " Set a marquee string option"]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player"]
    #[doc = " \\param option marq option to set \\see libvlc_video_marquee_option_t"]
    #[doc = " \\param psz_text marq option value"]
    pub fn libvlc_video_set_marquee_string(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        psz_text: *const libc::c_char,
    );
}
pub const libvlc_video_logo_option_t_libvlc_logo_enable: libvlc_video_logo_option_t = 0;
#[doc = "< string argument, \"file,d,t;file,d,t;...\""]
pub const libvlc_video_logo_option_t_libvlc_logo_file: libvlc_video_logo_option_t = 1;
pub const libvlc_video_logo_option_t_libvlc_logo_x: libvlc_video_logo_option_t = 2;
pub const libvlc_video_logo_option_t_libvlc_logo_y: libvlc_video_logo_option_t = 3;
pub const libvlc_video_logo_option_t_libvlc_logo_delay: libvlc_video_logo_option_t = 4;
pub const libvlc_video_logo_option_t_libvlc_logo_repeat: libvlc_video_logo_option_t = 5;
pub const libvlc_video_logo_option_t_libvlc_logo_opacity: libvlc_video_logo_option_t = 6;
pub const libvlc_video_logo_option_t_libvlc_logo_position: libvlc_video_logo_option_t = 7;
#[doc = " option values for libvlc_video_{get,set}_logo_{int,string}"]
pub type libvlc_video_logo_option_t = libc::c_uint;
extern "C" {
    #[doc = " Get integer logo option."]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player instance"]
    #[doc = " \\param option logo option to get, values of libvlc_video_logo_option_t"]
    pub fn libvlc_video_get_logo_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set logo option as integer. Options that take a different type value"]
    #[doc = " are ignored."]
    #[doc = " Passing libvlc_logo_enable as option value has the side effect of"]
    #[doc = " starting (arg !0) or stopping (arg 0) the logo filter."]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player instance"]
    #[doc = " \\param option logo option to set, values of libvlc_video_logo_option_t"]
    #[doc = " \\param value logo option value"]
    pub fn libvlc_video_set_logo_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        value: libc::c_int,
    );
}
extern "C" {
    #[doc = " Set logo option as string. Options that take a different type value"]
    #[doc = " are ignored."]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player instance"]
    #[doc = " \\param option logo option to set, values of libvlc_video_logo_option_t"]
    #[doc = " \\param psz_value logo option value"]
    pub fn libvlc_video_set_logo_string(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        psz_value: *const libc::c_char,
    );
}
pub const libvlc_video_adjust_option_t_libvlc_adjust_Enable: libvlc_video_adjust_option_t = 0;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Contrast: libvlc_video_adjust_option_t = 1;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Brightness: libvlc_video_adjust_option_t = 2;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Hue: libvlc_video_adjust_option_t = 3;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Saturation: libvlc_video_adjust_option_t = 4;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Gamma: libvlc_video_adjust_option_t = 5;
#[doc = " option values for libvlc_video_{get,set}_adjust_{int,float,bool}"]
pub type libvlc_video_adjust_option_t = libc::c_uint;
extern "C" {
    #[doc = " Get integer adjust option."]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player instance"]
    #[doc = " \\param option adjust option to get, values of libvlc_video_adjust_option_t"]
    #[doc = " \\version LibVLC 1.1.1 and later."]
    pub fn libvlc_video_get_adjust_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set adjust option as integer. Options that take a different type value"]
    #[doc = " are ignored."]
    #[doc = " Passing libvlc_adjust_enable as option value has the side effect of"]
    #[doc = " starting (arg !0) or stopping (arg 0) the adjust filter."]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player instance"]
    #[doc = " \\param option adust option to set, values of libvlc_video_adjust_option_t"]
    #[doc = " \\param value adjust option value"]
    #[doc = " \\version LibVLC 1.1.1 and later."]
    pub fn libvlc_video_set_adjust_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        value: libc::c_int,
    );
}
extern "C" {
    #[doc = " Get float adjust option."]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player instance"]
    #[doc = " \\param option adjust option to get, values of libvlc_video_adjust_option_t"]
    #[doc = " \\version LibVLC 1.1.1 and later."]
    pub fn libvlc_video_get_adjust_float(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> f32;
}
extern "C" {
    #[doc = " Set adjust option as float. Options that take a different type value"]
    #[doc = " are ignored."]
    #[doc = ""]
    #[doc = " \\param p_mi libvlc media player instance"]
    #[doc = " \\param option adust option to set, values of libvlc_video_adjust_option_t"]
    #[doc = " \\param value adjust option value"]
    #[doc = " \\version LibVLC 1.1.1 and later."]
    pub fn libvlc_video_set_adjust_float(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        value: f32,
    );
}
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Error: libvlc_audio_output_channel_t =
    -1;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Stereo: libvlc_audio_output_channel_t =
    1;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_RStereo: libvlc_audio_output_channel_t =
    2;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Left: libvlc_audio_output_channel_t = 3;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Right: libvlc_audio_output_channel_t =
    4;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Dolbys: libvlc_audio_output_channel_t =
    5;
#[doc = " Audio channels"]
pub type libvlc_audio_output_channel_t = libc::c_int;
extern "C" {
    #[doc = " Gets the list of available audio output modules."]
    #[doc = ""]
    #[doc = " \\param p_instance libvlc instance"]
    #[doc = " \\return list of available audio outputs. It must be freed with"]
    #[doc = "          \\see libvlc_audio_output_list_release \\see libvlc_audio_output_t ."]
    #[doc = "         In case of error, NULL is returned."]
    pub fn libvlc_audio_output_list_get(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_audio_output_t;
}
extern "C" {
    #[doc = " Frees the list of available audio output modules."]
    #[doc = ""]
    #[doc = " \\param p_list list with audio outputs for release"]
    pub fn libvlc_audio_output_list_release(p_list: *mut libvlc_audio_output_t);
}
extern "C" {
    #[doc = " Selects an audio output module."]
    #[doc = " \\note Any change will take be effect only after playback is stopped and"]
    #[doc = " restarted. Audio output cannot be changed while playing."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param psz_name name of audio output,"]
    #[doc = "               use psz_name of \\see libvlc_audio_output_t"]
    #[doc = " \\return 0 if function succeeded, -1 on error"]
    pub fn libvlc_audio_output_set(
        p_mi: *mut libvlc_media_player_t,
        psz_name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Gets a list of potential audio output devices."]
    #[doc = ""]
    #[doc = " See also libvlc_audio_output_device_set()."]
    #[doc = ""]
    #[doc = " \\note Not all audio outputs support enumerating devices."]
    #[doc = " The audio output may be functional even if the list is empty (NULL)."]
    #[doc = ""]
    #[doc = " \\note The list may not be exhaustive."]
    #[doc = ""]
    #[doc = " \\warning Some audio output devices in the list might not actually work in"]
    #[doc = " some circumstances. By default, it is recommended to not specify any"]
    #[doc = " explicit audio device."]
    #[doc = ""]
    #[doc = " \\param mp media player"]
    #[doc = " \\return A NULL-terminated linked list of potential audio output devices."]
    #[doc = " It must be freed with libvlc_audio_output_device_list_release()"]
    #[doc = " \\version LibVLC 2.2.0 or later."]
    pub fn libvlc_audio_output_device_enum(
        mp: *mut libvlc_media_player_t,
    ) -> *mut libvlc_audio_output_device_t;
}
extern "C" {
    #[doc = " Frees a list of available audio output devices."]
    #[doc = ""]
    #[doc = " \\param p_list list with audio outputs for release"]
    #[doc = " \\version LibVLC 2.1.0 or later."]
    pub fn libvlc_audio_output_device_list_release(p_list: *mut libvlc_audio_output_device_t);
}
extern "C" {
    #[doc = " Configures an explicit audio output device."]
    #[doc = ""]
    #[doc = " A list of adequate potential device strings can be obtained with"]
    #[doc = " libvlc_audio_output_device_enum()."]
    #[doc = ""]
    #[doc = " \\note This function does not select the specified audio output plugin."]
    #[doc = " libvlc_audio_output_set() is used for that purpose."]
    #[doc = ""]
    #[doc = " \\warning The syntax for the device parameter depends on the audio output."]
    #[doc = ""]
    #[doc = " Some audio output modules require further parameters (e.g. a channels map"]
    #[doc = " in the case of ALSA)."]
    #[doc = ""]
    #[doc = " \\version This function originally expected three parameters."]
    #[doc = " The middle parameter was removed from LibVLC 4.0 onward."]
    #[doc = ""]
    #[doc = " \\param mp media player"]
    #[doc = " \\param device_id device identifier string"]
    #[doc = "               (see \\ref libvlc_audio_output_device_t::psz_device)"]
    #[doc = ""]
    #[doc = " \\return If the change of device was requested succesfully, zero is returned"]
    #[doc = " (the actual change is asynchronous and not guaranteed to succeed)."]
    #[doc = " On error, a non-zero value is returned."]
    pub fn libvlc_audio_output_device_set(
        mp: *mut libvlc_media_player_t,
        device_id: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current audio output device identifier."]
    #[doc = ""]
    #[doc = " This complements libvlc_audio_output_device_set()."]
    #[doc = ""]
    #[doc = " \\warning The initial value for the current audio output device identifier"]
    #[doc = " may not be set or may be some unknown value. A LibVLC application should"]
    #[doc = " compare this value against the known device identifiers (e.g. those that"]
    #[doc = " were previously retrieved by a call to libvlc_audio_output_device_enum) to"]
    #[doc = " find the current audio output device."]
    #[doc = ""]
    #[doc = " It is possible that the selected audio output device changes (an external"]
    #[doc = " change) without a call to libvlc_audio_output_device_set. That may make this"]
    #[doc = " method unsuitable to use if a LibVLC application is attempting to track"]
    #[doc = " dynamic audio device changes as they happen."]
    #[doc = ""]
    #[doc = " \\param mp media player"]
    #[doc = " \\return the current audio output device identifier"]
    #[doc = "         NULL if no device is selected or in case of error"]
    #[doc = "         (the result must be released with free())."]
    #[doc = " \\version LibVLC 3.0.0 or later."]
    pub fn libvlc_audio_output_device_get(mp: *mut libvlc_media_player_t) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Toggle mute status."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\warning Toggling mute atomically is not always possible: On some platforms,"]
    #[doc = " other processes can mute the VLC audio playback stream asynchronously. Thus,"]
    #[doc = " there is a small race condition where toggling will not work."]
    #[doc = " See also the limitations of libvlc_audio_set_mute()."]
    pub fn libvlc_audio_toggle_mute(p_mi: *mut libvlc_media_player_t);
}
extern "C" {
    #[doc = " Get current mute status."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the mute status (boolean) if defined, -1 if undefined/unapplicable"]
    pub fn libvlc_audio_get_mute(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Set mute status."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param status If status is true then mute, otherwise unmute"]
    #[doc = " \\warning This function does not always work. If there are no active audio"]
    #[doc = " playback stream, the mute status might not be available. If digital"]
    #[doc = " pass-through (S/PDIF, HDMI...) is in use, muting may be unapplicable. Also"]
    #[doc = " some audio output plugins do not support muting at all."]
    #[doc = " \\note To force silent playback, disable all audio tracks. This is more"]
    #[doc = " efficient and reliable than mute."]
    pub fn libvlc_audio_set_mute(p_mi: *mut libvlc_media_player_t, status: libc::c_int);
}
extern "C" {
    #[doc = " Get current software audio volume."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the software volume in percents"]
    #[doc = " (0 = mute, 100 = nominal / 0dB)"]
    pub fn libvlc_audio_get_volume(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Set current software audio volume."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param i_volume the volume in percents (0 = mute, 100 = 0dB)"]
    #[doc = " \\return 0 if the volume was set, -1 if it was out of range"]
    pub fn libvlc_audio_set_volume(
        p_mi: *mut libvlc_media_player_t,
        i_volume: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get current audio channel."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the audio channel \\see libvlc_audio_output_channel_t"]
    pub fn libvlc_audio_get_channel(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Set current audio channel."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param channel the audio channel, \\see libvlc_audio_output_channel_t"]
    #[doc = " \\return 0 on success, -1 on error"]
    pub fn libvlc_audio_set_channel(
        p_mi: *mut libvlc_media_player_t,
        channel: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get current audio delay."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the audio delay (microseconds)"]
    #[doc = " \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_audio_get_delay(p_mi: *mut libvlc_media_player_t) -> i64;
}
extern "C" {
    #[doc = " Set current audio delay. The audio delay will be reset to zero each time the media changes."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param i_delay the audio delay (microseconds)"]
    #[doc = " \\return 0 on success, -1 on error"]
    #[doc = " \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_audio_set_delay(p_mi: *mut libvlc_media_player_t, i_delay: i64) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of equalizer presets."]
    #[doc = ""]
    #[doc = " \\return number of presets"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_preset_count() -> libc::c_uint;
}
extern "C" {
    #[doc = " Get the name of a particular equalizer preset."]
    #[doc = ""]
    #[doc = " This name can be used, for example, to prepare a preset label or menu in a user"]
    #[doc = " interface."]
    #[doc = ""]
    #[doc = " \\param u_index index of the preset, counting from zero"]
    #[doc = " \\return preset name, or NULL if there is no such preset"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_preset_name(u_index: libc::c_uint) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the number of distinct frequency bands for an equalizer."]
    #[doc = ""]
    #[doc = " \\return number of frequency bands"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_band_count() -> libc::c_uint;
}
extern "C" {
    #[doc = " Get a particular equalizer band frequency."]
    #[doc = ""]
    #[doc = " This value can be used, for example, to create a label for an equalizer band control"]
    #[doc = " in a user interface."]
    #[doc = ""]
    #[doc = " \\param u_index index of the band, counting from zero"]
    #[doc = " \\return equalizer band frequency (Hz), or -1 if there is no such band"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_band_frequency(u_index: libc::c_uint) -> f32;
}
extern "C" {
    #[doc = " Create a new default equalizer, with all frequency values zeroed."]
    #[doc = ""]
    #[doc = " The new equalizer can subsequently be applied to a media player by invoking"]
    #[doc = " libvlc_media_player_set_equalizer()."]
    #[doc = ""]
    #[doc = " The returned handle should be freed via libvlc_audio_equalizer_release() when"]
    #[doc = " it is no longer needed."]
    #[doc = ""]
    #[doc = " \\return opaque equalizer handle, or NULL on error"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_new() -> *mut libvlc_equalizer_t;
}
extern "C" {
    #[doc = " Create a new equalizer, with initial frequency values copied from an existing"]
    #[doc = " preset."]
    #[doc = ""]
    #[doc = " The new equalizer can subsequently be applied to a media player by invoking"]
    #[doc = " libvlc_media_player_set_equalizer()."]
    #[doc = ""]
    #[doc = " The returned handle should be freed via libvlc_audio_equalizer_release() when"]
    #[doc = " it is no longer needed."]
    #[doc = ""]
    #[doc = " \\param u_index index of the preset, counting from zero"]
    #[doc = " \\return opaque equalizer handle, or NULL on error"]
    #[doc = "         (it must be released with libvlc_audio_equalizer_release())"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_new_from_preset(u_index: libc::c_uint)
        -> *mut libvlc_equalizer_t;
}
extern "C" {
    #[doc = " Release a previously created equalizer instance."]
    #[doc = ""]
    #[doc = " The equalizer was previously created by using libvlc_audio_equalizer_new() or"]
    #[doc = " libvlc_audio_equalizer_new_from_preset()."]
    #[doc = ""]
    #[doc = " It is safe to invoke this method with a NULL p_equalizer parameter for no effect."]
    #[doc = ""]
    #[doc = " \\param p_equalizer opaque equalizer handle, or NULL"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_release(p_equalizer: *mut libvlc_equalizer_t);
}
extern "C" {
    #[doc = " Set a new pre-amplification value for an equalizer."]
    #[doc = ""]
    #[doc = " The new equalizer settings are subsequently applied to a media player by invoking"]
    #[doc = " libvlc_media_player_set_equalizer()."]
    #[doc = ""]
    #[doc = " The supplied amplification value will be clamped to the -20.0 to +20.0 range."]
    #[doc = ""]
    #[doc = " \\param p_equalizer valid equalizer handle, must not be NULL"]
    #[doc = " \\param f_preamp preamp value (-20.0 to 20.0 Hz)"]
    #[doc = " \\return zero on success, -1 on error"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_set_preamp(
        p_equalizer: *mut libvlc_equalizer_t,
        f_preamp: f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current pre-amplification value from an equalizer."]
    #[doc = ""]
    #[doc = " \\param p_equalizer valid equalizer handle, must not be NULL"]
    #[doc = " \\return preamp value (Hz)"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_preamp(p_equalizer: *mut libvlc_equalizer_t) -> f32;
}
extern "C" {
    #[doc = " Set a new amplification value for a particular equalizer frequency band."]
    #[doc = ""]
    #[doc = " The new equalizer settings are subsequently applied to a media player by invoking"]
    #[doc = " libvlc_media_player_set_equalizer()."]
    #[doc = ""]
    #[doc = " The supplied amplification value will be clamped to the -20.0 to +20.0 range."]
    #[doc = ""]
    #[doc = " \\param p_equalizer valid equalizer handle, must not be NULL"]
    #[doc = " \\param f_amp amplification value (-20.0 to 20.0 Hz)"]
    #[doc = " \\param u_band index, counting from zero, of the frequency band to set"]
    #[doc = " \\return zero on success, -1 on error"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_set_amp_at_index(
        p_equalizer: *mut libvlc_equalizer_t,
        f_amp: f32,
        u_band: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the amplification value for a particular equalizer frequency band."]
    #[doc = ""]
    #[doc = " \\param p_equalizer valid equalizer handle, must not be NULL"]
    #[doc = " \\param u_band index, counting from zero, of the frequency band to get"]
    #[doc = " \\return amplification value (Hz); NaN if there is no such frequency band"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_amp_at_index(
        p_equalizer: *mut libvlc_equalizer_t,
        u_band: libc::c_uint,
    ) -> f32;
}
extern "C" {
    #[doc = " Apply new equalizer settings to a media player."]
    #[doc = ""]
    #[doc = " The equalizer is first created by invoking libvlc_audio_equalizer_new() or"]
    #[doc = " libvlc_audio_equalizer_new_from_preset()."]
    #[doc = ""]
    #[doc = " It is possible to apply new equalizer settings to a media player whether the media"]
    #[doc = " player is currently playing media or not."]
    #[doc = ""]
    #[doc = " Invoking this method will immediately apply the new equalizer settings to the audio"]
    #[doc = " output of the currently playing media if there is any."]
    #[doc = ""]
    #[doc = " If there is no currently playing media, the new equalizer settings will be applied"]
    #[doc = " later if and when new media is played."]
    #[doc = ""]
    #[doc = " Equalizer settings will automatically be applied to subsequently played media."]
    #[doc = ""]
    #[doc = " To disable the equalizer for a media player invoke this method passing NULL for the"]
    #[doc = " p_equalizer parameter."]
    #[doc = ""]
    #[doc = " The media player does not keep a reference to the supplied equalizer so it is safe"]
    #[doc = " for an application to release the equalizer reference any time after this method"]
    #[doc = " returns."]
    #[doc = ""]
    #[doc = " \\param p_mi opaque media player handle"]
    #[doc = " \\param p_equalizer opaque equalizer handle, or NULL to disable the equalizer for this media player"]
    #[doc = " \\return zero on success, -1 on error"]
    #[doc = " \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_media_player_set_equalizer(
        p_mi: *mut libvlc_media_player_t,
        p_equalizer: *mut libvlc_equalizer_t,
    ) -> libc::c_int;
}
#[doc = "< Don't use a media player role"]
pub const libvlc_media_player_role_libvlc_role_None: libvlc_media_player_role = 0;
#[doc = "< Music (or radio) playback"]
pub const libvlc_media_player_role_libvlc_role_Music: libvlc_media_player_role = 1;
#[doc = "< Video playback"]
pub const libvlc_media_player_role_libvlc_role_Video: libvlc_media_player_role = 2;
#[doc = "< Speech, real-time communication"]
pub const libvlc_media_player_role_libvlc_role_Communication: libvlc_media_player_role = 3;
#[doc = "< Video game"]
pub const libvlc_media_player_role_libvlc_role_Game: libvlc_media_player_role = 4;
#[doc = "< User interaction feedback"]
pub const libvlc_media_player_role_libvlc_role_Notification: libvlc_media_player_role = 5;
#[doc = "< Embedded animation (e.g. in web page)"]
pub const libvlc_media_player_role_libvlc_role_Animation: libvlc_media_player_role = 6;
#[doc = "< Audio editing/production"]
pub const libvlc_media_player_role_libvlc_role_Production: libvlc_media_player_role = 7;
#[doc = "< Accessibility"]
pub const libvlc_media_player_role_libvlc_role_Accessibility: libvlc_media_player_role = 8;
pub const libvlc_media_player_role_libvlc_role_Test: libvlc_media_player_role = 9;
#[doc = " Media player roles."]
#[doc = ""]
#[doc = " \\version LibVLC 3.0.0 and later."]
#[doc = ""]
#[doc = " See \\ref libvlc_media_player_set_role()"]
pub type libvlc_media_player_role = libc::c_uint;
#[doc = " Media player roles."]
#[doc = ""]
#[doc = " \\version LibVLC 3.0.0 and later."]
#[doc = ""]
#[doc = " See \\ref libvlc_media_player_set_role()"]
pub use self::libvlc_media_player_role as libvlc_media_player_role_t;
extern "C" {
    #[doc = " Gets the media role."]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the media player role (\\ref libvlc_media_player_role_t)"]
    pub fn libvlc_media_player_get_role(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Sets the media role."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param role the media player role (\\ref libvlc_media_player_role_t)"]
    #[doc = " \\return 0 on success, -1 on error"]
    pub fn libvlc_media_player_set_role(
        p_mi: *mut libvlc_media_player_t,
        role: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create an empty media list."]
    #[doc = ""]
    #[doc = " \\return empty media list, or NULL on error"]
    pub fn libvlc_media_list_new() -> *mut libvlc_media_list_t;
}
extern "C" {
    #[doc = " Release media list created with libvlc_media_list_new()."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list created with libvlc_media_list_new()"]
    pub fn libvlc_media_list_release(p_ml: *mut libvlc_media_list_t);
}
extern "C" {
    #[doc = " Retain reference to a media list"]
    #[doc = ""]
    #[doc = " \\param p_ml a media list created with libvlc_media_list_new()"]
    pub fn libvlc_media_list_retain(p_ml: *mut libvlc_media_list_t);
}
extern "C" {
    #[doc = " Associate media instance with this media list instance."]
    #[doc = " If another media instance was present it will be released."]
    #[doc = " The libvlc_media_list_lock should NOT be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\param p_md media instance to add"]
    pub fn libvlc_media_list_set_media(p_ml: *mut libvlc_media_list_t, p_md: *mut libvlc_media_t);
}
extern "C" {
    #[doc = " Get media instance from this media list instance. This action will increase"]
    #[doc = " the refcount on the media instance."]
    #[doc = " The libvlc_media_list_lock should NOT be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\return media instance"]
    pub fn libvlc_media_list_media(p_ml: *mut libvlc_media_list_t) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Add media instance to media list"]
    #[doc = " The libvlc_media_list_lock should be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\param p_md a media instance"]
    #[doc = " \\return 0 on success, -1 if the media list is read-only"]
    pub fn libvlc_media_list_add_media(
        p_ml: *mut libvlc_media_list_t,
        p_md: *mut libvlc_media_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Insert media instance in media list on a position"]
    #[doc = " The libvlc_media_list_lock should be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\param p_md a media instance"]
    #[doc = " \\param i_pos position in array where to insert"]
    #[doc = " \\return 0 on success, -1 if the media list is read-only"]
    pub fn libvlc_media_list_insert_media(
        p_ml: *mut libvlc_media_list_t,
        p_md: *mut libvlc_media_t,
        i_pos: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Remove media instance from media list on a position"]
    #[doc = " The libvlc_media_list_lock should be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\param i_pos position in array where to insert"]
    #[doc = " \\return 0 on success, -1 if the list is read-only or the item was not found"]
    pub fn libvlc_media_list_remove_index(
        p_ml: *mut libvlc_media_list_t,
        i_pos: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get count on media list items"]
    #[doc = " The libvlc_media_list_lock should be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\return number of items in media list"]
    pub fn libvlc_media_list_count(p_ml: *mut libvlc_media_list_t) -> libc::c_int;
}
extern "C" {
    #[doc = " List media instance in media list at a position"]
    #[doc = " The libvlc_media_list_lock should be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\param i_pos position in array where to insert"]
    #[doc = " \\return media instance at position i_pos, or NULL if not found."]
    #[doc = " In case of success, libvlc_media_retain() is called to increase the refcount"]
    #[doc = " on the media."]
    pub fn libvlc_media_list_item_at_index(
        p_ml: *mut libvlc_media_list_t,
        i_pos: libc::c_int,
    ) -> *mut libvlc_media_t;
}
extern "C" {
    #[doc = " Find index position of List media instance in media list."]
    #[doc = " Warning: the function will return the first matched position."]
    #[doc = " The libvlc_media_list_lock should be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\param p_md media instance"]
    #[doc = " \\return position of media instance or -1 if media not found"]
    pub fn libvlc_media_list_index_of_item(
        p_ml: *mut libvlc_media_list_t,
        p_md: *mut libvlc_media_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " This indicates if this media list is read-only from a user point of view"]
    #[doc = ""]
    #[doc = " \\param p_ml media list instance"]
    #[doc = " \\retval true read-only"]
    #[doc = " \\retval false read/write"]
    pub fn libvlc_media_list_is_readonly(p_ml: *mut libvlc_media_list_t) -> bool;
}
extern "C" {
    #[doc = " Get lock on media list items"]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    pub fn libvlc_media_list_lock(p_ml: *mut libvlc_media_list_t);
}
extern "C" {
    #[doc = " Release lock on media list items"]
    #[doc = " The libvlc_media_list_lock should be held upon entering this function."]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    pub fn libvlc_media_list_unlock(p_ml: *mut libvlc_media_list_t);
}
extern "C" {
    #[doc = " Get libvlc_event_manager from this media list instance."]
    #[doc = " The p_event_manager is immutable, so you don't have to hold the lock"]
    #[doc = ""]
    #[doc = " \\param p_ml a media list instance"]
    #[doc = " \\return libvlc_event_manager"]
    pub fn libvlc_media_list_event_manager(
        p_ml: *mut libvlc_media_list_t,
    ) -> *mut libvlc_event_manager_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_list_player_t {
    _unused: [u8; 0],
}
pub const libvlc_playback_mode_t_libvlc_playback_mode_default: libvlc_playback_mode_t = 0;
pub const libvlc_playback_mode_t_libvlc_playback_mode_loop: libvlc_playback_mode_t = 1;
pub const libvlc_playback_mode_t_libvlc_playback_mode_repeat: libvlc_playback_mode_t = 2;
#[doc = "  Defines playback modes for playlist."]
pub type libvlc_playback_mode_t = libc::c_uint;
extern "C" {
    #[doc = " Create new media_list_player."]
    #[doc = ""]
    #[doc = " \\param p_instance libvlc instance"]
    #[doc = " \\return media list player instance or NULL on error"]
    #[doc = "         (it must be released by libvlc_media_list_player_release())"]
    pub fn libvlc_media_list_player_new(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_media_list_player_t;
}
extern "C" {
    #[doc = " Release a media_list_player after use"]
    #[doc = " Decrement the reference count of a media player object. If the"]
    #[doc = " reference count is 0, then libvlc_media_list_player_release() will"]
    #[doc = " release the media player object. If the media player object"]
    #[doc = " has been released, then it should not be used again."]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    pub fn libvlc_media_list_player_release(p_mlp: *mut libvlc_media_list_player_t);
}
extern "C" {
    #[doc = " Retain a reference to a media player list object. Use"]
    #[doc = " libvlc_media_list_player_release() to decrement reference count."]
    #[doc = ""]
    #[doc = " \\param p_mlp media player list object"]
    pub fn libvlc_media_list_player_retain(p_mlp: *mut libvlc_media_list_player_t);
}
extern "C" {
    #[doc = " Return the event manager of this media_list_player."]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\return the event manager"]
    pub fn libvlc_media_list_player_event_manager(
        p_mlp: *mut libvlc_media_list_player_t,
    ) -> *mut libvlc_event_manager_t;
}
extern "C" {
    #[doc = " Replace media player in media_list_player with this instance."]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\param p_mi media player instance"]
    pub fn libvlc_media_list_player_set_media_player(
        p_mlp: *mut libvlc_media_list_player_t,
        p_mi: *mut libvlc_media_player_t,
    );
}
extern "C" {
    #[doc = " Get media player of the media_list_player instance."]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\return media player instance"]
    #[doc = " \\note the caller is responsible for releasing the returned instance"]
    #[doc = "with libvlc_media_list_player_set_media_player()."]
    pub fn libvlc_media_list_player_get_media_player(
        p_mlp: *mut libvlc_media_list_player_t,
    ) -> *mut libvlc_media_player_t;
}
extern "C" {
    #[doc = " Set the media list associated with the player"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\param p_mlist list of media"]
    pub fn libvlc_media_list_player_set_media_list(
        p_mlp: *mut libvlc_media_list_player_t,
        p_mlist: *mut libvlc_media_list_t,
    );
}
extern "C" {
    #[doc = " Play media list"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    pub fn libvlc_media_list_player_play(p_mlp: *mut libvlc_media_list_player_t);
}
extern "C" {
    #[doc = " Toggle pause (or resume) media list"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    pub fn libvlc_media_list_player_pause(p_mlp: *mut libvlc_media_list_player_t);
}
extern "C" {
    #[doc = " Pause or resume media list"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\param do_pause play/resume if zero, pause if non-zero"]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_list_player_set_pause(
        p_mlp: *mut libvlc_media_list_player_t,
        do_pause: libc::c_int,
    );
}
extern "C" {
    #[doc = " Is media list playing?"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = ""]
    #[doc = " \\retval true playing"]
    #[doc = " \\retval false not playing"]
    pub fn libvlc_media_list_player_is_playing(p_mlp: *mut libvlc_media_list_player_t) -> bool;
}
extern "C" {
    #[doc = " Get current libvlc_state of media list player"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\return libvlc_state_t for media list player"]
    pub fn libvlc_media_list_player_get_state(
        p_mlp: *mut libvlc_media_list_player_t,
    ) -> libvlc_state_t;
}
extern "C" {
    #[doc = " Play media list item at position index"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\param i_index index in media list to play"]
    #[doc = " \\return 0 upon success -1 if the item wasn't found"]
    pub fn libvlc_media_list_player_play_item_at_index(
        p_mlp: *mut libvlc_media_list_player_t,
        i_index: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Play the given media item"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\param p_md the media instance"]
    #[doc = " \\return 0 upon success, -1 if the media is not part of the media list"]
    pub fn libvlc_media_list_player_play_item(
        p_mlp: *mut libvlc_media_list_player_t,
        p_md: *mut libvlc_media_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop playing media list"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    pub fn libvlc_media_list_player_stop_async(p_mlp: *mut libvlc_media_list_player_t);
}
extern "C" {
    #[doc = " Play next item from media list"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\return 0 upon success -1 if there is no next item"]
    pub fn libvlc_media_list_player_next(p_mlp: *mut libvlc_media_list_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Play previous item from media list"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\return 0 upon success -1 if there is no previous item"]
    pub fn libvlc_media_list_player_previous(p_mlp: *mut libvlc_media_list_player_t)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Sets the playback mode for the playlist"]
    #[doc = ""]
    #[doc = " \\param p_mlp media list player instance"]
    #[doc = " \\param e_mode playback mode specification"]
    pub fn libvlc_media_list_player_set_playback_mode(
        p_mlp: *mut libvlc_media_list_player_t,
        e_mode: libvlc_playback_mode_t,
    );
}
#[doc = " devices, like portable music player"]
pub const libvlc_media_discoverer_category_t_libvlc_media_discoverer_devices:
    libvlc_media_discoverer_category_t = 0;
#[doc = " LAN/WAN services, like Upnp, SMB, or SAP"]
pub const libvlc_media_discoverer_category_t_libvlc_media_discoverer_lan:
    libvlc_media_discoverer_category_t = 1;
#[doc = " Podcasts"]
pub const libvlc_media_discoverer_category_t_libvlc_media_discoverer_podcasts:
    libvlc_media_discoverer_category_t = 2;
#[doc = " Local directories, like Video, Music or Pictures directories"]
pub const libvlc_media_discoverer_category_t_libvlc_media_discoverer_localdirs:
    libvlc_media_discoverer_category_t = 3;
#[doc = " Category of a media discoverer"]
#[doc = " \\see libvlc_media_discoverer_list_get()"]
pub type libvlc_media_discoverer_category_t = libc::c_uint;
#[doc = " Media discoverer description"]
#[doc = " \\see libvlc_media_discoverer_list_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_discoverer_description_t {
    pub psz_name: *mut libc::c_char,
    pub psz_longname: *mut libc::c_char,
    pub i_cat: libvlc_media_discoverer_category_t,
}
#[test]
fn bindgen_test_layout_libvlc_media_discoverer_description_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_media_discoverer_description_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_media_discoverer_description_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_media_discoverer_description_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_media_discoverer_description_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_discoverer_description_t>())).psz_name as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_discoverer_description_t),
            "::",
            stringify!(psz_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_discoverer_description_t>())).psz_longname
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_discoverer_description_t),
            "::",
            stringify!(psz_longname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_media_discoverer_description_t>())).i_cat as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_media_discoverer_description_t),
            "::",
            stringify!(i_cat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_discoverer_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a media discoverer object by name."]
    #[doc = ""]
    #[doc = " After this object is created, you should attach to media_list events in"]
    #[doc = " order to be notified of new items discovered."]
    #[doc = ""]
    #[doc = " You need to call libvlc_media_discoverer_start() in order to start the"]
    #[doc = " discovery."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_discoverer_media_list"]
    #[doc = " \\see libvlc_media_discoverer_start"]
    #[doc = ""]
    #[doc = " \\param p_inst libvlc instance"]
    #[doc = " \\param psz_name service name; use libvlc_media_discoverer_list_get() to get"]
    #[doc = " a list of the discoverer names available in this libVLC instance"]
    #[doc = " \\return media discover object or NULL in case of error"]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_discoverer_new(
        p_inst: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> *mut libvlc_media_discoverer_t;
}
extern "C" {
    #[doc = " Start media discovery."]
    #[doc = ""]
    #[doc = " To stop it, call libvlc_media_discoverer_stop() or"]
    #[doc = " libvlc_media_discoverer_list_release() directly."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_discoverer_stop"]
    #[doc = ""]
    #[doc = " \\param p_mdis media discover object"]
    #[doc = " \\return -1 in case of error, 0 otherwise"]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_discoverer_start(p_mdis: *mut libvlc_media_discoverer_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop media discovery."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_discoverer_start"]
    #[doc = ""]
    #[doc = " \\param p_mdis media discover object"]
    #[doc = " \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_discoverer_stop(p_mdis: *mut libvlc_media_discoverer_t);
}
extern "C" {
    #[doc = " Release media discover object. If the reference count reaches 0, then"]
    #[doc = " the object will be released."]
    #[doc = ""]
    #[doc = " \\param p_mdis media service discover object"]
    pub fn libvlc_media_discoverer_release(p_mdis: *mut libvlc_media_discoverer_t);
}
extern "C" {
    #[doc = " Get media service discover media list."]
    #[doc = ""]
    #[doc = " \\param p_mdis media service discover object"]
    #[doc = " \\return list of media items"]
    pub fn libvlc_media_discoverer_media_list(
        p_mdis: *mut libvlc_media_discoverer_t,
    ) -> *mut libvlc_media_list_t;
}
extern "C" {
    #[doc = " Query if media service discover object is running."]
    #[doc = ""]
    #[doc = " \\param p_mdis media service discover object"]
    #[doc = ""]
    #[doc = " \\retval true running"]
    #[doc = " \\retval false not running"]
    pub fn libvlc_media_discoverer_is_running(p_mdis: *mut libvlc_media_discoverer_t) -> bool;
}
extern "C" {
    #[doc = " Get media discoverer services by category"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_inst libvlc instance"]
    #[doc = " \\param i_cat category of services to fetch"]
    #[doc = " \\param ppp_services address to store an allocated array of media discoverer"]
    #[doc = " services (must be freed with libvlc_media_discoverer_list_release() by"]
    #[doc = " the caller) [OUT]"]
    #[doc = ""]
    #[doc = " \\return the number of media discoverer services (0 on error)"]
    pub fn libvlc_media_discoverer_list_get(
        p_inst: *mut libvlc_instance_t,
        i_cat: libvlc_media_discoverer_category_t,
        ppp_services: *mut *mut *mut libvlc_media_discoverer_description_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Release an array of media discoverer services"]
    #[doc = ""]
    #[doc = " \\version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " \\see libvlc_media_discoverer_list_get()"]
    #[doc = ""]
    #[doc = " \\param pp_services array to release"]
    #[doc = " \\param i_count number of elements in the array"]
    pub fn libvlc_media_discoverer_list_release(
        pp_services: *mut *mut libvlc_media_discoverer_description_t,
        i_count: size_t,
    );
}
#[doc = " Metadata of a \\link #libvlc_media_t media item\\endlink changed"]
pub const libvlc_event_e_libvlc_MediaMetaChanged: libvlc_event_e = 0;
#[doc = " Subitem was added to a \\link #libvlc_media_t media item\\endlink"]
#[doc = " \\see libvlc_media_subitems()"]
pub const libvlc_event_e_libvlc_MediaSubItemAdded: libvlc_event_e = 1;
#[doc = " Duration of a \\link #libvlc_media_t media item\\endlink changed"]
#[doc = " \\see libvlc_media_get_duration()"]
pub const libvlc_event_e_libvlc_MediaDurationChanged: libvlc_event_e = 2;
#[doc = " Parsing state of a \\link #libvlc_media_t media item\\endlink changed"]
#[doc = " \\see libvlc_media_parse_with_options(),"]
#[doc = "      libvlc_media_get_parsed_status(),"]
#[doc = "      libvlc_media_parse_stop()"]
pub const libvlc_event_e_libvlc_MediaParsedChanged: libvlc_event_e = 3;
#[doc = " Subitem tree was added to a \\link #libvlc_media_t media item\\endlink"]
pub const libvlc_event_e_libvlc_MediaSubItemTreeAdded: libvlc_event_e = 6;
#[doc = " A thumbnail generation for this \\link #libvlc_media_t media \\endlink completed."]
#[doc = " \\see libvlc_media_thumbnail_request_by_time()"]
#[doc = " \\see libvlc_media_thumbnail_request_by_pos()"]
pub const libvlc_event_e_libvlc_MediaThumbnailGenerated: libvlc_event_e = 7;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaAttachedThumbnailsFound: libvlc_event_e = 8;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerMediaChanged: libvlc_event_e = 256;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerNothingSpecial: libvlc_event_e = 257;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerOpening: libvlc_event_e = 258;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerBuffering: libvlc_event_e = 259;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerPlaying: libvlc_event_e = 260;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerPaused: libvlc_event_e = 261;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerStopped: libvlc_event_e = 262;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerForward: libvlc_event_e = 263;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerBackward: libvlc_event_e = 264;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerStopping: libvlc_event_e = 265;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerEncounteredError: libvlc_event_e = 266;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerTimeChanged: libvlc_event_e = 267;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerPositionChanged: libvlc_event_e = 268;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerSeekableChanged: libvlc_event_e = 269;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerPausableChanged: libvlc_event_e = 270;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerSnapshotTaken: libvlc_event_e = 272;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerLengthChanged: libvlc_event_e = 273;
#[doc = " One or more embedded thumbnails were found during the media preparsing"]
#[doc = " The user can hold these picture(s) using libvlc_picture_retain if they"]
#[doc = " wish to use them"]
pub const libvlc_event_e_libvlc_MediaPlayerVout: libvlc_event_e = 274;
#[doc = " A track was added, cf. media_player_es_changed in \\ref libvlc_event_t.u"]
#[doc = " to get the id of the new track."]
pub const libvlc_event_e_libvlc_MediaPlayerESAdded: libvlc_event_e = 276;
#[doc = " A track was removed, cf. media_player_es_changed in \\ref"]
#[doc = " libvlc_event_t.u to get the id of the removed track."]
pub const libvlc_event_e_libvlc_MediaPlayerESDeleted: libvlc_event_e = 277;
#[doc = " Tracks were selected or unselected, cf."]
#[doc = " media_player_es_selection_changed in \\ref libvlc_event_t.u to get the"]
#[doc = " unselected and/or the selected track ids."]
pub const libvlc_event_e_libvlc_MediaPlayerESSelected: libvlc_event_e = 278;
#[doc = " Tracks were selected or unselected, cf."]
#[doc = " media_player_es_selection_changed in \\ref libvlc_event_t.u to get the"]
#[doc = " unselected and/or the selected track ids."]
pub const libvlc_event_e_libvlc_MediaPlayerCorked: libvlc_event_e = 279;
#[doc = " Tracks were selected or unselected, cf."]
#[doc = " media_player_es_selection_changed in \\ref libvlc_event_t.u to get the"]
#[doc = " unselected and/or the selected track ids."]
pub const libvlc_event_e_libvlc_MediaPlayerUncorked: libvlc_event_e = 280;
#[doc = " Tracks were selected or unselected, cf."]
#[doc = " media_player_es_selection_changed in \\ref libvlc_event_t.u to get the"]
#[doc = " unselected and/or the selected track ids."]
pub const libvlc_event_e_libvlc_MediaPlayerMuted: libvlc_event_e = 281;
#[doc = " Tracks were selected or unselected, cf."]
#[doc = " media_player_es_selection_changed in \\ref libvlc_event_t.u to get the"]
#[doc = " unselected and/or the selected track ids."]
pub const libvlc_event_e_libvlc_MediaPlayerUnmuted: libvlc_event_e = 282;
#[doc = " Tracks were selected or unselected, cf."]
#[doc = " media_player_es_selection_changed in \\ref libvlc_event_t.u to get the"]
#[doc = " unselected and/or the selected track ids."]
pub const libvlc_event_e_libvlc_MediaPlayerAudioVolume: libvlc_event_e = 283;
#[doc = " Tracks were selected or unselected, cf."]
#[doc = " media_player_es_selection_changed in \\ref libvlc_event_t.u to get the"]
#[doc = " unselected and/or the selected track ids."]
pub const libvlc_event_e_libvlc_MediaPlayerAudioDevice: libvlc_event_e = 284;
#[doc = " A track was updated, cf. media_player_es_changed in \\ref"]
#[doc = " libvlc_event_t.u to get the id of the updated track."]
pub const libvlc_event_e_libvlc_MediaPlayerESUpdated: libvlc_event_e = 285;
#[doc = " A track was updated, cf. media_player_es_changed in \\ref"]
#[doc = " libvlc_event_t.u to get the id of the updated track."]
pub const libvlc_event_e_libvlc_MediaPlayerProgramAdded: libvlc_event_e = 286;
#[doc = " A track was updated, cf. media_player_es_changed in \\ref"]
#[doc = " libvlc_event_t.u to get the id of the updated track."]
pub const libvlc_event_e_libvlc_MediaPlayerProgramDeleted: libvlc_event_e = 287;
#[doc = " A track was updated, cf. media_player_es_changed in \\ref"]
#[doc = " libvlc_event_t.u to get the id of the updated track."]
pub const libvlc_event_e_libvlc_MediaPlayerProgramSelected: libvlc_event_e = 288;
#[doc = " A track was updated, cf. media_player_es_changed in \\ref"]
#[doc = " libvlc_event_t.u to get the id of the updated track."]
pub const libvlc_event_e_libvlc_MediaPlayerProgramUpdated: libvlc_event_e = 289;
#[doc = " The title list changed, call"]
#[doc = " libvlc_media_player_get_full_title_descriptions() to get the new list."]
pub const libvlc_event_e_libvlc_MediaPlayerTitleListChanged: libvlc_event_e = 290;
#[doc = " The title selection changed, cf media_player_title_selection_changed in"]
#[doc = " \\ref libvlc_event_t.u"]
pub const libvlc_event_e_libvlc_MediaPlayerTitleSelectionChanged: libvlc_event_e = 291;
#[doc = " The title selection changed, cf media_player_title_selection_changed in"]
#[doc = " \\ref libvlc_event_t.u"]
pub const libvlc_event_e_libvlc_MediaPlayerChapterChanged: libvlc_event_e = 292;
#[doc = " A \\link #libvlc_media_t media item\\endlink was added to a"]
#[doc = " \\link #libvlc_media_list_t media list\\endlink."]
pub const libvlc_event_e_libvlc_MediaListItemAdded: libvlc_event_e = 512;
#[doc = " A \\link #libvlc_media_t media item\\endlink is about to get"]
#[doc = " added to a \\link #libvlc_media_list_t media list\\endlink."]
pub const libvlc_event_e_libvlc_MediaListWillAddItem: libvlc_event_e = 513;
#[doc = " A \\link #libvlc_media_t media item\\endlink was deleted from"]
#[doc = " a \\link #libvlc_media_list_t media list\\endlink."]
pub const libvlc_event_e_libvlc_MediaListItemDeleted: libvlc_event_e = 514;
#[doc = " A \\link #libvlc_media_t media item\\endlink is about to get"]
#[doc = " deleted from a \\link #libvlc_media_list_t media list\\endlink."]
pub const libvlc_event_e_libvlc_MediaListWillDeleteItem: libvlc_event_e = 515;
#[doc = " A \\link #libvlc_media_list_t media list\\endlink has reached the"]
#[doc = " end."]
#[doc = " All \\link #libvlc_media_t items\\endlink were either added (in"]
#[doc = " case of a \\ref libvlc_media_discoverer_t) or parsed (preparser)."]
pub const libvlc_event_e_libvlc_MediaListEndReached: libvlc_event_e = 516;
#[doc = " \\deprecated No longer used."]
#[doc = " This belonged to the removed libvlc_media_list_view_t"]
pub const libvlc_event_e_libvlc_MediaListViewItemAdded: libvlc_event_e = 768;
#[doc = " \\deprecated No longer used."]
#[doc = " This belonged to the removed libvlc_media_list_view_t"]
pub const libvlc_event_e_libvlc_MediaListViewWillAddItem: libvlc_event_e = 769;
#[doc = " \\deprecated No longer used."]
#[doc = " This belonged to the removed libvlc_media_list_view_t"]
pub const libvlc_event_e_libvlc_MediaListViewItemDeleted: libvlc_event_e = 770;
#[doc = " \\deprecated No longer used."]
#[doc = " This belonged to the removed libvlc_media_list_view_t"]
pub const libvlc_event_e_libvlc_MediaListViewWillDeleteItem: libvlc_event_e = 771;
#[doc = " Playback of a \\link #libvlc_media_list_player_t media list"]
#[doc = " player\\endlink has started."]
pub const libvlc_event_e_libvlc_MediaListPlayerPlayed: libvlc_event_e = 1024;
#[doc = " The current \\link #libvlc_media_t item\\endlink of a"]
#[doc = " \\link #libvlc_media_list_player_t media list player\\endlink"]
#[doc = " has changed to a different item."]
pub const libvlc_event_e_libvlc_MediaListPlayerNextItemSet: libvlc_event_e = 1025;
#[doc = " Playback of a \\link #libvlc_media_list_player_t media list"]
#[doc = " player\\endlink has stopped."]
pub const libvlc_event_e_libvlc_MediaListPlayerStopped: libvlc_event_e = 1026;
#[doc = " A new \\link #libvlc_renderer_item_t renderer item\\endlink was found by a"]
#[doc = " \\link #libvlc_renderer_discoverer_t renderer discoverer\\endlink."]
#[doc = " The renderer item is valid until deleted."]
pub const libvlc_event_e_libvlc_RendererDiscovererItemAdded: libvlc_event_e = 1282;
#[doc = " A previously discovered \\link #libvlc_renderer_item_t renderer item\\endlink"]
#[doc = " was deleted by a \\link #libvlc_renderer_discoverer_t renderer discoverer\\endlink."]
#[doc = " The renderer item is no longer valid."]
pub const libvlc_event_e_libvlc_RendererDiscovererItemDeleted: libvlc_event_e = 1283;
#[doc = " Event types"]
pub type libvlc_event_e = libc::c_uint;
#[doc = " A LibVLC event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libvlc_event_t {
    #[doc = "< Event type (see @ref libvlc_event_e)"]
    pub type_: libc::c_int,
    #[doc = "< Object emitting the event"]
    pub p_obj: *mut libc::c_void,
    #[doc = "< Type-dependent event description"]
    pub u: libvlc_event_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union libvlc_event_t__bindgen_ty_1 {
    pub media_meta_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_1,
    pub media_subitem_added: libvlc_event_t__bindgen_ty_1__bindgen_ty_2,
    pub media_duration_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_3,
    pub media_parsed_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_4,
    pub media_state_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_5,
    pub media_thumbnail_generated: libvlc_event_t__bindgen_ty_1__bindgen_ty_6,
    pub media_subitemtree_added: libvlc_event_t__bindgen_ty_1__bindgen_ty_7,
    pub media_attached_thumbnails_found: libvlc_event_t__bindgen_ty_1__bindgen_ty_8,
    pub media_player_buffering: libvlc_event_t__bindgen_ty_1__bindgen_ty_9,
    pub media_player_chapter_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_10,
    pub media_player_position_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_11,
    pub media_player_time_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_12,
    pub media_player_title_selection_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_13,
    pub media_player_seekable_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_14,
    pub media_player_pausable_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_15,
    pub media_player_scrambled_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_16,
    pub media_player_vout: libvlc_event_t__bindgen_ty_1__bindgen_ty_17,
    pub media_list_item_added: libvlc_event_t__bindgen_ty_1__bindgen_ty_18,
    pub media_list_will_add_item: libvlc_event_t__bindgen_ty_1__bindgen_ty_19,
    pub media_list_item_deleted: libvlc_event_t__bindgen_ty_1__bindgen_ty_20,
    pub media_list_will_delete_item: libvlc_event_t__bindgen_ty_1__bindgen_ty_21,
    pub media_list_player_next_item_set: libvlc_event_t__bindgen_ty_1__bindgen_ty_22,
    pub media_player_snapshot_taken: libvlc_event_t__bindgen_ty_1__bindgen_ty_23,
    pub media_player_length_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_24,
    pub media_player_media_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_25,
    pub media_player_es_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_26,
    pub media_player_es_selection_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_27,
    pub media_player_program_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_28,
    pub media_player_program_selection_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_29,
    pub media_player_audio_volume: libvlc_event_t__bindgen_ty_1__bindgen_ty_30,
    pub media_player_audio_device: libvlc_event_t__bindgen_ty_1__bindgen_ty_31,
    pub renderer_discoverer_item_added: libvlc_event_t__bindgen_ty_1__bindgen_ty_32,
    pub renderer_discoverer_item_deleted: libvlc_event_t__bindgen_ty_1__bindgen_ty_33,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_1 {
    pub meta_type: libvlc_meta_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_1>())).meta_type
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(meta_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_2 {
    pub new_child: *mut libvlc_media_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_2>())).new_child
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(new_child)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_3 {
    pub new_duration: i64,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_3>())).new_duration
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(new_duration)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< see @ref libvlc_media_parsed_status_t"]
    pub new_status: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_4>())).new_status
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(new_status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "< see @ref libvlc_state_t"]
    pub new_state: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_5>())).new_state
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(new_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_6 {
    pub p_thumbnail: *mut libvlc_picture_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_6>())).p_thumbnail
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(p_thumbnail)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_7 {
    pub item: *mut libvlc_media_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_7>())).item as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(item)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_8 {
    pub thumbnails: *mut libvlc_picture_list_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_8>())).thumbnails
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(thumbnails)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_9 {
    pub new_cache: f32,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_9>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_9>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_9>())).new_cache
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(new_cache)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_10 {
    pub new_chapter: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_10>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_10>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_10>())).new_chapter
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(new_chapter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_11 {
    pub new_position: f32,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_11>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_11>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_11>())).new_position
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(new_position)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_12 {
    pub new_time: libvlc_time_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_12>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_12>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_12>())).new_time
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(new_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_13 {
    pub title: *const libvlc_title_description_t,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_13>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_13>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_13>())).title
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_13>())).index
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_14 {
    pub new_seekable: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_14>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_14>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_14>())).new_seekable
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(new_seekable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_15 {
    pub new_pausable: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_15() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_15>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_15>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_15>())).new_pausable
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(new_pausable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_16 {
    pub new_scrambled: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_16() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_16>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_16>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_16>())).new_scrambled
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(new_scrambled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_17 {
    pub new_count: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_17() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_17>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_17>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_17>())).new_count
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(new_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_18 {
    pub item: *mut libvlc_media_t,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_18() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_18>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_18>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_18>())).item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_18>())).index
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_19 {
    pub item: *mut libvlc_media_t,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_19() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_19>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_19>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_19>())).item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_19>())).index
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_20 {
    pub item: *mut libvlc_media_t,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_20() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_20>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_20)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_20>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_20>())).item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_20),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_20>())).index
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_20),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_21 {
    pub item: *mut libvlc_media_t,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_21() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_21>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_21)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_21>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_21>())).item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_21),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_21>())).index
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_21),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_22 {
    pub item: *mut libvlc_media_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_22() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_22>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_22)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_22>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_22>())).item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_22),
            "::",
            stringify!(item)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_23 {
    pub psz_filename: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_23() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_23>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_23)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_23>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_23>())).psz_filename
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(psz_filename)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_24 {
    pub new_length: libvlc_time_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_24() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_24>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_24)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_24>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_24>())).new_length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_24),
            "::",
            stringify!(new_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_25 {
    pub new_media: *mut libvlc_media_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_25() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_25>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_25)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_25>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_25>())).new_media
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_25),
            "::",
            stringify!(new_media)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_26 {
    pub i_type: libvlc_track_type_t,
    #[doc = "< Deprecated, use psz_id"]
    pub i_id: libc::c_int,
    #[doc = " Call libvlc_media_player_get_track_from_id() to get the track"]
    #[doc = " description."]
    pub psz_id: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_26() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_26>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_26)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_26>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_26>())).i_type
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(i_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_26>())).i_id
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(i_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_26>())).psz_id
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(psz_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_27 {
    pub i_type: libvlc_track_type_t,
    pub psz_unselected_id: *const libc::c_char,
    pub psz_selected_id: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_27() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_27>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_27)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_27>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_27>())).i_type
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_27),
            "::",
            stringify!(i_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_27>()))
                .psz_unselected_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_27),
            "::",
            stringify!(psz_unselected_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_27>())).psz_selected_id
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_27),
            "::",
            stringify!(psz_selected_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_28 {
    pub i_id: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_28() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_28>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_28)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_28>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_28>())).i_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_28),
            "::",
            stringify!(i_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_29 {
    pub i_unselected_id: libc::c_int,
    pub i_selected_id: libc::c_int,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_29() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_29>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_29)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_29>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_29>())).i_unselected_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(i_unselected_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_29>())).i_selected_id
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(i_selected_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_30 {
    pub volume: f32,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_30() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_30>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_30)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_30>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_30>())).volume
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_30),
            "::",
            stringify!(volume)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_31 {
    pub device: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_31() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_31>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_31)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_31>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_31)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_31>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_31),
            "::",
            stringify!(device)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_32 {
    pub item: *mut libvlc_renderer_item_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_32() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_32>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_32)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_32>())).item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_32),
            "::",
            stringify!(item)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_33 {
    pub item: *mut libvlc_renderer_item_t,
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1__bindgen_ty_33() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_33>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_33)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_33>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_33)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1__bindgen_ty_33>())).item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1__bindgen_ty_33),
            "::",
            stringify!(item)
        )
    );
}
#[test]
fn bindgen_test_layout_libvlc_event_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(libvlc_event_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_event_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_meta_changed as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_meta_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_subitem_added
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_subitem_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_duration_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_duration_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_parsed_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_parsed_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_state_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_state_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_thumbnail_generated
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_thumbnail_generated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_subitemtree_added
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_subitemtree_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>()))
                .media_attached_thumbnails_found as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_attached_thumbnails_found)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_buffering
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_buffering)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_chapter_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_chapter_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_position_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_position_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_time_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_time_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>()))
                .media_player_title_selection_changed as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_title_selection_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_seekable_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_seekable_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_pausable_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_pausable_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_scrambled_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_scrambled_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_vout as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_vout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_list_item_added
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_list_item_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_list_will_add_item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_list_will_add_item)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_list_item_deleted
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_list_item_deleted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_list_will_delete_item
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_list_will_delete_item)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>()))
                .media_list_player_next_item_set as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_list_player_next_item_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_snapshot_taken
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_snapshot_taken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_length_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_length_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_media_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_media_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_es_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_es_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>()))
                .media_player_es_selection_changed as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_es_selection_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_program_changed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_program_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>()))
                .media_player_program_selection_changed as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_program_selection_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_audio_volume
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_audio_volume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).media_player_audio_device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(media_player_audio_device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>())).renderer_discoverer_item_added
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(renderer_discoverer_item_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_event_t__bindgen_ty_1>()))
                .renderer_discoverer_item_deleted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t__bindgen_ty_1),
            "::",
            stringify!(renderer_discoverer_item_deleted)
        )
    );
}
#[test]
fn bindgen_test_layout_libvlc_event_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_event_t>(),
        40usize,
        concat!("Size of: ", stringify!(libvlc_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_event_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_event_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_event_t>())).p_obj as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t),
            "::",
            stringify!(p_obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_event_t>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_event_t),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_dialog_id {
    _unused: [u8; 0],
}
pub const libvlc_dialog_question_type_LIBVLC_DIALOG_QUESTION_NORMAL: libvlc_dialog_question_type =
    0;
pub const libvlc_dialog_question_type_LIBVLC_DIALOG_QUESTION_WARNING: libvlc_dialog_question_type =
    1;
pub const libvlc_dialog_question_type_LIBVLC_DIALOG_QUESTION_CRITICAL: libvlc_dialog_question_type =
    2;
#[doc = " @defgroup libvlc_dialog LibVLC dialog"]
#[doc = " @ingroup libvlc"]
#[doc = " @{"]
#[doc = " @file"]
#[doc = " LibVLC dialog external API"]
pub type libvlc_dialog_question_type = libc::c_uint;
#[doc = " Dialog callbacks to be implemented"]
#[doc = ""]
#[doc = " @attention starting with vlc 4.0.0 the error callback (pf_display_error) is"]
#[doc = "            no longer part of this struct and need to be registered separately"]
#[doc = "            using @a libvlc_dialog_set_error_callback"]
#[doc = ""]
#[doc = " @see libvlc_dialog_set_error_callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_dialog_cbs {
    #[doc = " Called when a login dialog needs to be displayed"]
    #[doc = ""]
    #[doc = " You can interact with this dialog by calling libvlc_dialog_post_login()"]
    #[doc = " to post an answer or libvlc_dialog_dismiss() to cancel this dialog."]
    #[doc = ""]
    #[doc = " @note to receive this callback, libvlc_dialog_cbs.pf_cancel should not be"]
    #[doc = " NULL."]
    #[doc = ""]
    #[doc = " @param p_data opaque pointer for the callback"]
    #[doc = " @param p_id id used to interact with the dialog"]
    #[doc = " @param psz_title title of the dialog"]
    #[doc = " @param psz_text text of the dialog"]
    #[doc = " @param psz_default_username user name that should be set on the user form"]
    #[doc = " @param b_ask_store if true, ask the user if he wants to save the"]
    #[doc = " credentials"]
    pub pf_display_login: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            p_id: *mut libvlc_dialog_id,
            psz_title: *const libc::c_char,
            psz_text: *const libc::c_char,
            psz_default_username: *const libc::c_char,
            b_ask_store: bool,
        ),
    >,
    #[doc = " Called when a question dialog needs to be displayed"]
    #[doc = ""]
    #[doc = " You can interact with this dialog by calling libvlc_dialog_post_action()"]
    #[doc = " to post an answer or libvlc_dialog_dismiss() to cancel this dialog."]
    #[doc = ""]
    #[doc = " @note to receive this callback, libvlc_dialog_cbs.pf_cancel should not be"]
    #[doc = " NULL."]
    #[doc = ""]
    #[doc = " @param p_data opaque pointer for the callback"]
    #[doc = " @param p_id id used to interact with the dialog"]
    #[doc = " @param psz_title title of the dialog"]
    #[doc = " @param psz_text text of the dialog"]
    #[doc = " @param i_type question type (or severity) of the dialog"]
    #[doc = " @param psz_cancel text of the cancel button"]
    #[doc = " @param psz_action1 text of the first button, if NULL, don't display this"]
    #[doc = " button"]
    #[doc = " @param psz_action2 text of the second button, if NULL, don't display"]
    #[doc = " this button"]
    pub pf_display_question: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            p_id: *mut libvlc_dialog_id,
            psz_title: *const libc::c_char,
            psz_text: *const libc::c_char,
            i_type: libvlc_dialog_question_type,
            psz_cancel: *const libc::c_char,
            psz_action1: *const libc::c_char,
            psz_action2: *const libc::c_char,
        ),
    >,
    #[doc = " Called when a progress dialog needs to be displayed"]
    #[doc = ""]
    #[doc = " If cancellable (psz_cancel != NULL), you can cancel this dialog by"]
    #[doc = " calling libvlc_dialog_dismiss()"]
    #[doc = ""]
    #[doc = " @note to receive this callback, libvlc_dialog_cbs.pf_cancel and"]
    #[doc = " libvlc_dialog_cbs.pf_update_progress should not be NULL."]
    #[doc = ""]
    #[doc = " @param p_data opaque pointer for the callback"]
    #[doc = " @param p_id id used to interact with the dialog"]
    #[doc = " @param psz_title title of the dialog"]
    #[doc = " @param psz_text text of the dialog"]
    #[doc = " @param b_indeterminate true if the progress dialog is indeterminate"]
    #[doc = " @param f_position initial position of the progress bar (between 0.0 and"]
    #[doc = " 1.0)"]
    #[doc = " @param psz_cancel text of the cancel button, if NULL the dialog is not"]
    #[doc = " cancellable"]
    pub pf_display_progress: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            p_id: *mut libvlc_dialog_id,
            psz_title: *const libc::c_char,
            psz_text: *const libc::c_char,
            b_indeterminate: bool,
            f_position: f32,
            psz_cancel: *const libc::c_char,
        ),
    >,
    #[doc = " Called when a displayed dialog needs to be cancelled"]
    #[doc = ""]
    #[doc = " The implementation must call libvlc_dialog_dismiss() to really release"]
    #[doc = " the dialog."]
    #[doc = ""]
    #[doc = " @param p_data opaque pointer for the callback"]
    #[doc = " @param p_id id of the dialog"]
    pub pf_cancel: ::core::option::Option<
        unsafe extern "C" fn(p_data: *mut libc::c_void, p_id: *mut libvlc_dialog_id),
    >,
    #[doc = " Called when a progress dialog needs to be updated"]
    #[doc = ""]
    #[doc = " @param p_data opaque pointer for the callback"]
    #[doc = " @param p_id id of the dialog"]
    #[doc = " @param f_position osition of the progress bar (between 0.0 and 1.0)"]
    #[doc = " @param psz_text new text of the progress dialog"]
    pub pf_update_progress: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            p_id: *mut libvlc_dialog_id,
            f_position: f32,
            psz_text: *const libc::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_libvlc_dialog_cbs() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_dialog_cbs>(),
        40usize,
        concat!("Size of: ", stringify!(libvlc_dialog_cbs))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_dialog_cbs>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_dialog_cbs))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_dialog_cbs>())).pf_display_login as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_dialog_cbs),
            "::",
            stringify!(pf_display_login)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_dialog_cbs>())).pf_display_question as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_dialog_cbs),
            "::",
            stringify!(pf_display_question)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_dialog_cbs>())).pf_display_progress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_dialog_cbs),
            "::",
            stringify!(pf_display_progress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<libvlc_dialog_cbs>())).pf_cancel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_dialog_cbs),
            "::",
            stringify!(pf_cancel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_dialog_cbs>())).pf_update_progress as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_dialog_cbs),
            "::",
            stringify!(pf_update_progress)
        )
    );
}
#[doc = " Called when an error message needs to be displayed"]
#[doc = ""]
#[doc = " @param p_data opaque pointer for the callback"]
#[doc = " @param psz_title title of the dialog"]
#[doc = " @param psz_text text of the dialog"]
pub type libvlc_dialog_error_cbs = ::core::option::Option<
    unsafe extern "C" fn(
        p_data: *mut libc::c_void,
        psz_title: *const libc::c_char,
        psz_text: *const libc::c_char,
    ),
>;
extern "C" {
    #[doc = " Register callbacks in order to handle VLC dialogs"]
    #[doc = ""]
    #[doc = " @version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " @param p_cbs a pointer to callbacks, or NULL to unregister callbacks."]
    #[doc = " @param p_data opaque pointer for the callback"]
    pub fn libvlc_dialog_set_callbacks(
        p_instance: *mut libvlc_instance_t,
        p_cbs: *const libvlc_dialog_cbs,
        p_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn libvlc_dialog_set_error_callback(
        p_instance: *mut libvlc_instance_t,
        p_cbs: libvlc_dialog_error_cbs,
        p_data: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Associate an opaque pointer with the dialog id"]
    #[doc = ""]
    #[doc = " @version LibVLC 3.0.0 and later."]
    pub fn libvlc_dialog_set_context(p_id: *mut libvlc_dialog_id, p_context: *mut libc::c_void);
}
extern "C" {
    #[doc = " Return the opaque pointer associated with the dialog id"]
    #[doc = " \\see libvlc_dialog_set_context"]
    #[doc = " @version LibVLC 3.0.0 and later."]
    pub fn libvlc_dialog_get_context(p_id: *mut libvlc_dialog_id) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Post a login answer"]
    #[doc = ""]
    #[doc = " After this call, p_id won't be valid anymore"]
    #[doc = ""]
    #[doc = " @see libvlc_dialog_cbs.pf_display_login"]
    #[doc = ""]
    #[doc = " @version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " @param p_id id of the dialog"]
    #[doc = " @param psz_username valid and non empty string"]
    #[doc = " @param psz_password valid string (can be empty)"]
    #[doc = " @param b_store if true, store the credentials"]
    #[doc = " @return 0 on success, or -1 on error"]
    pub fn libvlc_dialog_post_login(
        p_id: *mut libvlc_dialog_id,
        psz_username: *const libc::c_char,
        psz_password: *const libc::c_char,
        b_store: bool,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Post a question answer"]
    #[doc = ""]
    #[doc = " After this call, p_id won't be valid anymore"]
    #[doc = ""]
    #[doc = " @see libvlc_dialog_cbs.pf_display_question"]
    #[doc = ""]
    #[doc = " @version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " @param p_id id of the dialog"]
    #[doc = " @param i_action 1 for action1, 2 for action2"]
    #[doc = " @return 0 on success, or -1 on error"]
    pub fn libvlc_dialog_post_action(
        p_id: *mut libvlc_dialog_id,
        i_action: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Dismiss a dialog"]
    #[doc = ""]
    #[doc = " After this call, p_id won't be valid anymore"]
    #[doc = ""]
    #[doc = " @see libvlc_dialog_cbs.pf_cancel"]
    #[doc = ""]
    #[doc = " @version LibVLC 3.0.0 and later."]
    #[doc = ""]
    #[doc = " @param p_id id of the dialog"]
    #[doc = " @return 0 on success, or -1 on error"]
    pub fn libvlc_dialog_dismiss(p_id: *mut libvlc_dialog_id) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse a media."]
    #[doc = ""]
    #[doc = " This fetches (local) art, meta data and tracks information."]
    #[doc = " The method is synchronous."]
    #[doc = ""]
    #[doc = " \\deprecated This function could block indefinitely."]
    #[doc = "             Use libvlc_media_parse_with_options() instead"]
    #[doc = ""]
    #[doc = " \\see libvlc_media_parse_with_options"]
    #[doc = " \\see libvlc_media_get_meta"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    pub fn libvlc_media_parse(p_md: *mut libvlc_media_t);
}
extern "C" {
    #[doc = " Parse a media."]
    #[doc = ""]
    #[doc = " This fetches (local) art, meta data and tracks information."]
    #[doc = " The method is the asynchronous of libvlc_media_parse()."]
    #[doc = ""]
    #[doc = " To track when this is over you can listen to libvlc_MediaParsedChanged"]
    #[doc = " event. However if the media was already parsed you will not receive this"]
    #[doc = " event."]
    #[doc = ""]
    #[doc = " \\deprecated You can't be sure to receive the libvlc_MediaParsedChanged"]
    #[doc = "             event (you can wait indefinitely for this event)."]
    #[doc = "             Use libvlc_media_parse_with_options() instead"]
    #[doc = ""]
    #[doc = " \\see libvlc_media_parse"]
    #[doc = " \\see libvlc_MediaParsedChanged"]
    #[doc = " \\see libvlc_media_get_meta"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    pub fn libvlc_media_parse_async(p_md: *mut libvlc_media_t);
}
extern "C" {
    #[doc = " Return true is the media descriptor object is parsed"]
    #[doc = ""]
    #[doc = " \\deprecated This can return true in case of failure."]
    #[doc = "             Use libvlc_media_get_parsed_status() instead"]
    #[doc = ""]
    #[doc = " \\see libvlc_MediaParsedChanged"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\retval true media object has been parsed"]
    #[doc = " \\retval false otherwise"]
    pub fn libvlc_media_is_parsed(p_md: *mut libvlc_media_t) -> bool;
}
extern "C" {
    #[doc = " Get media descriptor's elementary streams description"]
    #[doc = ""]
    #[doc = " Note, you need to call libvlc_media_parse_with_options() or play the media"]
    #[doc = " at least once before calling this function."]
    #[doc = " Not doing this will result in an empty array."]
    #[doc = ""]
    #[doc = " \\version LibVLC 2.1.0 and later."]
    #[doc = " \\see libvlc_media_parse_with_options"]
    #[doc = ""]
    #[doc = " \\param p_md media descriptor object"]
    #[doc = " \\param tracks address to store an allocated array of Elementary Streams"]
    #[doc = "        descriptions (must be freed with libvlc_media_tracks_release"]
    #[doc = "by the caller) [OUT]"]
    #[doc = ""]
    #[doc = " \\return the number of Elementary Streams (zero on error)"]
    pub fn libvlc_media_tracks_get(
        p_md: *mut libvlc_media_t,
        tracks: *mut *mut *mut libvlc_media_track_t,
    ) -> libc::c_uint;
}
extern "C" {
    #[doc = " Release media descriptor's elementary streams description array"]
    #[doc = ""]
    #[doc = " \\version LibVLC 2.1.0 and later."]
    #[doc = ""]
    #[doc = " \\param p_tracks tracks info array to release"]
    #[doc = " \\param i_count number of elements in the array"]
    pub fn libvlc_media_tracks_release(
        p_tracks: *mut *mut libvlc_media_track_t,
        i_count: libc::c_uint,
    );
}
#[doc = " Description for video, audio tracks and subtitles. It contains"]
#[doc = " id, name (description string) and pointer to next record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_track_description_t {
    pub i_id: libc::c_int,
    pub psz_name: *mut libc::c_char,
    pub p_next: *mut libvlc_track_description_t,
}
#[test]
fn bindgen_test_layout_libvlc_track_description_t() {
    assert_eq!(
        ::core::mem::size_of::<libvlc_track_description_t>(),
        24usize,
        concat!("Size of: ", stringify!(libvlc_track_description_t))
    );
    assert_eq!(
        ::core::mem::align_of::<libvlc_track_description_t>(),
        8usize,
        concat!("Alignment of ", stringify!(libvlc_track_description_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_track_description_t>())).i_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_track_description_t),
            "::",
            stringify!(i_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_track_description_t>())).psz_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_track_description_t),
            "::",
            stringify!(psz_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<libvlc_track_description_t>())).p_next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libvlc_track_description_t),
            "::",
            stringify!(p_next)
        )
    );
}
extern "C" {
    #[doc = " Release (free) libvlc_track_description_t"]
    #[doc = ""]
    #[doc = " \\param p_track_description the structure to release"]
    pub fn libvlc_track_description_list_release(
        p_track_description: *mut libvlc_track_description_t,
    );
}
extern "C" {
    #[doc = " Get number of available video tracks."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the number of available video tracks (int)"]
    pub fn libvlc_video_get_track_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the description of available video tracks."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return list with description of available video tracks, or NULL on error."]
    #[doc = " It must be freed with libvlc_track_description_list_release()"]
    pub fn libvlc_video_get_track_description(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_track_description_t;
}
extern "C" {
    #[doc = " Get current video track."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the video track ID (int) or -1 if no active input"]
    pub fn libvlc_video_get_track(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Set video track."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param i_track the track ID (i_id field from track description)"]
    #[doc = " \\return 0 on success, -1 if out of range"]
    pub fn libvlc_video_set_track(
        p_mi: *mut libvlc_media_player_t,
        i_track: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get current video subtitle."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\return the video subtitle selected, or -1 if none"]
    pub fn libvlc_video_get_spu(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of available video subtitles."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\return the number of available video subtitles"]
    pub fn libvlc_video_get_spu_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the description of available video subtitles."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\return list containing description of available video subtitles."]
    #[doc = " It must be freed with libvlc_track_description_list_release()"]
    pub fn libvlc_video_get_spu_description(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_track_description_t;
}
extern "C" {
    #[doc = " Set new video subtitle."]
    #[doc = ""]
    #[doc = " \\param p_mi the media player"]
    #[doc = " \\param i_spu video subtitle track to select (i_id from track description)"]
    #[doc = " \\return 0 on success, -1 if out of range"]
    pub fn libvlc_video_set_spu(
        p_mi: *mut libvlc_media_player_t,
        i_spu: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get number of available audio tracks."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the number of available audio tracks (int), or -1 if unavailable"]
    pub fn libvlc_audio_get_track_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the description of available audio tracks."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return list with description of available audio tracks, or NULL."]
    #[doc = " It must be freed with libvlc_track_description_list_release()"]
    pub fn libvlc_audio_get_track_description(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_track_description_t;
}
extern "C" {
    #[doc = " Get current audio track."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\return the audio track ID or -1 if no active input."]
    pub fn libvlc_audio_get_track(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Set current audio track."]
    #[doc = ""]
    #[doc = " \\param p_mi media player"]
    #[doc = " \\param i_track the track ID (i_id field from track description)"]
    #[doc = " \\return 0 on success, -1 on error"]
    pub fn libvlc_audio_set_track(
        p_mi: *mut libvlc_media_player_t,
        i_track: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start playing (if there is any item in the playlist)."]
    #[doc = ""]
    #[doc = " Additional playlist item options can be specified for addition to the"]
    #[doc = " item before it is played."]
    #[doc = ""]
    #[doc = " \\param p_instance the playlist instance"]
    pub fn libvlc_playlist_play(p_instance: *mut libvlc_instance_t);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
