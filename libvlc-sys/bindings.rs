/* automatically generated by rust-bindgen 0.71.1 */

pub type __int64_t = libc::c_longlong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_off_t = __int64_t;
pub type va_list = __darwin_va_list;
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut libc::c_uchar,
    pub _size: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sbuf"][::core::mem::size_of::<__sbuf>() - 16usize];
    ["Alignment of __sbuf"][::core::mem::align_of::<__sbuf>() - 8usize];
    ["Offset of field: __sbuf::_base"][::core::mem::offset_of!(__sbuf, _base) - 0usize];
    ["Offset of field: __sbuf::_size"][::core::mem::offset_of!(__sbuf, _size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut libc::c_uchar,
    pub _r: libc::c_int,
    pub _w: libc::c_int,
    pub _flags: libc::c_short,
    pub _file: libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: libc::c_int,
    pub _cookie: *mut libc::c_void,
    pub _close:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut libc::c_void,
            arg2: *mut libc::c_char,
            __n: libc::c_int,
        ) -> libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: fpos_t, arg3: libc::c_int) -> fpos_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut libc::c_void,
            arg2: *const libc::c_char,
            __n: libc::c_int,
        ) -> libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: libc::c_int,
    pub _ubuf: [libc::c_uchar; 3usize],
    pub _nbuf: [libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: libc::c_int,
    pub _offset: fpos_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sFILE"][::core::mem::size_of::<__sFILE>() - 152usize];
    ["Alignment of __sFILE"][::core::mem::align_of::<__sFILE>() - 8usize];
    ["Offset of field: __sFILE::_p"][::core::mem::offset_of!(__sFILE, _p) - 0usize];
    ["Offset of field: __sFILE::_r"][::core::mem::offset_of!(__sFILE, _r) - 8usize];
    ["Offset of field: __sFILE::_w"][::core::mem::offset_of!(__sFILE, _w) - 12usize];
    ["Offset of field: __sFILE::_flags"][::core::mem::offset_of!(__sFILE, _flags) - 16usize];
    ["Offset of field: __sFILE::_file"][::core::mem::offset_of!(__sFILE, _file) - 18usize];
    ["Offset of field: __sFILE::_bf"][::core::mem::offset_of!(__sFILE, _bf) - 24usize];
    ["Offset of field: __sFILE::_lbfsize"][::core::mem::offset_of!(__sFILE, _lbfsize) - 40usize];
    ["Offset of field: __sFILE::_cookie"][::core::mem::offset_of!(__sFILE, _cookie) - 48usize];
    ["Offset of field: __sFILE::_close"][::core::mem::offset_of!(__sFILE, _close) - 56usize];
    ["Offset of field: __sFILE::_read"][::core::mem::offset_of!(__sFILE, _read) - 64usize];
    ["Offset of field: __sFILE::_seek"][::core::mem::offset_of!(__sFILE, _seek) - 72usize];
    ["Offset of field: __sFILE::_write"][::core::mem::offset_of!(__sFILE, _write) - 80usize];
    ["Offset of field: __sFILE::_ub"][::core::mem::offset_of!(__sFILE, _ub) - 88usize];
    ["Offset of field: __sFILE::_extra"][::core::mem::offset_of!(__sFILE, _extra) - 104usize];
    ["Offset of field: __sFILE::_ur"][::core::mem::offset_of!(__sFILE, _ur) - 112usize];
    ["Offset of field: __sFILE::_ubuf"][::core::mem::offset_of!(__sFILE, _ubuf) - 116usize];
    ["Offset of field: __sFILE::_nbuf"][::core::mem::offset_of!(__sFILE, _nbuf) - 119usize];
    ["Offset of field: __sFILE::_lb"][::core::mem::offset_of!(__sFILE, _lb) - 120usize];
    ["Offset of field: __sFILE::_blksize"][::core::mem::offset_of!(__sFILE, _blksize) - 136usize];
    ["Offset of field: __sFILE::_offset"][::core::mem::offset_of!(__sFILE, _offset) - 144usize];
};
pub type FILE = __sFILE;
unsafe extern "C" {
    pub fn vsnprintf(
        __str: *mut libc::c_char,
        __size: libc::c_ulong,
        __format: *const libc::c_char,
        arg1: __builtin_va_list,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_instance_t {
    _unused: [u8; 0],
}
pub type libvlc_time_t = i64;
unsafe extern "C" {
    #[doc = " A human-readable error message for the last LibVLC error in the calling\n thread. The resulting string is valid until another error occurs (at least\n until the next LibVLC call).\n\n @warning\n This will be NULL if there was no error."]
    pub fn libvlc_errmsg() -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Clears the LibVLC error status for the current thread. This is optional.\n By default, the error status is automatically overridden when a new error\n occurs, and destroyed when the thread exits."]
    pub fn libvlc_clearerr();
}
unsafe extern "C" {
    #[doc = " Sets the LibVLC error status and message for the current thread.\n Any previous error is overridden.\n \\param fmt the format string\n \\param ap the arguments\n \\return a nul terminated string in any case"]
    pub fn libvlc_vprinterr(fmt: *const libc::c_char, ap: va_list) -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Sets the LibVLC error status and message for the current thread.\n Any previous error is overridden.\n \\param fmt the format string\n \\param args the arguments\n \\return a nul terminated string in any case"]
    pub fn libvlc_printerr(fmt: *const libc::c_char, ...) -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Create and initialize a libvlc instance.\n This functions accept a list of \"command line\" arguments similar to the\n main(). These arguments affect the LibVLC instance default configuration.\n\n \\note\n LibVLC may create threads. Therefore, any thread-unsafe process\n initialization must be performed before calling libvlc_new(). In particular\n and where applicable:\n - setlocale() and textdomain(),\n - setenv(), unsetenv() and putenv(),\n - with the X11 display system, XInitThreads()\n   (see also libvlc_media_player_set_xwindow()) and\n - on Microsoft Windows, SetErrorMode().\n - sigprocmask() shall never be invoked; pthread_sigmask() can be used.\n\n On POSIX systems, the SIGCHLD signal <b>must not</b> be ignored, i.e. the\n signal handler must set to SIG_DFL or a function pointer, not SIG_IGN.\n Also while LibVLC is active, the wait() function shall not be called, and\n any call to waitpid() shall use a strictly positive value for the first\n parameter (i.e. the PID). Failure to follow those rules may lead to a\n deadlock or a busy loop.\n Also on POSIX systems, it is recommended that the SIGPIPE signal be blocked,\n even if it is not, in principles, necessary, e.g.:\n @code\nsigset_t set;\n\nsignal(SIGCHLD, SIG_DFL);\nsigemptyset(&set);\nsigaddset(&set, SIGPIPE);\npthread_sigmask(SIG_BLOCK, &set, NULL);\n @endcode\n\n On Microsoft Windows Vista/2008, the process error mode\n SEM_FAILCRITICALERRORS flag <b>must</b> be set before using LibVLC.\n On later versions, that is optional and unnecessary.\n Also on Microsoft Windows (Vista and any later version), setting the default\n DLL directories to SYSTEM32 exclusively is strongly recommended for\n security reasons:\n @code\nSetErrorMode(SEM_FAILCRITICALERRORS);\nSetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32);\n @endcode\n\n \\version\n Arguments are meant to be passed from the command line to LibVLC, just like\n VLC media player does. The list of valid arguments depends on the LibVLC\n version, the operating system and platform, and set of available LibVLC\n plugins. Invalid or unsupported arguments will cause the function to fail\n (i.e. return NULL). Also, some arguments may alter the behaviour or\n otherwise interfere with other LibVLC functions.\n\n \\warning\n There is absolutely no warranty or promise of forward, backward and\n cross-platform compatibility with regards to libvlc_new() arguments.\n We recommend that you do not use them, other than when debugging.\n\n \\param argc the number of arguments (should be 0)\n \\param argv list of arguments (should be NULL)\n \\return the libvlc instance or NULL in case of error"]
    pub fn libvlc_new(
        argc: libc::c_int,
        argv: *const *const libc::c_char,
    ) -> *mut libvlc_instance_t;
}
unsafe extern "C" {
    #[doc = " Decrement the reference count of a libvlc instance, and destroy it\n if it reaches zero.\n\n \\param p_instance the instance to destroy"]
    pub fn libvlc_release(p_instance: *mut libvlc_instance_t);
}
unsafe extern "C" {
    #[doc = " Increments the reference count of a libvlc instance.\n The initial reference count is 1 after libvlc_new() returns.\n\n \\param p_instance the instance to reference"]
    pub fn libvlc_retain(p_instance: *mut libvlc_instance_t);
}
unsafe extern "C" {
    #[doc = " Try to start a user interface for the libvlc instance.\n\n \\param p_instance the instance\n \\param name interface name, or NULL for default\n \\return 0 on success, -1 on error."]
    pub fn libvlc_add_intf(
        p_instance: *mut libvlc_instance_t,
        name: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Registers a callback for the LibVLC exit event. This is mostly useful if\n the VLC playlist and/or at least one interface are started with\n libvlc_playlist_play() or libvlc_add_intf() respectively.\n Typically, this function will wake up your application main loop (from\n another thread).\n\n \\note This function should be called before the playlist or interface are\n started. Otherwise, there is a small race condition: the exit event could\n be raised before the handler is registered.\n\n \\param p_instance LibVLC instance\n \\param cb callback to invoke when LibVLC wants to exit,\n           or NULL to disable the exit handler (as by default)\n \\param opaque data pointer for the callback\n \\warning This function and libvlc_wait() cannot be used at the same time."]
    pub fn libvlc_set_exit_handler(
        p_instance: *mut libvlc_instance_t,
        cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
        opaque: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Sets the application name. LibVLC passes this as the user agent string\n when a protocol requires it.\n\n \\param p_instance LibVLC instance\n \\param name human-readable application name, e.g. \"FooBar player 1.2.3\"\n \\param http HTTP User Agent, e.g. \"FooBar/1.2.3 Python/2.6.0\"\n \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_set_user_agent(
        p_instance: *mut libvlc_instance_t,
        name: *const libc::c_char,
        http: *const libc::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Sets some meta-information about the application.\n See also libvlc_set_user_agent().\n\n \\param p_instance LibVLC instance\n \\param id Java-style application identifier, e.g. \"com.acme.foobar\"\n \\param version application version numbers, e.g. \"1.2.3\"\n \\param icon application icon name, e.g. \"foobar\"\n \\version LibVLC 2.1.0 or later."]
    pub fn libvlc_set_app_id(
        p_instance: *mut libvlc_instance_t,
        id: *const libc::c_char,
        version: *const libc::c_char,
        icon: *const libc::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Retrieve libvlc version.\n\n Example: \"1.1.0-git The Luggage\"\n\n \\return a string containing the libvlc version"]
    pub fn libvlc_get_version() -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve libvlc compiler version.\n\n Example: \"gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)\"\n\n \\return a string containing the libvlc compiler version"]
    pub fn libvlc_get_compiler() -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve libvlc changeset.\n\n Example: \"aa9bce0bc4\"\n\n \\return a string containing the libvlc changeset"]
    pub fn libvlc_get_changeset() -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Frees an heap allocation returned by a LibVLC function.\n If you know you're using the same underlying C run-time as the LibVLC\n implementation, then you can call ANSI C free() directly instead.\n\n \\param ptr the pointer"]
    pub fn libvlc_free(ptr: *mut libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_manager_t {
    _unused: [u8; 0],
}
#[doc = " Type of a LibVLC event."]
pub type libvlc_event_type_t = libc::c_int;
#[doc = " Callback function notification\n \\param p_event the event triggering the callback"]
pub type libvlc_callback_t = ::core::option::Option<
    unsafe extern "C" fn(p_event: *const libvlc_event_t, p_data: *mut libc::c_void),
>;
unsafe extern "C" {
    #[doc = " Register for an event notification.\n\n \\param p_event_manager the event manager to which you want to attach to.\n        Generally it is obtained by vlc_my_object_event_manager() where\n        my_object is the object you want to listen to.\n \\param i_event_type the desired event to which we want to listen\n \\param f_callback the function to call when i_event_type occurs\n \\param user_data user provided data to carry with the event\n \\return 0 on success, ENOMEM on error"]
    pub fn libvlc_event_attach(
        p_event_manager: *mut libvlc_event_manager_t,
        i_event_type: libvlc_event_type_t,
        f_callback: libvlc_callback_t,
        user_data: *mut libc::c_void,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister an event notification.\n\n \\param p_event_manager the event manager\n \\param i_event_type the desired event to which we want to unregister\n \\param f_callback the function to call when i_event_type occurs\n \\param p_user_data user provided data to carry with the event"]
    pub fn libvlc_event_detach(
        p_event_manager: *mut libvlc_event_manager_t,
        i_event_type: libvlc_event_type_t,
        f_callback: libvlc_callback_t,
        p_user_data: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get an event's type name.\n\n \\param event_type the desired event"]
    pub fn libvlc_event_type_name(event_type: libvlc_event_type_t) -> *const libc::c_char;
}
#[doc = "< Debug message"]
pub const libvlc_log_level_LIBVLC_DEBUG: libvlc_log_level = 0;
#[doc = "< Important informational message"]
pub const libvlc_log_level_LIBVLC_NOTICE: libvlc_log_level = 2;
#[doc = "< Warning (potential error) message"]
pub const libvlc_log_level_LIBVLC_WARNING: libvlc_log_level = 3;
#[doc = "< Error message"]
pub const libvlc_log_level_LIBVLC_ERROR: libvlc_log_level = 4;
#[doc = " Logging messages level.\n \\note Future LibVLC versions may define new levels."]
pub type libvlc_log_level = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlc_log_t {
    _unused: [u8; 0],
}
pub type libvlc_log_t = vlc_log_t;
unsafe extern "C" {
    #[doc = " Gets log message debug infos.\n\n This function retrieves self-debug information about a log message:\n - the name of the VLC module emitting the message,\n - the name of the source code module (i.e. file) and\n - the line number within the source code module.\n\n The returned module name and file name will be NULL if unknown.\n The returned line number will similarly be zero if unknown.\n\n \\param ctx message context (as passed to the @ref libvlc_log_cb callback)\n \\param module module name storage (or NULL) [OUT]\n \\param file source code file name storage (or NULL) [OUT]\n \\param line source code file line number storage (or NULL) [OUT]\n \\warning The returned module name and source code file name, if non-NULL,\n are only valid until the logging callback returns.\n\n \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_get_context(
        ctx: *const libvlc_log_t,
        module: *mut *const libc::c_char,
        file: *mut *const libc::c_char,
        line: *mut libc::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Gets log message info.\n\n This function retrieves meta-information about a log message:\n - the type name of the VLC object emitting the message,\n - the object header if any, and\n - a temporaly-unique object identifier.\n\n This information is mainly meant for <b>manual</b> troubleshooting.\n\n The returned type name may be \"generic\" if unknown, but it cannot be NULL.\n The returned header will be NULL if unset; in current versions, the header\n is used to distinguish for VLM inputs.\n The returned object ID will be zero if the message is not associated with\n any VLC object.\n\n \\param ctx message context (as passed to the @ref libvlc_log_cb callback)\n \\param name object name storage (or NULL) [OUT]\n \\param header object header (or NULL) [OUT]\n \\param line source code file line number storage (or NULL) [OUT]\n \\warning The returned module name and source code file name, if non-NULL,\n are only valid until the logging callback returns.\n\n \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_get_object(
        ctx: *const libvlc_log_t,
        name: *mut *const libc::c_char,
        header: *mut *const libc::c_char,
        id: *mut usize,
    );
}
#[doc = " Callback prototype for LibVLC log message handler.\n\n \\param data data pointer as given to libvlc_log_set()\n \\param level message level (@ref libvlc_log_level)\n \\param ctx message context (meta-information about the message)\n \\param fmt printf() format string (as defined by ISO C11)\n \\param args variable argument list for the format\n \\note Log message handlers <b>must</b> be thread-safe.\n \\warning The message context pointer, the format string parameters and the\n          variable arguments are only valid until the callback returns."]
pub type libvlc_log_cb = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut libc::c_void,
        level: libc::c_int,
        ctx: *const libvlc_log_t,
        fmt: *const libc::c_char,
        args: va_list,
    ),
>;
unsafe extern "C" {
    #[doc = " Unsets the logging callback.\n\n This function deregisters the logging callback for a LibVLC instance.\n This is rarely needed as the callback is implicitly unset when the instance\n is destroyed.\n\n \\note This function will wait for any pending callbacks invocation to\n complete (causing a deadlock if called from within the callback).\n\n \\param p_instance libvlc instance\n \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_unset(p_instance: *mut libvlc_instance_t);
}
unsafe extern "C" {
    #[doc = " Sets the logging callback for a LibVLC instance.\n\n This function is thread-safe: it will wait for any pending callbacks\n invocation to complete.\n\n \\param cb callback function pointer\n \\param data opaque data pointer for the callback function\n\n \\note Some log messages (especially debug) are emitted by LibVLC while\n is being initialized. These messages cannot be captured with this interface.\n\n \\warning A deadlock may occur if this function is called from the callback.\n\n \\param p_instance libvlc instance\n \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_set(
        p_instance: *mut libvlc_instance_t,
        cb: libvlc_log_cb,
        data: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Sets up logging to a file.\n \\param p_instance libvlc instance\n \\param stream FILE pointer opened for writing\n         (the FILE pointer must remain valid until libvlc_log_unset())\n \\version LibVLC 2.1.0 or later"]
    pub fn libvlc_log_set_file(p_instance: *mut libvlc_instance_t, stream: *mut FILE);
}
#[doc = " Description of a module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_module_description_t {
    pub psz_name: *mut libc::c_char,
    pub psz_shortname: *mut libc::c_char,
    pub psz_longname: *mut libc::c_char,
    pub psz_help: *mut libc::c_char,
    pub p_next: *mut libvlc_module_description_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_module_description_t"]
        [::core::mem::size_of::<libvlc_module_description_t>() - 40usize];
    ["Alignment of libvlc_module_description_t"]
        [::core::mem::align_of::<libvlc_module_description_t>() - 8usize];
    ["Offset of field: libvlc_module_description_t::psz_name"]
        [::core::mem::offset_of!(libvlc_module_description_t, psz_name) - 0usize];
    ["Offset of field: libvlc_module_description_t::psz_shortname"]
        [::core::mem::offset_of!(libvlc_module_description_t, psz_shortname) - 8usize];
    ["Offset of field: libvlc_module_description_t::psz_longname"]
        [::core::mem::offset_of!(libvlc_module_description_t, psz_longname) - 16usize];
    ["Offset of field: libvlc_module_description_t::psz_help"]
        [::core::mem::offset_of!(libvlc_module_description_t, psz_help) - 24usize];
    ["Offset of field: libvlc_module_description_t::p_next"]
        [::core::mem::offset_of!(libvlc_module_description_t, p_next) - 32usize];
};
unsafe extern "C" {
    #[doc = " Release a list of module descriptions.\n\n \\param p_list the list to be released"]
    pub fn libvlc_module_description_list_release(p_list: *mut libvlc_module_description_t);
}
unsafe extern "C" {
    #[doc = " Returns a list of audio filters that are available.\n\n \\param p_instance libvlc instance\n\n \\return a list of module descriptions. It should be freed with libvlc_module_description_list_release().\n         In case of an error, NULL is returned.\n\n \\see libvlc_module_description_t\n \\see libvlc_module_description_list_release"]
    pub fn libvlc_audio_filter_list_get(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_module_description_t;
}
unsafe extern "C" {
    #[doc = " Returns a list of video filters that are available.\n\n \\param p_instance libvlc instance\n\n \\return a list of module descriptions. It should be freed with libvlc_module_description_list_release().\n         In case of an error, NULL is returned.\n\n \\see libvlc_module_description_t\n \\see libvlc_module_description_list_release"]
    pub fn libvlc_video_filter_list_get(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_module_description_t;
}
unsafe extern "C" {
    #[doc = " Return the current time as defined by LibVLC. The unit is the microsecond.\n Time increases monotonically (regardless of time zone changes and RTC\n adjustements).\n The origin is arbitrary but consistent across the whole system\n (e.g. the system uptim, the time since the system was booted).\n \\note On systems that support it, the POSIX monotonic clock is used."]
    pub fn libvlc_clock() -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_renderer_discoverer_t {
    _unused: [u8; 0],
}
#[doc = " Renderer discoverer description\n\n \\see libvlc_renderer_discoverer_list_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_rd_description_t {
    pub psz_name: *mut libc::c_char,
    pub psz_longname: *mut libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_rd_description_t"]
        [::core::mem::size_of::<libvlc_rd_description_t>() - 16usize];
    ["Alignment of libvlc_rd_description_t"]
        [::core::mem::align_of::<libvlc_rd_description_t>() - 8usize];
    ["Offset of field: libvlc_rd_description_t::psz_name"]
        [::core::mem::offset_of!(libvlc_rd_description_t, psz_name) - 0usize];
    ["Offset of field: libvlc_rd_description_t::psz_longname"]
        [::core::mem::offset_of!(libvlc_rd_description_t, psz_longname) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_renderer_item_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Hold a renderer item, i.e. creates a new reference\n\n This functions need to called from the libvlc_RendererDiscovererItemAdded\n callback if the libvlc user wants to use this item after. (for display or\n for passing it to the mediaplayer for example).\n\n \\version LibVLC 3.0.0 or later\n\n \\return the current item"]
    pub fn libvlc_renderer_item_hold(
        p_item: *mut libvlc_renderer_item_t,
    ) -> *mut libvlc_renderer_item_t;
}
unsafe extern "C" {
    #[doc = " Releases a renderer item, i.e. decrements its reference counter\n\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_renderer_item_release(p_item: *mut libvlc_renderer_item_t);
}
unsafe extern "C" {
    #[doc = " Get the human readable name of a renderer item\n\n \\version LibVLC 3.0.0 or later\n\n \\return the name of the item (can't be NULL, must *not* be freed)"]
    pub fn libvlc_renderer_item_name(p_item: *const libvlc_renderer_item_t) -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Get the type (not translated) of a renderer item. For now, the type can only\n be \"chromecast\" (\"upnp\", \"airplay\" may come later).\n\n \\version LibVLC 3.0.0 or later\n\n \\return the type of the item (can't be NULL, must *not* be freed)"]
    pub fn libvlc_renderer_item_type(p_item: *const libvlc_renderer_item_t) -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Get the icon uri of a renderer item\n\n \\version LibVLC 3.0.0 or later\n\n \\return the uri of the item's icon (can be NULL, must *not* be freed)"]
    pub fn libvlc_renderer_item_icon_uri(
        p_item: *const libvlc_renderer_item_t,
    ) -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Get the flags of a renderer item\n\n \\see LIBVLC_RENDERER_CAN_AUDIO\n \\see LIBVLC_RENDERER_CAN_VIDEO\n\n \\version LibVLC 3.0.0 or later\n\n \\return bitwise flag: capabilities of the renderer, see"]
    pub fn libvlc_renderer_item_flags(p_item: *const libvlc_renderer_item_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Create a renderer discoverer object by name\n\n After this object is created, you should attach to events in order to be\n notified of the discoverer events.\n\n You need to call libvlc_renderer_discoverer_start() in order to start the\n discovery.\n\n \\see libvlc_renderer_discoverer_event_manager()\n \\see libvlc_renderer_discoverer_start()\n\n \\version LibVLC 3.0.0 or later\n\n \\param p_inst libvlc instance\n \\param psz_name service name; use libvlc_renderer_discoverer_list_get() to\n get a list of the discoverer names available in this libVLC instance\n \\return media discover object or NULL in case of error"]
    pub fn libvlc_renderer_discoverer_new(
        p_inst: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> *mut libvlc_renderer_discoverer_t;
}
unsafe extern "C" {
    #[doc = " Release a renderer discoverer object\n\n \\version LibVLC 3.0.0 or later\n\n \\param p_rd renderer discoverer object"]
    pub fn libvlc_renderer_discoverer_release(p_rd: *mut libvlc_renderer_discoverer_t);
}
unsafe extern "C" {
    #[doc = " Start renderer discovery\n\n To stop it, call libvlc_renderer_discoverer_stop() or\n libvlc_renderer_discoverer_release() directly.\n\n \\see libvlc_renderer_discoverer_stop()\n\n \\version LibVLC 3.0.0 or later\n\n \\param p_rd renderer discoverer object\n \\return -1 in case of error, 0 otherwise"]
    pub fn libvlc_renderer_discoverer_start(p_rd: *mut libvlc_renderer_discoverer_t)
        -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Stop renderer discovery.\n\n \\see libvlc_renderer_discoverer_start()\n\n \\version LibVLC 3.0.0 or later\n\n \\param p_rd renderer discoverer object"]
    pub fn libvlc_renderer_discoverer_stop(p_rd: *mut libvlc_renderer_discoverer_t);
}
unsafe extern "C" {
    #[doc = " Get the event manager of the renderer discoverer\n\n The possible events to attach are @ref libvlc_RendererDiscovererItemAdded\n and @ref libvlc_RendererDiscovererItemDeleted.\n\n The @ref libvlc_renderer_item_t struct passed to event callbacks is owned by\n VLC, users should take care of holding/releasing this struct for their\n internal usage.\n\n \\see libvlc_event_t.u.renderer_discoverer_item_added.item\n \\see libvlc_event_t.u.renderer_discoverer_item_removed.item\n\n \\version LibVLC 3.0.0 or later\n\n \\return a valid event manager (can't fail)"]
    pub fn libvlc_renderer_discoverer_event_manager(
        p_rd: *mut libvlc_renderer_discoverer_t,
    ) -> *mut libvlc_event_manager_t;
}
unsafe extern "C" {
    #[doc = " Get media discoverer services\n\n \\see libvlc_renderer_list_release()\n\n \\version LibVLC 3.0.0 and later\n\n \\param p_inst libvlc instance\n \\param ppp_services address to store an allocated array of renderer\n discoverer services (must be freed with libvlc_renderer_list_release() by\n the caller) [OUT]\n\n \\return the number of media discoverer services (0 on error)"]
    pub fn libvlc_renderer_discoverer_list_get(
        p_inst: *mut libvlc_instance_t,
        ppp_services: *mut *mut *mut libvlc_rd_description_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Release an array of media discoverer services\n\n \\see libvlc_renderer_discoverer_list_get()\n\n \\version LibVLC 3.0.0 and later\n\n \\param pp_services array to release\n \\param i_count number of elements in the array"]
    pub fn libvlc_renderer_discoverer_list_release(
        pp_services: *mut *mut libvlc_rd_description_t,
        i_count: usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_t {
    _unused: [u8; 0],
}
pub const libvlc_meta_t_libvlc_meta_Title: libvlc_meta_t = 0;
pub const libvlc_meta_t_libvlc_meta_Artist: libvlc_meta_t = 1;
pub const libvlc_meta_t_libvlc_meta_Genre: libvlc_meta_t = 2;
pub const libvlc_meta_t_libvlc_meta_Copyright: libvlc_meta_t = 3;
pub const libvlc_meta_t_libvlc_meta_Album: libvlc_meta_t = 4;
pub const libvlc_meta_t_libvlc_meta_TrackNumber: libvlc_meta_t = 5;
pub const libvlc_meta_t_libvlc_meta_Description: libvlc_meta_t = 6;
pub const libvlc_meta_t_libvlc_meta_Rating: libvlc_meta_t = 7;
pub const libvlc_meta_t_libvlc_meta_Date: libvlc_meta_t = 8;
pub const libvlc_meta_t_libvlc_meta_Setting: libvlc_meta_t = 9;
pub const libvlc_meta_t_libvlc_meta_URL: libvlc_meta_t = 10;
pub const libvlc_meta_t_libvlc_meta_Language: libvlc_meta_t = 11;
pub const libvlc_meta_t_libvlc_meta_NowPlaying: libvlc_meta_t = 12;
pub const libvlc_meta_t_libvlc_meta_Publisher: libvlc_meta_t = 13;
pub const libvlc_meta_t_libvlc_meta_EncodedBy: libvlc_meta_t = 14;
pub const libvlc_meta_t_libvlc_meta_ArtworkURL: libvlc_meta_t = 15;
pub const libvlc_meta_t_libvlc_meta_TrackID: libvlc_meta_t = 16;
pub const libvlc_meta_t_libvlc_meta_TrackTotal: libvlc_meta_t = 17;
pub const libvlc_meta_t_libvlc_meta_Director: libvlc_meta_t = 18;
pub const libvlc_meta_t_libvlc_meta_Season: libvlc_meta_t = 19;
pub const libvlc_meta_t_libvlc_meta_Episode: libvlc_meta_t = 20;
pub const libvlc_meta_t_libvlc_meta_ShowName: libvlc_meta_t = 21;
pub const libvlc_meta_t_libvlc_meta_Actors: libvlc_meta_t = 22;
pub const libvlc_meta_t_libvlc_meta_AlbumArtist: libvlc_meta_t = 23;
pub const libvlc_meta_t_libvlc_meta_DiscNumber: libvlc_meta_t = 24;
pub const libvlc_meta_t_libvlc_meta_DiscTotal: libvlc_meta_t = 25;
#[doc = " Meta data types"]
pub type libvlc_meta_t = libc::c_uint;
pub const libvlc_state_t_libvlc_NothingSpecial: libvlc_state_t = 0;
pub const libvlc_state_t_libvlc_Opening: libvlc_state_t = 1;
pub const libvlc_state_t_libvlc_Buffering: libvlc_state_t = 2;
pub const libvlc_state_t_libvlc_Playing: libvlc_state_t = 3;
pub const libvlc_state_t_libvlc_Paused: libvlc_state_t = 4;
pub const libvlc_state_t_libvlc_Stopped: libvlc_state_t = 5;
pub const libvlc_state_t_libvlc_Ended: libvlc_state_t = 6;
pub const libvlc_state_t_libvlc_Error: libvlc_state_t = 7;
#[doc = " Note the order of libvlc_state_t enum must match exactly the order of\n \\see mediacontrol_PlayerStatus, \\see input_state_e enums,\n and VideoLAN.LibVLC.State (at bindings/cil/src/media.cs).\n\n Expected states by web plugins are:\n IDLE/CLOSE=0, OPENING=1, PLAYING=3, PAUSED=4,\n STOPPING=5, ENDED=6, ERROR=7"]
pub type libvlc_state_t = libc::c_uint;
pub const libvlc_media_option_trusted: _bindgen_ty_1 = 2;
pub const libvlc_media_option_unique: _bindgen_ty_1 = 256;
pub type _bindgen_ty_1 = libc::c_uint;
pub const libvlc_track_type_t_libvlc_track_unknown: libvlc_track_type_t = -1;
pub const libvlc_track_type_t_libvlc_track_audio: libvlc_track_type_t = 0;
pub const libvlc_track_type_t_libvlc_track_video: libvlc_track_type_t = 1;
pub const libvlc_track_type_t_libvlc_track_text: libvlc_track_type_t = 2;
pub type libvlc_track_type_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_stats_t {
    pub i_read_bytes: libc::c_int,
    pub f_input_bitrate: f32,
    pub i_demux_read_bytes: libc::c_int,
    pub f_demux_bitrate: f32,
    pub i_demux_corrupted: libc::c_int,
    pub i_demux_discontinuity: libc::c_int,
    pub i_decoded_video: libc::c_int,
    pub i_decoded_audio: libc::c_int,
    pub i_displayed_pictures: libc::c_int,
    pub i_lost_pictures: libc::c_int,
    pub i_played_abuffers: libc::c_int,
    pub i_lost_abuffers: libc::c_int,
    pub i_sent_packets: libc::c_int,
    pub i_sent_bytes: libc::c_int,
    pub f_send_bitrate: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_stats_t"][::core::mem::size_of::<libvlc_media_stats_t>() - 60usize];
    ["Alignment of libvlc_media_stats_t"][::core::mem::align_of::<libvlc_media_stats_t>() - 4usize];
    ["Offset of field: libvlc_media_stats_t::i_read_bytes"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_read_bytes) - 0usize];
    ["Offset of field: libvlc_media_stats_t::f_input_bitrate"]
        [::core::mem::offset_of!(libvlc_media_stats_t, f_input_bitrate) - 4usize];
    ["Offset of field: libvlc_media_stats_t::i_demux_read_bytes"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_demux_read_bytes) - 8usize];
    ["Offset of field: libvlc_media_stats_t::f_demux_bitrate"]
        [::core::mem::offset_of!(libvlc_media_stats_t, f_demux_bitrate) - 12usize];
    ["Offset of field: libvlc_media_stats_t::i_demux_corrupted"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_demux_corrupted) - 16usize];
    ["Offset of field: libvlc_media_stats_t::i_demux_discontinuity"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_demux_discontinuity) - 20usize];
    ["Offset of field: libvlc_media_stats_t::i_decoded_video"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_decoded_video) - 24usize];
    ["Offset of field: libvlc_media_stats_t::i_decoded_audio"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_decoded_audio) - 28usize];
    ["Offset of field: libvlc_media_stats_t::i_displayed_pictures"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_displayed_pictures) - 32usize];
    ["Offset of field: libvlc_media_stats_t::i_lost_pictures"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_lost_pictures) - 36usize];
    ["Offset of field: libvlc_media_stats_t::i_played_abuffers"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_played_abuffers) - 40usize];
    ["Offset of field: libvlc_media_stats_t::i_lost_abuffers"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_lost_abuffers) - 44usize];
    ["Offset of field: libvlc_media_stats_t::i_sent_packets"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_sent_packets) - 48usize];
    ["Offset of field: libvlc_media_stats_t::i_sent_bytes"]
        [::core::mem::offset_of!(libvlc_media_stats_t, i_sent_bytes) - 52usize];
    ["Offset of field: libvlc_media_stats_t::f_send_bitrate"]
        [::core::mem::offset_of!(libvlc_media_stats_t, f_send_bitrate) - 56usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libvlc_media_track_info_t {
    pub i_codec: u32,
    pub i_id: libc::c_int,
    pub i_type: libvlc_track_type_t,
    pub i_profile: libc::c_int,
    pub i_level: libc::c_int,
    pub u: libvlc_media_track_info_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union libvlc_media_track_info_t__bindgen_ty_1 {
    pub audio: libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1,
    pub video: libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1 {
    pub i_channels: libc::c_uint,
    pub i_rate: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1::i_channels"][::core::mem::offset_of!(
        libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1,
        i_channels
    )
        - 0usize];
    ["Offset of field: libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1::i_rate"][::core::mem::offset_of!(
        libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_1,
        i_rate
    ) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2 {
    pub i_height: libc::c_uint,
    pub i_width: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2::i_height"][::core::mem::offset_of!(
        libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2,
        i_height
    )
        - 0usize];
    ["Offset of field: libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2::i_width"][::core::mem::offset_of!(
        libvlc_media_track_info_t__bindgen_ty_1__bindgen_ty_2,
        i_width
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_track_info_t__bindgen_ty_1"]
        [::core::mem::size_of::<libvlc_media_track_info_t__bindgen_ty_1>() - 8usize];
    ["Alignment of libvlc_media_track_info_t__bindgen_ty_1"]
        [::core::mem::align_of::<libvlc_media_track_info_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: libvlc_media_track_info_t__bindgen_ty_1::audio"]
        [::core::mem::offset_of!(libvlc_media_track_info_t__bindgen_ty_1, audio) - 0usize];
    ["Offset of field: libvlc_media_track_info_t__bindgen_ty_1::video"]
        [::core::mem::offset_of!(libvlc_media_track_info_t__bindgen_ty_1, video) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_track_info_t"]
        [::core::mem::size_of::<libvlc_media_track_info_t>() - 28usize];
    ["Alignment of libvlc_media_track_info_t"]
        [::core::mem::align_of::<libvlc_media_track_info_t>() - 4usize];
    ["Offset of field: libvlc_media_track_info_t::i_codec"]
        [::core::mem::offset_of!(libvlc_media_track_info_t, i_codec) - 0usize];
    ["Offset of field: libvlc_media_track_info_t::i_id"]
        [::core::mem::offset_of!(libvlc_media_track_info_t, i_id) - 4usize];
    ["Offset of field: libvlc_media_track_info_t::i_type"]
        [::core::mem::offset_of!(libvlc_media_track_info_t, i_type) - 8usize];
    ["Offset of field: libvlc_media_track_info_t::i_profile"]
        [::core::mem::offset_of!(libvlc_media_track_info_t, i_profile) - 12usize];
    ["Offset of field: libvlc_media_track_info_t::i_level"]
        [::core::mem::offset_of!(libvlc_media_track_info_t, i_level) - 16usize];
    ["Offset of field: libvlc_media_track_info_t::u"]
        [::core::mem::offset_of!(libvlc_media_track_info_t, u) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_audio_track_t {
    pub i_channels: libc::c_uint,
    pub i_rate: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_audio_track_t"][::core::mem::size_of::<libvlc_audio_track_t>() - 8usize];
    ["Alignment of libvlc_audio_track_t"][::core::mem::align_of::<libvlc_audio_track_t>() - 4usize];
    ["Offset of field: libvlc_audio_track_t::i_channels"]
        [::core::mem::offset_of!(libvlc_audio_track_t, i_channels) - 0usize];
    ["Offset of field: libvlc_audio_track_t::i_rate"]
        [::core::mem::offset_of!(libvlc_audio_track_t, i_rate) - 4usize];
};
#[doc = "< Normal. Top line represents top, left column left."]
pub const libvlc_video_orient_t_libvlc_video_orient_top_left: libvlc_video_orient_t = 0;
#[doc = "< Flipped horizontally"]
pub const libvlc_video_orient_t_libvlc_video_orient_top_right: libvlc_video_orient_t = 1;
#[doc = "< Flipped vertically"]
pub const libvlc_video_orient_t_libvlc_video_orient_bottom_left: libvlc_video_orient_t = 2;
#[doc = "< Rotated 180 degrees"]
pub const libvlc_video_orient_t_libvlc_video_orient_bottom_right: libvlc_video_orient_t = 3;
#[doc = "< Transposed"]
pub const libvlc_video_orient_t_libvlc_video_orient_left_top: libvlc_video_orient_t = 4;
#[doc = "< Rotated 90 degrees clockwise (or 270 anti-clockwise)"]
pub const libvlc_video_orient_t_libvlc_video_orient_left_bottom: libvlc_video_orient_t = 5;
#[doc = "< Rotated 90 degrees anti-clockwise"]
pub const libvlc_video_orient_t_libvlc_video_orient_right_top: libvlc_video_orient_t = 6;
#[doc = "< Anti-transposed"]
pub const libvlc_video_orient_t_libvlc_video_orient_right_bottom: libvlc_video_orient_t = 7;
pub type libvlc_video_orient_t = libc::c_uint;
pub const libvlc_video_projection_t_libvlc_video_projection_rectangular: libvlc_video_projection_t =
    0;
#[doc = "< 360 spherical"]
pub const libvlc_video_projection_t_libvlc_video_projection_equirectangular:
    libvlc_video_projection_t = 1;
pub const libvlc_video_projection_t_libvlc_video_projection_cubemap_layout_standard:
    libvlc_video_projection_t = 256;
pub type libvlc_video_projection_t = libc::c_uint;
#[doc = " Viewpoint\n\n \\warning allocate using libvlc_video_new_viewpoint()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_viewpoint_t {
    #[doc = "< view point yaw in degrees  ]-180;180]"]
    pub f_yaw: f32,
    #[doc = "< view point pitch in degrees  ]-90;90]"]
    pub f_pitch: f32,
    #[doc = "< view point roll in degrees ]-180;180]"]
    pub f_roll: f32,
    #[doc = "< field of view in degrees ]0;180[ (default 80.)"]
    pub f_field_of_view: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_video_viewpoint_t"]
        [::core::mem::size_of::<libvlc_video_viewpoint_t>() - 16usize];
    ["Alignment of libvlc_video_viewpoint_t"]
        [::core::mem::align_of::<libvlc_video_viewpoint_t>() - 4usize];
    ["Offset of field: libvlc_video_viewpoint_t::f_yaw"]
        [::core::mem::offset_of!(libvlc_video_viewpoint_t, f_yaw) - 0usize];
    ["Offset of field: libvlc_video_viewpoint_t::f_pitch"]
        [::core::mem::offset_of!(libvlc_video_viewpoint_t, f_pitch) - 4usize];
    ["Offset of field: libvlc_video_viewpoint_t::f_roll"]
        [::core::mem::offset_of!(libvlc_video_viewpoint_t, f_roll) - 8usize];
    ["Offset of field: libvlc_video_viewpoint_t::f_field_of_view"]
        [::core::mem::offset_of!(libvlc_video_viewpoint_t, f_field_of_view) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_video_track_t {
    pub i_height: libc::c_uint,
    pub i_width: libc::c_uint,
    pub i_sar_num: libc::c_uint,
    pub i_sar_den: libc::c_uint,
    pub i_frame_rate_num: libc::c_uint,
    pub i_frame_rate_den: libc::c_uint,
    pub i_orientation: libvlc_video_orient_t,
    pub i_projection: libvlc_video_projection_t,
    #[doc = "< Initial view point"]
    pub pose: libvlc_video_viewpoint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_video_track_t"][::core::mem::size_of::<libvlc_video_track_t>() - 48usize];
    ["Alignment of libvlc_video_track_t"][::core::mem::align_of::<libvlc_video_track_t>() - 4usize];
    ["Offset of field: libvlc_video_track_t::i_height"]
        [::core::mem::offset_of!(libvlc_video_track_t, i_height) - 0usize];
    ["Offset of field: libvlc_video_track_t::i_width"]
        [::core::mem::offset_of!(libvlc_video_track_t, i_width) - 4usize];
    ["Offset of field: libvlc_video_track_t::i_sar_num"]
        [::core::mem::offset_of!(libvlc_video_track_t, i_sar_num) - 8usize];
    ["Offset of field: libvlc_video_track_t::i_sar_den"]
        [::core::mem::offset_of!(libvlc_video_track_t, i_sar_den) - 12usize];
    ["Offset of field: libvlc_video_track_t::i_frame_rate_num"]
        [::core::mem::offset_of!(libvlc_video_track_t, i_frame_rate_num) - 16usize];
    ["Offset of field: libvlc_video_track_t::i_frame_rate_den"]
        [::core::mem::offset_of!(libvlc_video_track_t, i_frame_rate_den) - 20usize];
    ["Offset of field: libvlc_video_track_t::i_orientation"]
        [::core::mem::offset_of!(libvlc_video_track_t, i_orientation) - 24usize];
    ["Offset of field: libvlc_video_track_t::i_projection"]
        [::core::mem::offset_of!(libvlc_video_track_t, i_projection) - 28usize];
    ["Offset of field: libvlc_video_track_t::pose"]
        [::core::mem::offset_of!(libvlc_video_track_t, pose) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_subtitle_track_t {
    pub psz_encoding: *mut libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_subtitle_track_t"][::core::mem::size_of::<libvlc_subtitle_track_t>() - 8usize];
    ["Alignment of libvlc_subtitle_track_t"]
        [::core::mem::align_of::<libvlc_subtitle_track_t>() - 8usize];
    ["Offset of field: libvlc_subtitle_track_t::psz_encoding"]
        [::core::mem::offset_of!(libvlc_subtitle_track_t, psz_encoding) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libvlc_media_track_t {
    pub i_codec: u32,
    pub i_original_fourcc: u32,
    pub i_id: libc::c_int,
    pub i_type: libvlc_track_type_t,
    pub i_profile: libc::c_int,
    pub i_level: libc::c_int,
    pub __bindgen_anon_1: libvlc_media_track_t__bindgen_ty_1,
    pub i_bitrate: libc::c_uint,
    pub psz_language: *mut libc::c_char,
    pub psz_description: *mut libc::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union libvlc_media_track_t__bindgen_ty_1 {
    pub audio: *mut libvlc_audio_track_t,
    pub video: *mut libvlc_video_track_t,
    pub subtitle: *mut libvlc_subtitle_track_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_track_t__bindgen_ty_1"]
        [::core::mem::size_of::<libvlc_media_track_t__bindgen_ty_1>() - 8usize];
    ["Alignment of libvlc_media_track_t__bindgen_ty_1"]
        [::core::mem::align_of::<libvlc_media_track_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: libvlc_media_track_t__bindgen_ty_1::audio"]
        [::core::mem::offset_of!(libvlc_media_track_t__bindgen_ty_1, audio) - 0usize];
    ["Offset of field: libvlc_media_track_t__bindgen_ty_1::video"]
        [::core::mem::offset_of!(libvlc_media_track_t__bindgen_ty_1, video) - 0usize];
    ["Offset of field: libvlc_media_track_t__bindgen_ty_1::subtitle"]
        [::core::mem::offset_of!(libvlc_media_track_t__bindgen_ty_1, subtitle) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_track_t"][::core::mem::size_of::<libvlc_media_track_t>() - 56usize];
    ["Alignment of libvlc_media_track_t"][::core::mem::align_of::<libvlc_media_track_t>() - 8usize];
    ["Offset of field: libvlc_media_track_t::i_codec"]
        [::core::mem::offset_of!(libvlc_media_track_t, i_codec) - 0usize];
    ["Offset of field: libvlc_media_track_t::i_original_fourcc"]
        [::core::mem::offset_of!(libvlc_media_track_t, i_original_fourcc) - 4usize];
    ["Offset of field: libvlc_media_track_t::i_id"]
        [::core::mem::offset_of!(libvlc_media_track_t, i_id) - 8usize];
    ["Offset of field: libvlc_media_track_t::i_type"]
        [::core::mem::offset_of!(libvlc_media_track_t, i_type) - 12usize];
    ["Offset of field: libvlc_media_track_t::i_profile"]
        [::core::mem::offset_of!(libvlc_media_track_t, i_profile) - 16usize];
    ["Offset of field: libvlc_media_track_t::i_level"]
        [::core::mem::offset_of!(libvlc_media_track_t, i_level) - 20usize];
    ["Offset of field: libvlc_media_track_t::i_bitrate"]
        [::core::mem::offset_of!(libvlc_media_track_t, i_bitrate) - 32usize];
    ["Offset of field: libvlc_media_track_t::psz_language"]
        [::core::mem::offset_of!(libvlc_media_track_t, psz_language) - 40usize];
    ["Offset of field: libvlc_media_track_t::psz_description"]
        [::core::mem::offset_of!(libvlc_media_track_t, psz_description) - 48usize];
};
pub const libvlc_media_type_t_libvlc_media_type_unknown: libvlc_media_type_t = 0;
pub const libvlc_media_type_t_libvlc_media_type_file: libvlc_media_type_t = 1;
pub const libvlc_media_type_t_libvlc_media_type_directory: libvlc_media_type_t = 2;
pub const libvlc_media_type_t_libvlc_media_type_disc: libvlc_media_type_t = 3;
pub const libvlc_media_type_t_libvlc_media_type_stream: libvlc_media_type_t = 4;
pub const libvlc_media_type_t_libvlc_media_type_playlist: libvlc_media_type_t = 5;
#[doc = " Media type\n\n \\see libvlc_media_get_type"]
pub type libvlc_media_type_t = libc::c_uint;
#[doc = " Parse media if it's a local file"]
pub const libvlc_media_parse_flag_t_libvlc_media_parse_local: libvlc_media_parse_flag_t = 0;
#[doc = " Parse media even if it's a network file"]
pub const libvlc_media_parse_flag_t_libvlc_media_parse_network: libvlc_media_parse_flag_t = 1;
#[doc = " Fetch meta and covert art using local resources"]
pub const libvlc_media_parse_flag_t_libvlc_media_fetch_local: libvlc_media_parse_flag_t = 2;
#[doc = " Fetch meta and covert art using network resources"]
pub const libvlc_media_parse_flag_t_libvlc_media_fetch_network: libvlc_media_parse_flag_t = 4;
#[doc = " Interact with the user (via libvlc_dialog_cbs) when preparsing this item\n (and not its sub items). Set this flag in order to receive a callback\n when the input is asking for credentials."]
pub const libvlc_media_parse_flag_t_libvlc_media_do_interact: libvlc_media_parse_flag_t = 8;
#[doc = " Parse flags used by libvlc_media_parse_with_options()\n\n \\see libvlc_media_parse_with_options"]
pub type libvlc_media_parse_flag_t = libc::c_uint;
pub const libvlc_media_parsed_status_t_libvlc_media_parsed_status_skipped:
    libvlc_media_parsed_status_t = 1;
pub const libvlc_media_parsed_status_t_libvlc_media_parsed_status_failed:
    libvlc_media_parsed_status_t = 2;
pub const libvlc_media_parsed_status_t_libvlc_media_parsed_status_timeout:
    libvlc_media_parsed_status_t = 3;
pub const libvlc_media_parsed_status_t_libvlc_media_parsed_status_done:
    libvlc_media_parsed_status_t = 4;
#[doc = " Parse status used sent by libvlc_media_parse_with_options() or returned by\n libvlc_media_get_parsed_status()\n\n \\see libvlc_media_parse_with_options\n \\see libvlc_media_get_parsed_status"]
pub type libvlc_media_parsed_status_t = libc::c_uint;
pub const libvlc_media_slave_type_t_libvlc_media_slave_type_subtitle: libvlc_media_slave_type_t = 0;
pub const libvlc_media_slave_type_t_libvlc_media_slave_type_audio: libvlc_media_slave_type_t = 1;
#[doc = " Type of a media slave: subtitle or audio."]
pub type libvlc_media_slave_type_t = libc::c_uint;
#[doc = " A slave of a libvlc_media_t\n \\see libvlc_media_slaves_get"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_slave_t {
    pub psz_uri: *mut libc::c_char,
    pub i_type: libvlc_media_slave_type_t,
    pub i_priority: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_slave_t"][::core::mem::size_of::<libvlc_media_slave_t>() - 16usize];
    ["Alignment of libvlc_media_slave_t"][::core::mem::align_of::<libvlc_media_slave_t>() - 8usize];
    ["Offset of field: libvlc_media_slave_t::psz_uri"]
        [::core::mem::offset_of!(libvlc_media_slave_t, psz_uri) - 0usize];
    ["Offset of field: libvlc_media_slave_t::i_type"]
        [::core::mem::offset_of!(libvlc_media_slave_t, i_type) - 8usize];
    ["Offset of field: libvlc_media_slave_t::i_priority"]
        [::core::mem::offset_of!(libvlc_media_slave_t, i_priority) - 12usize];
};
#[doc = " Callback prototype to open a custom bitstream input media.\n\n The same media item can be opened multiple times. Each time, this callback\n is invoked. It should allocate and initialize any instance-specific\n resources, then store them in *datap. The instance resources can be freed\n in the @ref libvlc_media_close_cb callback.\n\n \\param opaque private pointer as passed to libvlc_media_new_callbacks()\n \\param datap storage space for a private data pointer [OUT]\n \\param sizep byte length of the bitstream or UINT64_MAX if unknown [OUT]\n\n \\note For convenience, *datap is initially NULL and *sizep is initially 0.\n\n \\return 0 on success, non-zero on error. In case of failure, the other\n callbacks will not be invoked and any value stored in *datap and *sizep is\n discarded."]
pub type libvlc_media_open_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        datap: *mut *mut libc::c_void,
        sizep: *mut u64,
    ) -> libc::c_int,
>;
#[doc = " Callback prototype to read data from a custom bitstream input media.\n\n \\param opaque private pointer as set by the @ref libvlc_media_open_cb\n               callback\n \\param buf start address of the buffer to read data into\n \\param len bytes length of the buffer\n\n \\return strictly positive number of bytes read, 0 on end-of-stream,\n         or -1 on non-recoverable error\n\n \\note If no data is immediately available, then the callback should sleep.\n \\warning The application is responsible for avoiding deadlock situations.\n In particular, the callback should return an error if playback is stopped;\n if it does not return, then libvlc_media_player_stop() will never return."]
pub type libvlc_media_read_cb = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, buf: *mut libc::c_uchar, len: usize) -> isize,
>;
#[doc = " Callback prototype to seek a custom bitstream input media.\n\n \\param opaque private pointer as set by the @ref libvlc_media_open_cb\n               callback\n \\param offset absolute byte offset to seek to\n \\return 0 on success, -1 on error."]
pub type libvlc_media_seek_cb = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, offset: u64) -> libc::c_int,
>;
#[doc = " Callback prototype to close a custom bitstream input media.\n\n \\param opaque private pointer as set by the @ref libvlc_media_open_cb\n               callback"]
pub type libvlc_media_close_cb =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>;
unsafe extern "C" {
    #[doc = " Create a media with a certain given media resource location,\n for instance a valid URL.\n\n \\note To refer to a local file with this function,\n the file://... URI syntax <b>must</b> be used (see IETF RFC3986).\n We recommend using libvlc_media_new_path() instead when dealing with\n local files.\n\n \\see libvlc_media_release\n\n \\param p_instance the instance\n \\param psz_mrl the media location\n \\return the newly created media or NULL on error"]
    pub fn libvlc_media_new_location(
        p_instance: *mut libvlc_instance_t,
        psz_mrl: *const libc::c_char,
    ) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Create a media for a certain file path.\n\n \\see libvlc_media_release\n\n \\param p_instance the instance\n \\param path local filesystem path\n \\return the newly created media or NULL on error"]
    pub fn libvlc_media_new_path(
        p_instance: *mut libvlc_instance_t,
        path: *const libc::c_char,
    ) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Create a media for an already open file descriptor.\n The file descriptor shall be open for reading (or reading and writing).\n\n Regular file descriptors, pipe read descriptors and character device\n descriptors (including TTYs) are supported on all platforms.\n Block device descriptors are supported where available.\n Directory descriptors are supported on systems that provide fdopendir().\n Sockets are supported on all platforms where they are file descriptors,\n i.e. all except Windows.\n\n \\note This library will <b>not</b> automatically close the file descriptor\n under any circumstance. Nevertheless, a file descriptor can usually only be\n rendered once in a media player. To render it a second time, the file\n descriptor should probably be rewound to the beginning with lseek().\n\n \\see libvlc_media_release\n\n \\version LibVLC 1.1.5 and later.\n\n \\param p_instance the instance\n \\param fd open file descriptor\n \\return the newly created media or NULL on error"]
    pub fn libvlc_media_new_fd(
        p_instance: *mut libvlc_instance_t,
        fd: libc::c_int,
    ) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Create a media with custom callbacks to read the data from.\n\n \\param instance LibVLC instance\n \\param open_cb callback to open the custom bitstream input media\n \\param read_cb callback to read data (must not be NULL)\n \\param seek_cb callback to seek, or NULL if seeking is not supported\n \\param close_cb callback to close the media, or NULL if unnecessary\n \\param opaque data pointer for the open callback\n\n \\return the newly created media or NULL on error\n\n \\note If open_cb is NULL, the opaque pointer will be passed to read_cb,\n seek_cb and close_cb, and the stream size will be treated as unknown.\n\n \\note The callbacks may be called asynchronously (from another thread).\n A single stream instance need not be reentrant. However the open_cb needs to\n be reentrant if the media is used by multiple player instances.\n\n \\warning The callbacks may be used until all or any player instances\n that were supplied the media item are stopped.\n\n \\see libvlc_media_release\n\n \\version LibVLC 3.0.0 and later."]
    pub fn libvlc_media_new_callbacks(
        instance: *mut libvlc_instance_t,
        open_cb: libvlc_media_open_cb,
        read_cb: libvlc_media_read_cb,
        seek_cb: libvlc_media_seek_cb,
        close_cb: libvlc_media_close_cb,
        opaque: *mut libc::c_void,
    ) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Create a media as an empty node with a given name.\n\n \\see libvlc_media_release\n\n \\param p_instance the instance\n \\param psz_name the name of the node\n \\return the new empty media or NULL on error"]
    pub fn libvlc_media_new_as_node(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Add an option to the media.\n\n This option will be used to determine how the media_player will\n read the media. This allows to use VLC's advanced\n reading/streaming options on a per-media basis.\n\n \\note The options are listed in 'vlc --long-help' from the command line,\n e.g. \"-sout-all\". Keep in mind that available options and their semantics\n vary across LibVLC versions and builds.\n \\warning Not all options affects libvlc_media_t objects:\n Specifically, due to architectural issues most audio and video options,\n such as text renderer options, have no effects on an individual media.\n These options must be set through libvlc_new() instead.\n\n \\param p_md the media descriptor\n \\param psz_options the options (as a string)"]
    pub fn libvlc_media_add_option(p_md: *mut libvlc_media_t, psz_options: *const libc::c_char);
}
unsafe extern "C" {
    #[doc = " Add an option to the media with configurable flags.\n\n This option will be used to determine how the media_player will\n read the media. This allows to use VLC's advanced\n reading/streaming options on a per-media basis.\n\n The options are detailed in vlc --long-help, for instance\n \"--sout-all\". Note that all options are not usable on medias:\n specifically, due to architectural issues, video-related options\n such as text renderer options cannot be set on a single media. They\n must be set on the whole libvlc instance instead.\n\n \\param p_md the media descriptor\n \\param psz_options the options (as a string)\n \\param i_flags the flags for this option"]
    pub fn libvlc_media_add_option_flag(
        p_md: *mut libvlc_media_t,
        psz_options: *const libc::c_char,
        i_flags: libc::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Retain a reference to a media descriptor object (libvlc_media_t). Use\n libvlc_media_release() to decrement the reference count of a\n media descriptor object.\n\n \\param p_md the media descriptor"]
    pub fn libvlc_media_retain(p_md: *mut libvlc_media_t);
}
unsafe extern "C" {
    #[doc = " Decrement the reference count of a media descriptor object. If the\n reference count is 0, then libvlc_media_release() will release the\n media descriptor object. It will send out an libvlc_MediaFreed event\n to all listeners. If the media descriptor object has been released it\n should not be used again.\n\n \\param p_md the media descriptor"]
    pub fn libvlc_media_release(p_md: *mut libvlc_media_t);
}
unsafe extern "C" {
    #[doc = " Get the media resource locator (mrl) from a media descriptor object\n\n \\param p_md a media descriptor object\n \\return string with mrl of media descriptor object"]
    pub fn libvlc_media_get_mrl(p_md: *mut libvlc_media_t) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Duplicate a media descriptor object.\n\n \\param p_md a media descriptor object."]
    pub fn libvlc_media_duplicate(p_md: *mut libvlc_media_t) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Read the meta of the media.\n\n If the media has not yet been parsed this will return NULL.\n\n \\see libvlc_media_parse\n \\see libvlc_media_parse_with_options\n \\see libvlc_MediaMetaChanged\n\n \\param p_md the media descriptor\n \\param e_meta the meta to read\n \\return the media's meta"]
    pub fn libvlc_media_get_meta(
        p_md: *mut libvlc_media_t,
        e_meta: libvlc_meta_t,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Set the meta of the media (this function will not save the meta, call\n libvlc_media_save_meta in order to save the meta)\n\n \\param p_md the media descriptor\n \\param e_meta the meta to write\n \\param psz_value the media's meta"]
    pub fn libvlc_media_set_meta(
        p_md: *mut libvlc_media_t,
        e_meta: libvlc_meta_t,
        psz_value: *const libc::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Save the meta previously set\n\n \\param p_md the media desriptor\n \\return true if the write operation was successful"]
    pub fn libvlc_media_save_meta(p_md: *mut libvlc_media_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get current state of media descriptor object. Possible media states are\n libvlc_NothingSpecial=0, libvlc_Opening, libvlc_Playing, libvlc_Paused,\n libvlc_Stopped, libvlc_Ended, libvlc_Error.\n\n \\see libvlc_state_t\n \\param p_md a media descriptor object\n \\return state of media descriptor object"]
    pub fn libvlc_media_get_state(p_md: *mut libvlc_media_t) -> libvlc_state_t;
}
unsafe extern "C" {
    #[doc = " Get the current statistics about the media\n \\param p_md: media descriptor object\n \\param p_stats: structure that contain the statistics about the media\n                 (this structure must be allocated by the caller)\n \\return true if the statistics are available, false otherwise\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_get_stats(
        p_md: *mut libvlc_media_t,
        p_stats: *mut libvlc_media_stats_t,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_list_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get subitems of media descriptor object. This will increment\n the reference count of supplied media descriptor object. Use\n libvlc_media_list_release() to decrement the reference counting.\n\n \\param p_md media descriptor object\n \\return list of media descriptor subitems or NULL"]
    pub fn libvlc_media_subitems(p_md: *mut libvlc_media_t) -> *mut libvlc_media_list_t;
}
unsafe extern "C" {
    #[doc = " Get event manager from media descriptor object.\n NOTE: this function doesn't increment reference counting.\n\n \\param p_md a media descriptor object\n \\return event manager object"]
    pub fn libvlc_media_event_manager(p_md: *mut libvlc_media_t) -> *mut libvlc_event_manager_t;
}
unsafe extern "C" {
    #[doc = " Get duration (in ms) of media descriptor object item.\n\n \\param p_md media descriptor object\n \\return duration of media item or -1 on error"]
    pub fn libvlc_media_get_duration(p_md: *mut libvlc_media_t) -> libvlc_time_t;
}
unsafe extern "C" {
    #[doc = " Parse the media asynchronously with options.\n\n This fetches (local or network) art, meta data and/or tracks information.\n This method is the extended version of libvlc_media_parse_with_options().\n\n To track when this is over you can listen to libvlc_MediaParsedChanged\n event. However if this functions returns an error, you will not receive any\n events.\n\n It uses a flag to specify parse options (see libvlc_media_parse_flag_t). All\n these flags can be combined. By default, media is parsed if it's a local\n file.\n\n \\note Parsing can be aborted with libvlc_media_parse_stop().\n\n \\see libvlc_MediaParsedChanged\n \\see libvlc_media_get_meta\n \\see libvlc_media_tracks_get\n \\see libvlc_media_get_parsed_status\n \\see libvlc_media_parse_flag_t\n\n \\param p_md media descriptor object\n \\param parse_flag parse options:\n \\param timeout maximum time allowed to preparse the media. If -1, the\n default \"preparse-timeout\" option will be used as a timeout. If 0, it will\n wait indefinitely. If > 0, the timeout will be used (in milliseconds).\n \\return -1 in case of error, 0 otherwise\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_parse_with_options(
        p_md: *mut libvlc_media_t,
        parse_flag: libvlc_media_parse_flag_t,
        timeout: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Stop the parsing of the media\n\n When the media parsing is stopped, the libvlc_MediaParsedChanged event will\n be sent with the libvlc_media_parsed_status_timeout status.\n\n \\see libvlc_media_parse_with_options\n\n \\param p_md media descriptor object\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_parse_stop(p_md: *mut libvlc_media_t);
}
unsafe extern "C" {
    #[doc = " Get Parsed status for media descriptor object.\n\n \\see libvlc_MediaParsedChanged\n \\see libvlc_media_parsed_status_t\n\n \\param p_md media descriptor object\n \\return a value of the libvlc_media_parsed_status_t enum\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_get_parsed_status(
        p_md: *mut libvlc_media_t,
    ) -> libvlc_media_parsed_status_t;
}
unsafe extern "C" {
    #[doc = " Sets media descriptor's user_data. user_data is specialized data\n accessed by the host application, VLC.framework uses it as a pointer to\n an native object that references a libvlc_media_t pointer\n\n \\param p_md media descriptor object\n \\param p_new_user_data pointer to user data"]
    pub fn libvlc_media_set_user_data(
        p_md: *mut libvlc_media_t,
        p_new_user_data: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get media descriptor's user_data. user_data is specialized data\n accessed by the host application, VLC.framework uses it as a pointer to\n an native object that references a libvlc_media_t pointer\n\n \\param p_md media descriptor object"]
    pub fn libvlc_media_get_user_data(p_md: *mut libvlc_media_t) -> *mut libc::c_void;
}
unsafe extern "C" {
    #[doc = " Get media descriptor's elementary streams description\n\n Note, you need to call libvlc_media_parse() or play the media at least once\n before calling this function.\n Not doing this will result in an empty array.\n\n \\version LibVLC 2.1.0 and later.\n\n \\param p_md media descriptor object\n \\param tracks address to store an allocated array of Elementary Streams\n        descriptions (must be freed with libvlc_media_tracks_release\nby the caller) [OUT]\n\n \\return the number of Elementary Streams (zero on error)"]
    pub fn libvlc_media_tracks_get(
        p_md: *mut libvlc_media_t,
        tracks: *mut *mut *mut libvlc_media_track_t,
    ) -> libc::c_uint;
}
unsafe extern "C" {
    #[doc = " Get codec description from media elementary stream\n\n \\version LibVLC 3.0.0 and later.\n\n \\see libvlc_media_track_t\n\n \\param i_type i_type from libvlc_media_track_t\n \\param i_codec i_codec or i_original_fourcc from libvlc_media_track_t\n\n \\return codec description"]
    pub fn libvlc_media_get_codec_description(
        i_type: libvlc_track_type_t,
        i_codec: u32,
    ) -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Release media descriptor's elementary streams description array\n\n \\version LibVLC 2.1.0 and later.\n\n \\param p_tracks tracks info array to release\n \\param i_count number of elements in the array"]
    pub fn libvlc_media_tracks_release(
        p_tracks: *mut *mut libvlc_media_track_t,
        i_count: libc::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Get the media type of the media descriptor object\n\n \\version LibVLC 3.0.0 and later.\n\n \\see libvlc_media_type_t\n\n \\param p_md media descriptor object\n\n \\return media type"]
    pub fn libvlc_media_get_type(p_md: *mut libvlc_media_t) -> libvlc_media_type_t;
}
unsafe extern "C" {
    #[doc = " Add a slave to the current media.\n\n A slave is an external input source that may contains an additional subtitle\n track (like a .srt) or an additional audio track (like a .ac3).\n\n \\note This function must be called before the media is parsed (via\n libvlc_media_parse_with_options()) or before the media is played (via\n libvlc_media_player_play())\n\n \\version LibVLC 3.0.0 and later.\n\n \\param p_md media descriptor object\n \\param i_type subtitle or audio\n \\param i_priority from 0 (low priority) to 4 (high priority)\n \\param psz_uri Uri of the slave (should contain a valid scheme).\n\n \\return 0 on success, -1 on error."]
    pub fn libvlc_media_slaves_add(
        p_md: *mut libvlc_media_t,
        i_type: libvlc_media_slave_type_t,
        i_priority: libc::c_uint,
        psz_uri: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Clear all slaves previously added by libvlc_media_slaves_add() or\n internally.\n\n \\version LibVLC 3.0.0 and later.\n\n \\param p_md media descriptor object"]
    pub fn libvlc_media_slaves_clear(p_md: *mut libvlc_media_t);
}
unsafe extern "C" {
    #[doc = " Get a media descriptor's slave list\n\n The list will contain slaves parsed by VLC or previously added by\n libvlc_media_slaves_add(). The typical use case of this function is to save\n a list of slave in a database for a later use.\n\n \\version LibVLC 3.0.0 and later.\n\n \\see libvlc_media_slaves_add\n\n \\param p_md media descriptor object\n \\param ppp_slaves address to store an allocated array of slaves (must be\n freed with libvlc_media_slaves_release()) [OUT]\n\n \\return the number of slaves (zero on error)"]
    pub fn libvlc_media_slaves_get(
        p_md: *mut libvlc_media_t,
        ppp_slaves: *mut *mut *mut libvlc_media_slave_t,
    ) -> libc::c_uint;
}
unsafe extern "C" {
    #[doc = " Release a media descriptor's slave list\n\n \\version LibVLC 3.0.0 and later.\n\n \\param pp_slaves slave array to release\n \\param i_count number of elements in the array"]
    pub fn libvlc_media_slaves_release(
        pp_slaves: *mut *mut libvlc_media_slave_t,
        i_count: libc::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_player_t {
    _unused: [u8; 0],
}
#[doc = " Description for video, audio tracks and subtitles. It contains\n id, name (description string) and pointer to next record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_track_description_t {
    pub i_id: libc::c_int,
    pub psz_name: *mut libc::c_char,
    pub p_next: *mut libvlc_track_description_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_track_description_t"]
        [::core::mem::size_of::<libvlc_track_description_t>() - 24usize];
    ["Alignment of libvlc_track_description_t"]
        [::core::mem::align_of::<libvlc_track_description_t>() - 8usize];
    ["Offset of field: libvlc_track_description_t::i_id"]
        [::core::mem::offset_of!(libvlc_track_description_t, i_id) - 0usize];
    ["Offset of field: libvlc_track_description_t::psz_name"]
        [::core::mem::offset_of!(libvlc_track_description_t, psz_name) - 8usize];
    ["Offset of field: libvlc_track_description_t::p_next"]
        [::core::mem::offset_of!(libvlc_track_description_t, p_next) - 16usize];
};
pub const libvlc_title_menu: _bindgen_ty_2 = 1;
pub const libvlc_title_interactive: _bindgen_ty_2 = 2;
#[doc = " Description for titles"]
pub type _bindgen_ty_2 = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_title_description_t {
    #[doc = "< duration in milliseconds"]
    pub i_duration: i64,
    #[doc = "< title name"]
    pub psz_name: *mut libc::c_char,
    #[doc = "< info if item was recognized as a menu, interactive or plain content by the demuxer"]
    pub i_flags: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_title_description_t"]
        [::core::mem::size_of::<libvlc_title_description_t>() - 24usize];
    ["Alignment of libvlc_title_description_t"]
        [::core::mem::align_of::<libvlc_title_description_t>() - 8usize];
    ["Offset of field: libvlc_title_description_t::i_duration"]
        [::core::mem::offset_of!(libvlc_title_description_t, i_duration) - 0usize];
    ["Offset of field: libvlc_title_description_t::psz_name"]
        [::core::mem::offset_of!(libvlc_title_description_t, psz_name) - 8usize];
    ["Offset of field: libvlc_title_description_t::i_flags"]
        [::core::mem::offset_of!(libvlc_title_description_t, i_flags) - 16usize];
};
#[doc = " Description for chapters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_chapter_description_t {
    #[doc = "< time-offset of the chapter in milliseconds"]
    pub i_time_offset: i64,
    #[doc = "< duration of the chapter in milliseconds"]
    pub i_duration: i64,
    #[doc = "< chapter name"]
    pub psz_name: *mut libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_chapter_description_t"]
        [::core::mem::size_of::<libvlc_chapter_description_t>() - 24usize];
    ["Alignment of libvlc_chapter_description_t"]
        [::core::mem::align_of::<libvlc_chapter_description_t>() - 8usize];
    ["Offset of field: libvlc_chapter_description_t::i_time_offset"]
        [::core::mem::offset_of!(libvlc_chapter_description_t, i_time_offset) - 0usize];
    ["Offset of field: libvlc_chapter_description_t::i_duration"]
        [::core::mem::offset_of!(libvlc_chapter_description_t, i_duration) - 8usize];
    ["Offset of field: libvlc_chapter_description_t::psz_name"]
        [::core::mem::offset_of!(libvlc_chapter_description_t, psz_name) - 16usize];
};
#[doc = " Description for audio output. It contains\n name, description and pointer to next record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_audio_output_t {
    pub psz_name: *mut libc::c_char,
    pub psz_description: *mut libc::c_char,
    pub p_next: *mut libvlc_audio_output_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_audio_output_t"][::core::mem::size_of::<libvlc_audio_output_t>() - 24usize];
    ["Alignment of libvlc_audio_output_t"]
        [::core::mem::align_of::<libvlc_audio_output_t>() - 8usize];
    ["Offset of field: libvlc_audio_output_t::psz_name"]
        [::core::mem::offset_of!(libvlc_audio_output_t, psz_name) - 0usize];
    ["Offset of field: libvlc_audio_output_t::psz_description"]
        [::core::mem::offset_of!(libvlc_audio_output_t, psz_description) - 8usize];
    ["Offset of field: libvlc_audio_output_t::p_next"]
        [::core::mem::offset_of!(libvlc_audio_output_t, p_next) - 16usize];
};
#[doc = " Description for audio output device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_audio_output_device_t {
    #[doc = "< Next entry in list"]
    pub p_next: *mut libvlc_audio_output_device_t,
    #[doc = "< Device identifier string"]
    pub psz_device: *mut libc::c_char,
    #[doc = "< User-friendly device description"]
    pub psz_description: *mut libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_audio_output_device_t"]
        [::core::mem::size_of::<libvlc_audio_output_device_t>() - 24usize];
    ["Alignment of libvlc_audio_output_device_t"]
        [::core::mem::align_of::<libvlc_audio_output_device_t>() - 8usize];
    ["Offset of field: libvlc_audio_output_device_t::p_next"]
        [::core::mem::offset_of!(libvlc_audio_output_device_t, p_next) - 0usize];
    ["Offset of field: libvlc_audio_output_device_t::psz_device"]
        [::core::mem::offset_of!(libvlc_audio_output_device_t, psz_device) - 8usize];
    ["Offset of field: libvlc_audio_output_device_t::psz_description"]
        [::core::mem::offset_of!(libvlc_audio_output_device_t, psz_description) - 16usize];
};
pub const libvlc_video_marquee_option_t_libvlc_marquee_Enable: libvlc_video_marquee_option_t = 0;
pub const libvlc_video_marquee_option_t_libvlc_marquee_Text: libvlc_video_marquee_option_t = 1;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Color: libvlc_video_marquee_option_t = 2;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Opacity: libvlc_video_marquee_option_t = 3;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Position: libvlc_video_marquee_option_t = 4;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Refresh: libvlc_video_marquee_option_t = 5;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Size: libvlc_video_marquee_option_t = 6;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Timeout: libvlc_video_marquee_option_t = 7;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_X: libvlc_video_marquee_option_t = 8;
#[doc = " string argument"]
pub const libvlc_video_marquee_option_t_libvlc_marquee_Y: libvlc_video_marquee_option_t = 9;
#[doc = " Marq options definition"]
pub type libvlc_video_marquee_option_t = libc::c_uint;
pub const libvlc_navigate_mode_t_libvlc_navigate_activate: libvlc_navigate_mode_t = 0;
pub const libvlc_navigate_mode_t_libvlc_navigate_up: libvlc_navigate_mode_t = 1;
pub const libvlc_navigate_mode_t_libvlc_navigate_down: libvlc_navigate_mode_t = 2;
pub const libvlc_navigate_mode_t_libvlc_navigate_left: libvlc_navigate_mode_t = 3;
pub const libvlc_navigate_mode_t_libvlc_navigate_right: libvlc_navigate_mode_t = 4;
pub const libvlc_navigate_mode_t_libvlc_navigate_popup: libvlc_navigate_mode_t = 5;
#[doc = " Navigation mode"]
pub type libvlc_navigate_mode_t = libc::c_uint;
pub const libvlc_position_t_libvlc_position_disable: libvlc_position_t = -1;
pub const libvlc_position_t_libvlc_position_center: libvlc_position_t = 0;
pub const libvlc_position_t_libvlc_position_left: libvlc_position_t = 1;
pub const libvlc_position_t_libvlc_position_right: libvlc_position_t = 2;
pub const libvlc_position_t_libvlc_position_top: libvlc_position_t = 3;
pub const libvlc_position_t_libvlc_position_top_left: libvlc_position_t = 4;
pub const libvlc_position_t_libvlc_position_top_right: libvlc_position_t = 5;
pub const libvlc_position_t_libvlc_position_bottom: libvlc_position_t = 6;
pub const libvlc_position_t_libvlc_position_bottom_left: libvlc_position_t = 7;
pub const libvlc_position_t_libvlc_position_bottom_right: libvlc_position_t = 8;
#[doc = " Enumeration of values used to set position (e.g. of video title)."]
pub type libvlc_position_t = libc::c_int;
pub const libvlc_teletext_key_t_libvlc_teletext_key_red: libvlc_teletext_key_t = 7471104;
pub const libvlc_teletext_key_t_libvlc_teletext_key_green: libvlc_teletext_key_t = 6750208;
pub const libvlc_teletext_key_t_libvlc_teletext_key_yellow: libvlc_teletext_key_t = 7929856;
pub const libvlc_teletext_key_t_libvlc_teletext_key_blue: libvlc_teletext_key_t = 6422528;
pub const libvlc_teletext_key_t_libvlc_teletext_key_index: libvlc_teletext_key_t = 6881280;
#[doc = " Enumeration of teletext keys than can be passed via\n libvlc_video_set_teletext()"]
pub type libvlc_teletext_key_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_equalizer_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Create an empty Media Player object\n\n \\param p_libvlc_instance the libvlc instance in which the Media Player\n        should be created.\n \\return a new media player object, or NULL on error."]
    pub fn libvlc_media_player_new(
        p_libvlc_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_media_player_t;
}
unsafe extern "C" {
    #[doc = " Create a Media Player object from a Media\n\n \\param p_md the media. Afterwards the p_md can be safely\n        destroyed.\n \\return a new media player object, or NULL on error."]
    pub fn libvlc_media_player_new_from_media(
        p_md: *mut libvlc_media_t,
    ) -> *mut libvlc_media_player_t;
}
unsafe extern "C" {
    #[doc = " Release a media_player after use\n Decrement the reference count of a media player object. If the\n reference count is 0, then libvlc_media_player_release() will\n release the media player object. If the media player object\n has been released, then it should not be used again.\n\n \\param p_mi the Media Player to free"]
    pub fn libvlc_media_player_release(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Retain a reference to a media player object. Use\n libvlc_media_player_release() to decrement reference count.\n\n \\param p_mi media player object"]
    pub fn libvlc_media_player_retain(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Set the media that will be used by the media_player. If any,\n previous md will be released.\n\n \\param p_mi the Media Player\n \\param p_md the Media. Afterwards the p_md can be safely\n        destroyed."]
    pub fn libvlc_media_player_set_media(
        p_mi: *mut libvlc_media_player_t,
        p_md: *mut libvlc_media_t,
    );
}
unsafe extern "C" {
    #[doc = " Get the media used by the media_player.\n\n \\param p_mi the Media Player\n \\return the media associated with p_mi, or NULL if no\n         media is associated"]
    pub fn libvlc_media_player_get_media(p_mi: *mut libvlc_media_player_t) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Get the Event Manager from which the media player send event.\n\n \\param p_mi the Media Player\n \\return the event manager associated with p_mi"]
    pub fn libvlc_media_player_event_manager(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_event_manager_t;
}
unsafe extern "C" {
    #[doc = " is_playing\n\n \\param p_mi the Media Player\n \\return 1 if the media player is playing, 0 otherwise\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_player_is_playing(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Play\n\n \\param p_mi the Media Player\n \\return 0 if playback started (and was already started), or -1 on error."]
    pub fn libvlc_media_player_play(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Pause or resume (no effect if there is no media)\n\n \\param mp the Media Player\n \\param do_pause play/resume if zero, pause if non-zero\n \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_media_player_set_pause(mp: *mut libvlc_media_player_t, do_pause: libc::c_int);
}
unsafe extern "C" {
    #[doc = " Toggle pause (no effect if there is no media)\n\n \\param p_mi the Media Player"]
    pub fn libvlc_media_player_pause(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Stop (no effect if there is no media)\n\n \\param p_mi the Media Player"]
    pub fn libvlc_media_player_stop(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Set a renderer to the media player\n\n \\note must be called before the first call of libvlc_media_player_play() to\n take effect.\n\n \\see libvlc_renderer_discoverer_new\n\n \\param p_mi the Media Player\n \\param p_item an item discovered by libvlc_renderer_discoverer_start()\n \\return 0 on success, -1 on error.\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_player_set_renderer(
        p_mi: *mut libvlc_media_player_t,
        p_item: *mut libvlc_renderer_item_t,
    ) -> libc::c_int;
}
#[doc = " Callback prototype to allocate and lock a picture buffer.\n\n Whenever a new video frame needs to be decoded, the lock callback is\n invoked. Depending on the video chroma, one or three pixel planes of\n adequate dimensions must be returned via the second parameter. Those\n planes must be aligned on 32-bytes boundaries.\n\n \\param opaque private pointer as passed to libvlc_video_set_callbacks() [IN]\n \\param planes start address of the pixel planes (LibVLC allocates the array\n             of void pointers, this callback must initialize the array) [OUT]\n \\return a private pointer for the display and unlock callbacks to identify\n         the picture buffers"]
pub type libvlc_video_lock_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        planes: *mut *mut libc::c_void,
    ) -> *mut libc::c_void,
>;
#[doc = " Callback prototype to unlock a picture buffer.\n\n When the video frame decoding is complete, the unlock callback is invoked.\n This callback might not be needed at all. It is only an indication that the\n application can now read the pixel values if it needs to.\n\n \\note A picture buffer is unlocked after the picture is decoded,\n but before the picture is displayed.\n\n \\param opaque private pointer as passed to libvlc_video_set_callbacks() [IN]\n \\param picture private pointer returned from the @ref libvlc_video_lock_cb\n                callback [IN]\n \\param planes pixel planes as defined by the @ref libvlc_video_lock_cb\n               callback (this parameter is only for convenience) [IN]"]
pub type libvlc_video_unlock_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        picture: *mut libc::c_void,
        planes: *const *mut libc::c_void,
    ),
>;
#[doc = " Callback prototype to display a picture.\n\n When the video frame needs to be shown, as determined by the media playback\n clock, the display callback is invoked.\n\n \\param opaque private pointer as passed to libvlc_video_set_callbacks() [IN]\n \\param picture private pointer returned from the @ref libvlc_video_lock_cb\n                callback [IN]"]
pub type libvlc_video_display_cb = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, picture: *mut libc::c_void),
>;
#[doc = " Callback prototype to configure picture buffers format.\n This callback gets the format of the video as output by the video decoder\n and the chain of video filters (if any). It can opt to change any parameter\n as it needs. In that case, LibVLC will attempt to convert the video format\n (rescaling and chroma conversion) but these operations can be CPU intensive.\n\n \\param opaque pointer to the private pointer passed to\n               libvlc_video_set_callbacks() [IN/OUT]\n \\param chroma pointer to the 4 bytes video format identifier [IN/OUT]\n \\param width pointer to the pixel width [IN/OUT]\n \\param height pointer to the pixel height [IN/OUT]\n \\param pitches table of scanline pitches in bytes for each pixel plane\n                (the table is allocated by LibVLC) [OUT]\n \\param lines table of scanlines count for each plane [OUT]\n \\return the number of picture buffers allocated, 0 indicates failure\n\n \\note\n For each pixels plane, the scanline pitch must be bigger than or equal to\n the number of bytes per pixel multiplied by the pixel width.\n Similarly, the number of scanlines must be bigger than of equal to\n the pixel height.\n Furthermore, we recommend that pitches and lines be multiple of 32\n to not break assumptions that might be held by optimized code\n in the video decoders, video filters and/or video converters."]
pub type libvlc_video_format_cb = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut *mut libc::c_void,
        chroma: *mut libc::c_char,
        width: *mut libc::c_uint,
        height: *mut libc::c_uint,
        pitches: *mut libc::c_uint,
        lines: *mut libc::c_uint,
    ) -> libc::c_uint,
>;
#[doc = " Callback prototype to configure picture buffers format.\n\n \\param opaque private pointer as passed to libvlc_video_set_callbacks()\n               (and possibly modified by @ref libvlc_video_format_cb) [IN]"]
pub type libvlc_video_cleanup_cb =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>;
unsafe extern "C" {
    #[doc = " Set callbacks and private data to render decoded video to a custom area\n in memory.\n Use libvlc_video_set_format() or libvlc_video_set_format_callbacks()\n to configure the decoded format.\n\n \\warning Rendering video into custom memory buffers is considerably less\n efficient than rendering in a custom window as normal.\n\n For optimal perfomances, VLC media player renders into a custom window, and\n does not use this function and associated callbacks. It is <b>highly\n recommended</b> that other LibVLC-based application do likewise.\n To embed video in a window, use libvlc_media_player_set_xid() or equivalent\n depending on the operating system.\n\n If window embedding does not fit the application use case, then a custom\n LibVLC video output display plugin is required to maintain optimal video\n rendering performances.\n\n The following limitations affect performance:\n - Hardware video decoding acceleration will either be disabled completely,\n   or require (relatively slow) copy from video/DSP memory to main memory.\n - Sub-pictures (subtitles, on-screen display, etc.) must be blent into the\n   main picture by the CPU instead of the GPU.\n - Depending on the video format, pixel format conversion, picture scaling,\n   cropping and/or picture re-orientation, must be performed by the CPU\n   instead of the GPU.\n - Memory copying is required between LibVLC reference picture buffers and\n   application buffers (between lock and unlock callbacks).\n\n \\param mp the media player\n \\param lock callback to lock video memory (must not be NULL)\n \\param unlock callback to unlock video memory (or NULL if not needed)\n \\param display callback to display video (or NULL if not needed)\n \\param opaque private pointer for the three callbacks (as first parameter)\n \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_video_set_callbacks(
        mp: *mut libvlc_media_player_t,
        lock: libvlc_video_lock_cb,
        unlock: libvlc_video_unlock_cb,
        display: libvlc_video_display_cb,
        opaque: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set decoded video chroma and dimensions.\n This only works in combination with libvlc_video_set_callbacks(),\n and is mutually exclusive with libvlc_video_set_format_callbacks().\n\n \\param mp the media player\n \\param chroma a four-characters string identifying the chroma\n               (e.g. \"RV32\" or \"YUYV\")\n \\param width pixel width\n \\param height pixel height\n \\param pitch line pitch (in bytes)\n \\version LibVLC 1.1.1 or later\n \\bug All pixel planes are expected to have the same pitch.\n To use the YCbCr color space with chrominance subsampling,\n consider using libvlc_video_set_format_callbacks() instead."]
    pub fn libvlc_video_set_format(
        mp: *mut libvlc_media_player_t,
        chroma: *const libc::c_char,
        width: libc::c_uint,
        height: libc::c_uint,
        pitch: libc::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Set decoded video chroma and dimensions. This only works in combination with\n libvlc_video_set_callbacks().\n\n \\param mp the media player\n \\param setup callback to select the video format (cannot be NULL)\n \\param cleanup callback to release any allocated resources (or NULL)\n \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_video_set_format_callbacks(
        mp: *mut libvlc_media_player_t,
        setup: libvlc_video_format_cb,
        cleanup: libvlc_video_cleanup_cb,
    );
}
unsafe extern "C" {
    #[doc = " Set the NSView handler where the media player should render its video output.\n\n Use the vout called \"macosx\".\n\n The drawable is an NSObject that follow the VLCOpenGLVideoViewEmbedding\n protocol:\n\n @code{.m}\n \\@protocol VLCOpenGLVideoViewEmbedding <NSObject>\n - (void)addVoutSubview:(NSView *)view;\n - (void)removeVoutSubview:(NSView *)view;\n \\@end\n @endcode\n\n Or it can be an NSView object.\n\n If you want to use it along with Qt see the QMacCocoaViewContainer. Then\n the following code should work:\n @code{.mm}\n {\n     NSView *video = [[NSView alloc] init];\n     QMacCocoaViewContainer *container = new QMacCocoaViewContainer(video, parent);\n     libvlc_media_player_set_nsobject(mp, video);\n     [video release];\n }\n @endcode\n\n You can find a live example in VLCVideoView in VLCKit.framework.\n\n \\param p_mi the Media Player\n \\param drawable the drawable that is either an NSView or an object following\n the VLCOpenGLVideoViewEmbedding protocol."]
    pub fn libvlc_media_player_set_nsobject(
        p_mi: *mut libvlc_media_player_t,
        drawable: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the NSView handler previously set with libvlc_media_player_set_nsobject().\n\n \\param p_mi the Media Player\n \\return the NSView handler or 0 if none where set"]
    pub fn libvlc_media_player_get_nsobject(p_mi: *mut libvlc_media_player_t) -> *mut libc::c_void;
}
unsafe extern "C" {
    #[doc = " Set an X Window System drawable where the media player should render its\n video output. The call takes effect when the playback starts. If it is\n already started, it might need to be stopped before changes apply.\n If LibVLC was built without X11 output support, then this function has no\n effects.\n\n By default, LibVLC will capture input events on the video rendering area.\n Use libvlc_video_set_mouse_input() and libvlc_video_set_key_input() to\n disable that and deliver events to the parent window / to the application\n instead. By design, the X11 protocol delivers input events to only one\n recipient.\n\n \\warning\n The application must call the XInitThreads() function from Xlib before\n libvlc_new(), and before any call to XOpenDisplay() directly or via any\n other library. Failure to call XInitThreads() will seriously impede LibVLC\n performance. Calling XOpenDisplay() before XInitThreads() will eventually\n crash the process. That is a limitation of Xlib.\n\n \\param p_mi media player\n \\param drawable X11 window ID\n\n \\note\n The specified identifier must correspond to an existing Input/Output class\n X11 window. Pixmaps are <b>not</b> currently supported. The default X11\n server is assumed, i.e. that specified in the DISPLAY environment variable.\n\n \\warning\n LibVLC can deal with invalid X11 handle errors, however some display drivers\n (EGL, GLX, VA and/or VDPAU) can unfortunately not. Thus the window handle\n must remain valid until playback is stopped, otherwise the process may\n abort or crash.\n\n \\bug\n No more than one window handle per media player instance can be specified.\n If the media has multiple simultaneously active video tracks, extra tracks\n will be rendered into external windows beyond the control of the\n application."]
    pub fn libvlc_media_player_set_xwindow(p_mi: *mut libvlc_media_player_t, drawable: u32);
}
unsafe extern "C" {
    #[doc = " Get the X Window System window identifier previously set with\n libvlc_media_player_set_xwindow(). Note that this will return the identifier\n even if VLC is not currently using it (for instance if it is playing an\n audio-only input).\n\n \\param p_mi the Media Player\n \\return an X window ID, or 0 if none where set."]
    pub fn libvlc_media_player_get_xwindow(p_mi: *mut libvlc_media_player_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Set a Win32/Win64 API window handle (HWND) where the media player should\n render its video output. If LibVLC was built without Win32/Win64 API output\n support, then this has no effects.\n\n \\param p_mi the Media Player\n \\param drawable windows handle of the drawable"]
    pub fn libvlc_media_player_set_hwnd(
        p_mi: *mut libvlc_media_player_t,
        drawable: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the Windows API window handle (HWND) previously set with\n libvlc_media_player_set_hwnd(). The handle will be returned even if LibVLC\n is not currently outputting any video to it.\n\n \\param p_mi the Media Player\n \\return a window handle or NULL if there are none."]
    pub fn libvlc_media_player_get_hwnd(p_mi: *mut libvlc_media_player_t) -> *mut libc::c_void;
}
unsafe extern "C" {
    #[doc = " Set the android context.\n\n \\version LibVLC 3.0.0 and later.\n\n \\param p_mi the media player\n \\param p_awindow_handler org.videolan.libvlc.AWindow jobject owned by the\n        org.videolan.libvlc.MediaPlayer class from the libvlc-android project."]
    pub fn libvlc_media_player_set_android_context(
        p_mi: *mut libvlc_media_player_t,
        p_awindow_handler: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set the EFL Evas Object.\n\n \\version LibVLC 3.0.0 and later.\n\n \\param p_mi the media player\n \\param p_evas_object a valid EFL Evas Object (Evas_Object)\n \\return -1 if an error was detected, 0 otherwise."]
    pub fn libvlc_media_player_set_evas_object(
        p_mi: *mut libvlc_media_player_t,
        p_evas_object: *mut libc::c_void,
    ) -> libc::c_int;
}
#[doc = " Callback prototype for audio playback.\n\n The LibVLC media player decodes and post-processes the audio signal\n asynchronously (in an internal thread). Whenever audio samples are ready\n to be queued to the output, this callback is invoked.\n\n The number of samples provided per invocation may depend on the file format,\n the audio coding algorithm, the decoder plug-in, the post-processing\n filters and timing. Application must not assume a certain number of samples.\n\n The exact format of audio samples is determined by libvlc_audio_set_format()\n or libvlc_audio_set_format_callbacks() as is the channels layout.\n\n Note that the number of samples is per channel. For instance, if the audio\n track sampling rate is 48000 Hz, then 1200 samples represent 25 milliseconds\n of audio signal - regardless of the number of audio channels.\n\n \\param data data pointer as passed to libvlc_audio_set_callbacks() [IN]\n \\param samples pointer to a table of audio samples to play back [IN]\n \\param count number of audio samples to play back\n \\param pts expected play time stamp (see libvlc_delay())"]
pub type libvlc_audio_play_cb = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut libc::c_void,
        samples: *const libc::c_void,
        count: libc::c_uint,
        pts: i64,
    ),
>;
#[doc = " Callback prototype for audio pause.\n\n LibVLC invokes this callback to pause audio playback.\n\n \\note The pause callback is never called if the audio is already paused.\n \\param data data pointer as passed to libvlc_audio_set_callbacks() [IN]\n \\param pts time stamp of the pause request (should be elapsed already)"]
pub type libvlc_audio_pause_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void, pts: i64)>;
#[doc = " Callback prototype for audio resumption.\n\n LibVLC invokes this callback to resume audio playback after it was\n previously paused.\n\n \\note The resume callback is never called if the audio is not paused.\n \\param data data pointer as passed to libvlc_audio_set_callbacks() [IN]\n \\param pts time stamp of the resumption request (should be elapsed already)"]
pub type libvlc_audio_resume_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void, pts: i64)>;
#[doc = " Callback prototype for audio buffer flush.\n\n LibVLC invokes this callback if it needs to discard all pending buffers and\n stop playback as soon as possible. This typically occurs when the media is\n stopped.\n\n \\param data data pointer as passed to libvlc_audio_set_callbacks() [IN]"]
pub type libvlc_audio_flush_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void, pts: i64)>;
#[doc = " Callback prototype for audio buffer drain.\n\n LibVLC may invoke this callback when the decoded audio track is ending.\n There will be no further decoded samples for the track, but playback should\n nevertheless continue until all already pending buffers are rendered.\n\n \\param data data pointer as passed to libvlc_audio_set_callbacks() [IN]"]
pub type libvlc_audio_drain_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
#[doc = " Callback prototype for audio volume change.\n \\param data data pointer as passed to libvlc_audio_set_callbacks() [IN]\n \\param volume software volume (1. = nominal, 0. = mute)\n \\param mute muted flag"]
pub type libvlc_audio_set_volume_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void, volume: f32, mute: bool)>;
unsafe extern "C" {
    #[doc = " Sets callbacks and private data for decoded audio.\n\n Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()\n to configure the decoded audio format.\n\n \\note The audio callbacks override any other audio output mechanism.\n If the callbacks are set, LibVLC will <b>not</b> output audio in any way.\n\n \\param mp the media player\n \\param play callback to play audio samples (must not be NULL)\n \\param pause callback to pause playback (or NULL to ignore)\n \\param resume callback to resume playback (or NULL to ignore)\n \\param flush callback to flush audio buffers (or NULL to ignore)\n \\param drain callback to drain audio buffers (or NULL to ignore)\n \\param opaque private pointer for the audio callbacks (as first parameter)\n \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_audio_set_callbacks(
        mp: *mut libvlc_media_player_t,
        play: libvlc_audio_play_cb,
        pause: libvlc_audio_pause_cb,
        resume: libvlc_audio_resume_cb,
        flush: libvlc_audio_flush_cb,
        drain: libvlc_audio_drain_cb,
        opaque: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set callbacks and private data for decoded audio. This only works in\n combination with libvlc_audio_set_callbacks().\n Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()\n to configure the decoded audio format.\n\n \\param mp the media player\n \\param set_volume callback to apply audio volume,\n                   or NULL to apply volume in software\n \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_audio_set_volume_callback(
        mp: *mut libvlc_media_player_t,
        set_volume: libvlc_audio_set_volume_cb,
    );
}
#[doc = " Callback prototype to setup the audio playback.\n\n This is called when the media player needs to create a new audio output.\n \\param opaque pointer to the data pointer passed to\n               libvlc_audio_set_callbacks() [IN/OUT]\n \\param format 4 bytes sample format [IN/OUT]\n \\param rate sample rate [IN/OUT]\n \\param channels channels count [IN/OUT]\n \\return 0 on success, anything else to skip audio playback"]
pub type libvlc_audio_setup_cb = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut *mut libc::c_void,
        format: *mut libc::c_char,
        rate: *mut libc::c_uint,
        channels: *mut libc::c_uint,
    ) -> libc::c_int,
>;
#[doc = " Callback prototype for audio playback cleanup.\n\n This is called when the media player no longer needs an audio output.\n \\param opaque data pointer as passed to libvlc_audio_set_callbacks() [IN]"]
pub type libvlc_audio_cleanup_cb =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
unsafe extern "C" {
    #[doc = " Sets decoded audio format via callbacks.\n\n This only works in combination with libvlc_audio_set_callbacks().\n\n \\param mp the media player\n \\param setup callback to select the audio format (cannot be NULL)\n \\param cleanup callback to release any allocated resources (or NULL)\n \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_audio_set_format_callbacks(
        mp: *mut libvlc_media_player_t,
        setup: libvlc_audio_setup_cb,
        cleanup: libvlc_audio_cleanup_cb,
    );
}
unsafe extern "C" {
    #[doc = " Sets a fixed decoded audio format.\n\n This only works in combination with libvlc_audio_set_callbacks(),\n and is mutually exclusive with libvlc_audio_set_format_callbacks().\n\n \\param mp the media player\n \\param format a four-characters string identifying the sample format\n               (e.g. \"S16N\" or \"f32l\")\n \\param rate sample rate (expressed in Hz)\n \\param channels channels count\n \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_audio_set_format(
        mp: *mut libvlc_media_player_t,
        format: *const libc::c_char,
        rate: libc::c_uint,
        channels: libc::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Get the current movie length (in ms).\n\n \\param p_mi the Media Player\n \\return the movie length (in ms), or -1 if there is no media."]
    pub fn libvlc_media_player_get_length(p_mi: *mut libvlc_media_player_t) -> libvlc_time_t;
}
unsafe extern "C" {
    #[doc = " Get the current movie time (in ms).\n\n \\param p_mi the Media Player\n \\return the movie time (in ms), or -1 if there is no media."]
    pub fn libvlc_media_player_get_time(p_mi: *mut libvlc_media_player_t) -> libvlc_time_t;
}
unsafe extern "C" {
    #[doc = " Set the movie time (in ms). This has no effect if no media is being played.\n Not all formats and protocols support this.\n\n \\param p_mi the Media Player\n \\param i_time the movie time (in ms)."]
    pub fn libvlc_media_player_set_time(p_mi: *mut libvlc_media_player_t, i_time: libvlc_time_t);
}
unsafe extern "C" {
    #[doc = " Get movie position as percentage between 0.0 and 1.0.\n\n \\param p_mi the Media Player\n \\return movie position, or -1. in case of error"]
    pub fn libvlc_media_player_get_position(p_mi: *mut libvlc_media_player_t) -> f32;
}
unsafe extern "C" {
    #[doc = " Set movie position as percentage between 0.0 and 1.0.\n This has no effect if playback is not enabled.\n This might not work depending on the underlying input format and protocol.\n\n \\param p_mi the Media Player\n \\param f_pos the position"]
    pub fn libvlc_media_player_set_position(p_mi: *mut libvlc_media_player_t, f_pos: f32);
}
unsafe extern "C" {
    #[doc = " Set movie chapter (if applicable).\n\n \\param p_mi the Media Player\n \\param i_chapter chapter number to play"]
    pub fn libvlc_media_player_set_chapter(
        p_mi: *mut libvlc_media_player_t,
        i_chapter: libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Get movie chapter.\n\n \\param p_mi the Media Player\n \\return chapter number currently playing, or -1 if there is no media."]
    pub fn libvlc_media_player_get_chapter(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get movie chapter count\n\n \\param p_mi the Media Player\n \\return number of chapters in movie, or -1."]
    pub fn libvlc_media_player_get_chapter_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Is the player able to play\n\n \\param p_mi the Media Player\n \\return boolean\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_player_will_play(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get title chapter count\n\n \\param p_mi the Media Player\n \\param i_title title\n \\return number of chapters in title, or -1"]
    pub fn libvlc_media_player_get_chapter_count_for_title(
        p_mi: *mut libvlc_media_player_t,
        i_title: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set movie title\n\n \\param p_mi the Media Player\n \\param i_title title number to play"]
    pub fn libvlc_media_player_set_title(p_mi: *mut libvlc_media_player_t, i_title: libc::c_int);
}
unsafe extern "C" {
    #[doc = " Get movie title\n\n \\param p_mi the Media Player\n \\return title number currently playing, or -1"]
    pub fn libvlc_media_player_get_title(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get movie title count\n\n \\param p_mi the Media Player\n \\return title number count, or -1"]
    pub fn libvlc_media_player_get_title_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set previous chapter (if applicable)\n\n \\param p_mi the Media Player"]
    pub fn libvlc_media_player_previous_chapter(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Set next chapter (if applicable)\n\n \\param p_mi the Media Player"]
    pub fn libvlc_media_player_next_chapter(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Get the requested movie play rate.\n @warning Depending on the underlying media, the requested rate may be\n different from the real playback rate.\n\n \\param p_mi the Media Player\n \\return movie play rate"]
    pub fn libvlc_media_player_get_rate(p_mi: *mut libvlc_media_player_t) -> f32;
}
unsafe extern "C" {
    #[doc = " Set movie play rate\n\n \\param p_mi the Media Player\n \\param rate movie play rate to set\n \\return -1 if an error was detected, 0 otherwise (but even then, it might\n not actually work depending on the underlying media protocol)"]
    pub fn libvlc_media_player_set_rate(p_mi: *mut libvlc_media_player_t, rate: f32)
        -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get current movie state\n\n \\param p_mi the Media Player\n \\return the current state of the media player (playing, paused, ...) \\see libvlc_state_t"]
    pub fn libvlc_media_player_get_state(p_mi: *mut libvlc_media_player_t) -> libvlc_state_t;
}
unsafe extern "C" {
    #[doc = " How many video outputs does this media player have?\n\n \\param p_mi the media player\n \\return the number of video outputs"]
    pub fn libvlc_media_player_has_vout(p_mi: *mut libvlc_media_player_t) -> libc::c_uint;
}
unsafe extern "C" {
    #[doc = " Is this media player seekable?\n\n \\param p_mi the media player\n \\return true if the media player can seek\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_player_is_seekable(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Can this media player be paused?\n\n \\param p_mi the media player\n \\return true if the media player can pause\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_player_can_pause(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the current program is scrambled\n\n \\param p_mi the media player\n \\return true if the current program is scrambled\n\n \\libvlc_return_bool\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_media_player_program_scrambled(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Display the next frame (if supported)\n\n \\param p_mi the media player"]
    pub fn libvlc_media_player_next_frame(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Navigate through DVD Menu\n\n \\param p_mi the Media Player\n \\param navigate the Navigation mode\n \\version libVLC 2.0.0 or later"]
    pub fn libvlc_media_player_navigate(p_mi: *mut libvlc_media_player_t, navigate: libc::c_uint);
}
unsafe extern "C" {
    #[doc = " Set if, and how, the video title will be shown when media is played.\n\n \\param p_mi the media player\n \\param position position at which to display the title, or libvlc_position_disable to prevent the title from being displayed\n \\param timeout title display timeout in milliseconds (ignored if libvlc_position_disable)\n \\version libVLC 2.1.0 or later"]
    pub fn libvlc_media_player_set_video_title_display(
        p_mi: *mut libvlc_media_player_t,
        position: libvlc_position_t,
        timeout: libc::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Add a slave to the current media player.\n\n \\note If the player is playing, the slave will be added directly. This call\n will also update the slave list of the attached libvlc_media_t.\n\n \\version LibVLC 3.0.0 and later.\n\n \\see libvlc_media_slaves_add\n\n \\param p_mi the media player\n \\param i_type subtitle or audio\n \\param psz_uri Uri of the slave (should contain a valid scheme).\n \\param b_select True if this slave should be selected when it's loaded\n\n \\return 0 on success, -1 on error."]
    pub fn libvlc_media_player_add_slave(
        p_mi: *mut libvlc_media_player_t,
        i_type: libvlc_media_slave_type_t,
        psz_uri: *const libc::c_char,
        b_select: bool,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Release (free) libvlc_track_description_t\n\n \\param p_track_description the structure to release"]
    pub fn libvlc_track_description_list_release(
        p_track_description: *mut libvlc_track_description_t,
    );
}
unsafe extern "C" {
    #[doc = " Toggle fullscreen status on non-embedded video outputs.\n\n @warning The same limitations applies to this function\n as to libvlc_set_fullscreen().\n\n \\param p_mi the media player"]
    pub fn libvlc_toggle_fullscreen(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Enable or disable fullscreen.\n\n @warning With most window managers, only a top-level windows can be in\n full-screen mode. Hence, this function will not operate properly if\n libvlc_media_player_set_xwindow() was used to embed the video in a\n non-top-level window. In that case, the embedding window must be reparented\n to the root window <b>before</b> fullscreen mode is enabled. You will want\n to reparent it back to its normal parent when disabling fullscreen.\n\n \\param p_mi the media player\n \\param b_fullscreen boolean for fullscreen status"]
    pub fn libvlc_set_fullscreen(p_mi: *mut libvlc_media_player_t, b_fullscreen: libc::c_int);
}
unsafe extern "C" {
    #[doc = " Get current fullscreen status.\n\n \\param p_mi the media player\n \\return the fullscreen status (boolean)\n\n \\libvlc_return_bool"]
    pub fn libvlc_get_fullscreen(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Enable or disable key press events handling, according to the LibVLC hotkeys\n configuration. By default and for historical reasons, keyboard events are\n handled by the LibVLC video widget.\n\n \\note On X11, there can be only one subscriber for key press and mouse\n click events per window. If your application has subscribed to those events\n for the X window ID of the video widget, then LibVLC will not be able to\n handle key presses and mouse clicks in any case.\n\n \\warning This function is only implemented for X11 and Win32 at the moment.\n\n \\param p_mi the media player\n \\param on true to handle key press events, false to ignore them."]
    pub fn libvlc_video_set_key_input(p_mi: *mut libvlc_media_player_t, on: libc::c_uint);
}
unsafe extern "C" {
    #[doc = " Enable or disable mouse click events handling. By default, those events are\n handled. This is needed for DVD menus to work, as well as a few video\n filters such as \"puzzle\".\n\n \\see libvlc_video_set_key_input().\n\n \\warning This function is only implemented for X11 and Win32 at the moment.\n\n \\param p_mi the media player\n \\param on true to handle mouse click events, false to ignore them."]
    pub fn libvlc_video_set_mouse_input(p_mi: *mut libvlc_media_player_t, on: libc::c_uint);
}
unsafe extern "C" {
    #[doc = " Get the pixel dimensions of a video.\n\n \\param p_mi media player\n \\param num number of the video (starting from, and most commonly 0)\n \\param px pointer to get the pixel width [OUT]\n \\param py pointer to get the pixel height [OUT]\n \\return 0 on success, -1 if the specified video does not exist"]
    pub fn libvlc_video_get_size(
        p_mi: *mut libvlc_media_player_t,
        num: libc::c_uint,
        px: *mut libc::c_uint,
        py: *mut libc::c_uint,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the mouse pointer coordinates over a video.\n Coordinates are expressed in terms of the decoded video resolution,\n <b>not</b> in terms of pixels on the screen/viewport (to get the latter,\n you can query your windowing system directly).\n\n Either of the coordinates may be negative or larger than the corresponding\n dimension of the video, if the cursor is outside the rendering area.\n\n @warning The coordinates may be out-of-date if the pointer is not located\n on the video rendering area. LibVLC does not track the pointer if it is\n outside of the video widget.\n\n @note LibVLC does not support multiple pointers (it does of course support\n multiple input devices sharing the same pointer) at the moment.\n\n \\param p_mi media player\n \\param num number of the video (starting from, and most commonly 0)\n \\param px pointer to get the abscissa [OUT]\n \\param py pointer to get the ordinate [OUT]\n \\return 0 on success, -1 if the specified video does not exist"]
    pub fn libvlc_video_get_cursor(
        p_mi: *mut libvlc_media_player_t,
        num: libc::c_uint,
        px: *mut libc::c_int,
        py: *mut libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current video scaling factor.\n See also libvlc_video_set_scale().\n\n \\param p_mi the media player\n \\return the currently configured zoom factor, or 0. if the video is set\n to fit to the output window/drawable automatically."]
    pub fn libvlc_video_get_scale(p_mi: *mut libvlc_media_player_t) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the video scaling factor. That is the ratio of the number of pixels on\n screen to the number of pixels in the original decoded video in each\n dimension. Zero is a special value; it will adjust the video to the output\n window/drawable (in windowed mode) or the entire screen.\n\n Note that not all video outputs support scaling.\n\n \\param p_mi the media player\n \\param f_factor the scaling factor, or zero"]
    pub fn libvlc_video_set_scale(p_mi: *mut libvlc_media_player_t, f_factor: f32);
}
unsafe extern "C" {
    #[doc = " Get current video aspect ratio.\n\n \\param p_mi the media player\n \\return the video aspect ratio or NULL if unspecified\n (the result must be released with free() or libvlc_free())."]
    pub fn libvlc_video_get_aspect_ratio(p_mi: *mut libvlc_media_player_t) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Set new video aspect ratio.\n\n \\param p_mi the media player\n \\param psz_aspect new video aspect-ratio or NULL to reset to default\n \\note Invalid aspect ratios are ignored."]
    pub fn libvlc_video_set_aspect_ratio(
        p_mi: *mut libvlc_media_player_t,
        psz_aspect: *const libc::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Create a video viewpoint structure.\n\n \\version LibVLC 3.0.0 and later\n\n \\return video viewpoint or NULL\n         (the result must be released with free() or libvlc_free())."]
    pub fn libvlc_video_new_viewpoint() -> *mut libvlc_video_viewpoint_t;
}
unsafe extern "C" {
    #[doc = " Update the video viewpoint information.\n\n \\note It is safe to call this function before the media player is started.\n\n \\version LibVLC 3.0.0 and later\n\n \\param p_mi the media player\n \\param p_viewpoint video viewpoint allocated via libvlc_video_new_viewpoint()\n \\param b_absolute if true replace the old viewpoint with the new one. If\n false, increase/decrease it.\n \\return -1 in case of error, 0 otherwise\n\n \\note the values are set asynchronously, it will be used by the next frame displayed."]
    pub fn libvlc_video_update_viewpoint(
        p_mi: *mut libvlc_media_player_t,
        p_viewpoint: *const libvlc_video_viewpoint_t,
        b_absolute: bool,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get current video subtitle.\n\n \\param p_mi the media player\n \\return the video subtitle selected, or -1 if none"]
    pub fn libvlc_video_get_spu(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of available video subtitles.\n\n \\param p_mi the media player\n \\return the number of available video subtitles"]
    pub fn libvlc_video_get_spu_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the description of available video subtitles.\n\n \\param p_mi the media player\n \\return list containing description of available video subtitles.\n It must be freed with libvlc_track_description_list_release()"]
    pub fn libvlc_video_get_spu_description(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_track_description_t;
}
unsafe extern "C" {
    #[doc = " Set new video subtitle.\n\n \\param p_mi the media player\n \\param i_spu video subtitle track to select (i_id from track description)\n \\return 0 on success, -1 if out of range"]
    pub fn libvlc_video_set_spu(
        p_mi: *mut libvlc_media_player_t,
        i_spu: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current subtitle delay. Positive values means subtitles are being\n displayed later, negative values earlier.\n\n \\param p_mi media player\n \\return time (in microseconds) the display of subtitles is being delayed\n \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_video_get_spu_delay(p_mi: *mut libvlc_media_player_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Set the subtitle delay. This affects the timing of when the subtitle will\n be displayed. Positive values result in subtitles being displayed later,\n while negative values will result in subtitles being displayed earlier.\n\n The subtitle delay will be reset to zero each time the media changes.\n\n \\param p_mi media player\n \\param i_delay time (in microseconds) the display of subtitles should be delayed\n \\return 0 on success, -1 on error\n \\version LibVLC 2.0.0 or later"]
    pub fn libvlc_video_set_spu_delay(
        p_mi: *mut libvlc_media_player_t,
        i_delay: i64,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the full description of available titles\n\n \\version LibVLC 3.0.0 and later.\n\n \\param p_mi the media player\n \\param titles address to store an allocated array of title descriptions\n        descriptions (must be freed with libvlc_title_descriptions_release()\n        by the caller) [OUT]\n\n \\return the number of titles (-1 on error)"]
    pub fn libvlc_media_player_get_full_title_descriptions(
        p_mi: *mut libvlc_media_player_t,
        titles: *mut *mut *mut libvlc_title_description_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Release a title description\n\n \\version LibVLC 3.0.0 and later\n\n \\param p_titles title description array to release\n \\param i_count number of title descriptions to release"]
    pub fn libvlc_title_descriptions_release(
        p_titles: *mut *mut libvlc_title_description_t,
        i_count: libc::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Get the full description of available chapters\n\n \\version LibVLC 3.0.0 and later.\n\n \\param p_mi the media player\n \\param i_chapters_of_title index of the title to query for chapters (uses current title if set to -1)\n \\param pp_chapters address to store an allocated array of chapter descriptions\n        descriptions (must be freed with libvlc_chapter_descriptions_release()\n        by the caller) [OUT]\n\n \\return the number of chapters (-1 on error)"]
    pub fn libvlc_media_player_get_full_chapter_descriptions(
        p_mi: *mut libvlc_media_player_t,
        i_chapters_of_title: libc::c_int,
        pp_chapters: *mut *mut *mut libvlc_chapter_description_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Release a chapter description\n\n \\version LibVLC 3.0.0 and later\n\n \\param p_chapters chapter description array to release\n \\param i_count number of chapter descriptions to release"]
    pub fn libvlc_chapter_descriptions_release(
        p_chapters: *mut *mut libvlc_chapter_description_t,
        i_count: libc::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Get current crop filter geometry.\n\n \\param p_mi the media player\n \\return the crop filter geometry or NULL if unset"]
    pub fn libvlc_video_get_crop_geometry(p_mi: *mut libvlc_media_player_t) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Set new crop filter geometry.\n\n \\param p_mi the media player\n \\param psz_geometry new crop filter geometry (NULL to unset)"]
    pub fn libvlc_video_set_crop_geometry(
        p_mi: *mut libvlc_media_player_t,
        psz_geometry: *const libc::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Get current teletext page requested or 0 if it's disabled.\n\n Teletext is disabled by default, call libvlc_video_set_teletext() to enable\n it.\n\n \\param p_mi the media player\n \\return the current teletext page requested."]
    pub fn libvlc_video_get_teletext(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set new teletext page to retrieve.\n\n This function can also be used to send a teletext key.\n\n \\param p_mi the media player\n \\param i_page teletex page number requested. This value can be 0 to disable\n teletext, a number in the range ]0;1000[ to show the requested page, or a\n \\ref libvlc_teletext_key_t. 100 is the default teletext page."]
    pub fn libvlc_video_set_teletext(p_mi: *mut libvlc_media_player_t, i_page: libc::c_int);
}
unsafe extern "C" {
    #[doc = " Get number of available video tracks.\n\n \\param p_mi media player\n \\return the number of available video tracks (int)"]
    pub fn libvlc_video_get_track_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the description of available video tracks.\n\n \\param p_mi media player\n \\return list with description of available video tracks, or NULL on error.\n It must be freed with libvlc_track_description_list_release()"]
    pub fn libvlc_video_get_track_description(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_track_description_t;
}
unsafe extern "C" {
    #[doc = " Get current video track.\n\n \\param p_mi media player\n \\return the video track ID (int) or -1 if no active input"]
    pub fn libvlc_video_get_track(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set video track.\n\n \\param p_mi media player\n \\param i_track the track ID (i_id field from track description)\n \\return 0 on success, -1 if out of range"]
    pub fn libvlc_video_set_track(
        p_mi: *mut libvlc_media_player_t,
        i_track: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Take a snapshot of the current video window.\n\n If i_width AND i_height is 0, original size is used.\n If i_width XOR i_height is 0, original aspect-ratio is preserved.\n\n \\param p_mi media player instance\n \\param num number of video output (typically 0 for the first/only one)\n \\param psz_filepath the path of a file or a folder to save the screenshot into\n \\param i_width the snapshot's width\n \\param i_height the snapshot's height\n \\return 0 on success, -1 if the video was not found"]
    pub fn libvlc_video_take_snapshot(
        p_mi: *mut libvlc_media_player_t,
        num: libc::c_uint,
        psz_filepath: *const libc::c_char,
        i_width: libc::c_uint,
        i_height: libc::c_uint,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Enable or disable deinterlace filter\n\n \\param p_mi libvlc media player\n \\param psz_mode type of deinterlace filter, NULL to disable"]
    pub fn libvlc_video_set_deinterlace(
        p_mi: *mut libvlc_media_player_t,
        psz_mode: *const libc::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Get an integer marquee option value\n\n \\param p_mi libvlc media player\n \\param option marq option to get \\see libvlc_video_marquee_int_option_t"]
    pub fn libvlc_video_get_marquee_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get a string marquee option value\n\n \\param p_mi libvlc media player\n \\param option marq option to get \\see libvlc_video_marquee_string_option_t"]
    pub fn libvlc_video_get_marquee_string(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Enable, disable or set an integer marquee option\n\n Setting libvlc_marquee_Enable has the side effect of enabling (arg !0)\n or disabling (arg 0) the marq filter.\n\n \\param p_mi libvlc media player\n \\param option marq option to set \\see libvlc_video_marquee_int_option_t\n \\param i_val marq option value"]
    pub fn libvlc_video_set_marquee_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        i_val: libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Set a marquee string option\n\n \\param p_mi libvlc media player\n \\param option marq option to set \\see libvlc_video_marquee_string_option_t\n \\param psz_text marq option value"]
    pub fn libvlc_video_set_marquee_string(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        psz_text: *const libc::c_char,
    );
}
pub const libvlc_video_logo_option_t_libvlc_logo_enable: libvlc_video_logo_option_t = 0;
#[doc = "< string argument, \"file,d,t;file,d,t;...\""]
pub const libvlc_video_logo_option_t_libvlc_logo_file: libvlc_video_logo_option_t = 1;
pub const libvlc_video_logo_option_t_libvlc_logo_x: libvlc_video_logo_option_t = 2;
pub const libvlc_video_logo_option_t_libvlc_logo_y: libvlc_video_logo_option_t = 3;
pub const libvlc_video_logo_option_t_libvlc_logo_delay: libvlc_video_logo_option_t = 4;
pub const libvlc_video_logo_option_t_libvlc_logo_repeat: libvlc_video_logo_option_t = 5;
pub const libvlc_video_logo_option_t_libvlc_logo_opacity: libvlc_video_logo_option_t = 6;
pub const libvlc_video_logo_option_t_libvlc_logo_position: libvlc_video_logo_option_t = 7;
#[doc = " option values for libvlc_video_{get,set}_logo_{int,string}"]
pub type libvlc_video_logo_option_t = libc::c_uint;
unsafe extern "C" {
    #[doc = " Get integer logo option.\n\n \\param p_mi libvlc media player instance\n \\param option logo option to get, values of libvlc_video_logo_option_t"]
    pub fn libvlc_video_get_logo_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set logo option as integer. Options that take a different type value\n are ignored.\n Passing libvlc_logo_enable as option value has the side effect of\n starting (arg !0) or stopping (arg 0) the logo filter.\n\n \\param p_mi libvlc media player instance\n \\param option logo option to set, values of libvlc_video_logo_option_t\n \\param value logo option value"]
    pub fn libvlc_video_set_logo_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        value: libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Set logo option as string. Options that take a different type value\n are ignored.\n\n \\param p_mi libvlc media player instance\n \\param option logo option to set, values of libvlc_video_logo_option_t\n \\param psz_value logo option value"]
    pub fn libvlc_video_set_logo_string(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        psz_value: *const libc::c_char,
    );
}
pub const libvlc_video_adjust_option_t_libvlc_adjust_Enable: libvlc_video_adjust_option_t = 0;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Contrast: libvlc_video_adjust_option_t = 1;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Brightness: libvlc_video_adjust_option_t = 2;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Hue: libvlc_video_adjust_option_t = 3;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Saturation: libvlc_video_adjust_option_t = 4;
pub const libvlc_video_adjust_option_t_libvlc_adjust_Gamma: libvlc_video_adjust_option_t = 5;
#[doc = " option values for libvlc_video_{get,set}_adjust_{int,float,bool}"]
pub type libvlc_video_adjust_option_t = libc::c_uint;
unsafe extern "C" {
    #[doc = " Get integer adjust option.\n\n \\param p_mi libvlc media player instance\n \\param option adjust option to get, values of libvlc_video_adjust_option_t\n \\version LibVLC 1.1.1 and later."]
    pub fn libvlc_video_get_adjust_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set adjust option as integer. Options that take a different type value\n are ignored.\n Passing libvlc_adjust_enable as option value has the side effect of\n starting (arg !0) or stopping (arg 0) the adjust filter.\n\n \\param p_mi libvlc media player instance\n \\param option adust option to set, values of libvlc_video_adjust_option_t\n \\param value adjust option value\n \\version LibVLC 1.1.1 and later."]
    pub fn libvlc_video_set_adjust_int(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        value: libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Get float adjust option.\n\n \\param p_mi libvlc media player instance\n \\param option adjust option to get, values of libvlc_video_adjust_option_t\n \\version LibVLC 1.1.1 and later."]
    pub fn libvlc_video_get_adjust_float(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " Set adjust option as float. Options that take a different type value\n are ignored.\n\n \\param p_mi libvlc media player instance\n \\param option adust option to set, values of libvlc_video_adjust_option_t\n \\param value adjust option value\n \\version LibVLC 1.1.1 and later."]
    pub fn libvlc_video_set_adjust_float(
        p_mi: *mut libvlc_media_player_t,
        option: libc::c_uint,
        value: f32,
    );
}
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_Error:
    libvlc_audio_output_device_types_t = -1;
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_Mono:
    libvlc_audio_output_device_types_t = 1;
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_Stereo:
    libvlc_audio_output_device_types_t = 2;
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_2F2R:
    libvlc_audio_output_device_types_t = 4;
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_3F2R:
    libvlc_audio_output_device_types_t = 5;
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_5_1:
    libvlc_audio_output_device_types_t = 6;
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_6_1:
    libvlc_audio_output_device_types_t = 7;
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_7_1:
    libvlc_audio_output_device_types_t = 8;
pub const libvlc_audio_output_device_types_t_libvlc_AudioOutputDevice_SPDIF:
    libvlc_audio_output_device_types_t = 10;
#[doc = " Audio device types"]
pub type libvlc_audio_output_device_types_t = libc::c_int;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Error: libvlc_audio_output_channel_t =
    -1;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Stereo: libvlc_audio_output_channel_t =
    1;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_RStereo: libvlc_audio_output_channel_t =
    2;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Left: libvlc_audio_output_channel_t = 3;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Right: libvlc_audio_output_channel_t =
    4;
pub const libvlc_audio_output_channel_t_libvlc_AudioChannel_Dolbys: libvlc_audio_output_channel_t =
    5;
#[doc = " Audio channels"]
pub type libvlc_audio_output_channel_t = libc::c_int;
unsafe extern "C" {
    #[doc = " Gets the list of available audio output modules.\n\n \\param p_instance libvlc instance\n \\return list of available audio outputs. It must be freed with\n          \\see libvlc_audio_output_list_release \\see libvlc_audio_output_t .\n         In case of error, NULL is returned."]
    pub fn libvlc_audio_output_list_get(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_audio_output_t;
}
unsafe extern "C" {
    #[doc = " Frees the list of available audio output modules.\n\n \\param p_list list with audio outputs for release"]
    pub fn libvlc_audio_output_list_release(p_list: *mut libvlc_audio_output_t);
}
unsafe extern "C" {
    #[doc = " Selects an audio output module.\n \\note Any change will take be effect only after playback is stopped and\n restarted. Audio output cannot be changed while playing.\n\n \\param p_mi media player\n \\param psz_name name of audio output,\n               use psz_name of \\see libvlc_audio_output_t\n \\return 0 if function succeeded, -1 on error"]
    pub fn libvlc_audio_output_set(
        p_mi: *mut libvlc_media_player_t,
        psz_name: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Gets a list of potential audio output devices,\n \\see libvlc_audio_output_device_set().\n\n \\note Not all audio outputs support enumerating devices.\n The audio output may be functional even if the list is empty (NULL).\n\n \\note The list may not be exhaustive.\n\n \\warning Some audio output devices in the list might not actually work in\n some circumstances. By default, it is recommended to not specify any\n explicit audio device.\n\n \\param mp media player\n \\return A NULL-terminated linked list of potential audio output devices.\n It must be freed with libvlc_audio_output_device_list_release()\n \\version LibVLC 2.2.0 or later."]
    pub fn libvlc_audio_output_device_enum(
        mp: *mut libvlc_media_player_t,
    ) -> *mut libvlc_audio_output_device_t;
}
unsafe extern "C" {
    #[doc = " Gets a list of audio output devices for a given audio output module,\n \\see libvlc_audio_output_device_set().\n\n \\note Not all audio outputs support this. In particular, an empty (NULL)\n list of devices does <b>not</b> imply that the specified audio output does\n not work.\n\n \\note The list might not be exhaustive.\n\n \\warning Some audio output devices in the list might not actually work in\n some circumstances. By default, it is recommended to not specify any\n explicit audio device.\n\n \\param p_instance libvlc instance\n \\param aout audio output name\n                 (as returned by libvlc_audio_output_list_get())\n \\return A NULL-terminated linked list of potential audio output devices.\n It must be freed with libvlc_audio_output_device_list_release()\n \\version LibVLC 2.1.0 or later."]
    pub fn libvlc_audio_output_device_list_get(
        p_instance: *mut libvlc_instance_t,
        aout: *const libc::c_char,
    ) -> *mut libvlc_audio_output_device_t;
}
unsafe extern "C" {
    #[doc = " Frees a list of available audio output devices.\n\n \\param p_list list with audio outputs for release\n \\version LibVLC 2.1.0 or later."]
    pub fn libvlc_audio_output_device_list_release(p_list: *mut libvlc_audio_output_device_t);
}
unsafe extern "C" {
    #[doc = " Configures an explicit audio output device.\n\n If the module paramater is NULL, audio output will be moved to the device\n specified by the device identifier string immediately. This is the\n recommended usage.\n\n A list of adequate potential device strings can be obtained with\n libvlc_audio_output_device_enum().\n\n However passing NULL is supported in LibVLC version 2.2.0 and later only;\n in earlier versions, this function would have no effects when the module\n parameter was NULL.\n\n If the module parameter is not NULL, the device parameter of the\n corresponding audio output, if it exists, will be set to the specified\n string. Note that some audio output modules do not have such a parameter\n (notably MMDevice and PulseAudio).\n\n A list of adequate potential device strings can be obtained with\n libvlc_audio_output_device_list_get().\n\n \\note This function does not select the specified audio output plugin.\n libvlc_audio_output_set() is used for that purpose.\n\n \\warning The syntax for the device parameter depends on the audio output.\n\n Some audio output modules require further parameters (e.g. a channels map\n in the case of ALSA).\n\n \\param mp media player\n \\param module If NULL, current audio output module.\n               if non-NULL, name of audio output module\n(\\see libvlc_audio_output_t)\n \\param device_id device identifier string\n \\return Nothing. Errors are ignored (this is a design bug)."]
    pub fn libvlc_audio_output_device_set(
        mp: *mut libvlc_media_player_t,
        module: *const libc::c_char,
        device_id: *const libc::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Get the current audio output device identifier.\n\n This complements libvlc_audio_output_device_set().\n\n \\warning The initial value for the current audio output device identifier\n may not be set or may be some unknown value. A LibVLC application should\n compare this value against the known device identifiers (e.g. those that\n were previously retrieved by a call to libvlc_audio_output_device_enum or\n libvlc_audio_output_device_list_get) to find the current audio output device.\n\n It is possible that the selected audio output device changes (an external\n change) without a call to libvlc_audio_output_device_set. That may make this\n method unsuitable to use if a LibVLC application is attempting to track\n dynamic audio device changes as they happen.\n\n \\param mp media player\n \\return the current audio output device identifier\n         NULL if no device is selected or in case of error\n         (the result must be released with free() or libvlc_free()).\n \\version LibVLC 3.0.0 or later."]
    pub fn libvlc_audio_output_device_get(mp: *mut libvlc_media_player_t) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Toggle mute status.\n\n \\param p_mi media player\n \\warning Toggling mute atomically is not always possible: On some platforms,\n other processes can mute the VLC audio playback stream asynchronously. Thus,\n there is a small race condition where toggling will not work.\n See also the limitations of libvlc_audio_set_mute()."]
    pub fn libvlc_audio_toggle_mute(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Get current mute status.\n\n \\param p_mi media player\n \\return the mute status (boolean) if defined, -1 if undefined/unapplicable"]
    pub fn libvlc_audio_get_mute(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set mute status.\n\n \\param p_mi media player\n \\param status If status is true then mute, otherwise unmute\n \\warning This function does not always work. If there are no active audio\n playback stream, the mute status might not be available. If digital\n pass-through (S/PDIF, HDMI...) is in use, muting may be unapplicable. Also\n some audio output plugins do not support muting at all.\n \\note To force silent playback, disable all audio tracks. This is more\n efficient and reliable than mute."]
    pub fn libvlc_audio_set_mute(p_mi: *mut libvlc_media_player_t, status: libc::c_int);
}
unsafe extern "C" {
    #[doc = " Get current software audio volume.\n\n \\param p_mi media player\n \\return the software volume in percents\n (0 = mute, 100 = nominal / 0dB)"]
    pub fn libvlc_audio_get_volume(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set current software audio volume.\n\n \\param p_mi media player\n \\param i_volume the volume in percents (0 = mute, 100 = 0dB)\n \\return 0 if the volume was set, -1 if it was out of range"]
    pub fn libvlc_audio_set_volume(
        p_mi: *mut libvlc_media_player_t,
        i_volume: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get number of available audio tracks.\n\n \\param p_mi media player\n \\return the number of available audio tracks (int), or -1 if unavailable"]
    pub fn libvlc_audio_get_track_count(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the description of available audio tracks.\n\n \\param p_mi media player\n \\return list with description of available audio tracks, or NULL.\n It must be freed with libvlc_track_description_list_release()"]
    pub fn libvlc_audio_get_track_description(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_track_description_t;
}
unsafe extern "C" {
    #[doc = " Get current audio track.\n\n \\param p_mi media player\n \\return the audio track ID or -1 if no active input."]
    pub fn libvlc_audio_get_track(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set current audio track.\n\n \\param p_mi media player\n \\param i_track the track ID (i_id field from track description)\n \\return 0 on success, -1 on error"]
    pub fn libvlc_audio_set_track(
        p_mi: *mut libvlc_media_player_t,
        i_track: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get current audio channel.\n\n \\param p_mi media player\n \\return the audio channel \\see libvlc_audio_output_channel_t"]
    pub fn libvlc_audio_get_channel(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set current audio channel.\n\n \\param p_mi media player\n \\param channel the audio channel, \\see libvlc_audio_output_channel_t\n \\return 0 on success, -1 on error"]
    pub fn libvlc_audio_set_channel(
        p_mi: *mut libvlc_media_player_t,
        channel: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get current audio delay.\n\n \\param p_mi media player\n \\return the audio delay (microseconds)\n \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_audio_get_delay(p_mi: *mut libvlc_media_player_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Set current audio delay. The audio delay will be reset to zero each time the media changes.\n\n \\param p_mi media player\n \\param i_delay the audio delay (microseconds)\n \\return 0 on success, -1 on error\n \\version LibVLC 1.1.1 or later"]
    pub fn libvlc_audio_set_delay(p_mi: *mut libvlc_media_player_t, i_delay: i64) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of equalizer presets.\n\n \\return number of presets\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_preset_count() -> libc::c_uint;
}
unsafe extern "C" {
    #[doc = " Get the name of a particular equalizer preset.\n\n This name can be used, for example, to prepare a preset label or menu in a user\n interface.\n\n \\param u_index index of the preset, counting from zero\n \\return preset name, or NULL if there is no such preset\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_preset_name(u_index: libc::c_uint) -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Get the number of distinct frequency bands for an equalizer.\n\n \\return number of frequency bands\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_band_count() -> libc::c_uint;
}
unsafe extern "C" {
    #[doc = " Get a particular equalizer band frequency.\n\n This value can be used, for example, to create a label for an equalizer band control\n in a user interface.\n\n \\param u_index index of the band, counting from zero\n \\return equalizer band frequency (Hz), or -1 if there is no such band\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_band_frequency(u_index: libc::c_uint) -> f32;
}
unsafe extern "C" {
    #[doc = " Create a new default equalizer, with all frequency values zeroed.\n\n The new equalizer can subsequently be applied to a media player by invoking\n libvlc_media_player_set_equalizer().\n\n The returned handle should be freed via libvlc_audio_equalizer_release() when\n it is no longer needed.\n\n \\return opaque equalizer handle, or NULL on error\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_new() -> *mut libvlc_equalizer_t;
}
unsafe extern "C" {
    #[doc = " Create a new equalizer, with initial frequency values copied from an existing\n preset.\n\n The new equalizer can subsequently be applied to a media player by invoking\n libvlc_media_player_set_equalizer().\n\n The returned handle should be freed via libvlc_audio_equalizer_release() when\n it is no longer needed.\n\n \\param u_index index of the preset, counting from zero\n \\return opaque equalizer handle, or NULL on error\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_new_from_preset(u_index: libc::c_uint)
        -> *mut libvlc_equalizer_t;
}
unsafe extern "C" {
    #[doc = " Release a previously created equalizer instance.\n\n The equalizer was previously created by using libvlc_audio_equalizer_new() or\n libvlc_audio_equalizer_new_from_preset().\n\n It is safe to invoke this method with a NULL p_equalizer parameter for no effect.\n\n \\param p_equalizer opaque equalizer handle, or NULL\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_release(p_equalizer: *mut libvlc_equalizer_t);
}
unsafe extern "C" {
    #[doc = " Set a new pre-amplification value for an equalizer.\n\n The new equalizer settings are subsequently applied to a media player by invoking\n libvlc_media_player_set_equalizer().\n\n The supplied amplification value will be clamped to the -20.0 to +20.0 range.\n\n \\param p_equalizer valid equalizer handle, must not be NULL\n \\param f_preamp preamp value (-20.0 to 20.0 Hz)\n \\return zero on success, -1 on error\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_set_preamp(
        p_equalizer: *mut libvlc_equalizer_t,
        f_preamp: f32,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current pre-amplification value from an equalizer.\n\n \\param p_equalizer valid equalizer handle, must not be NULL\n \\return preamp value (Hz)\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_preamp(p_equalizer: *mut libvlc_equalizer_t) -> f32;
}
unsafe extern "C" {
    #[doc = " Set a new amplification value for a particular equalizer frequency band.\n\n The new equalizer settings are subsequently applied to a media player by invoking\n libvlc_media_player_set_equalizer().\n\n The supplied amplification value will be clamped to the -20.0 to +20.0 range.\n\n \\param p_equalizer valid equalizer handle, must not be NULL\n \\param f_amp amplification value (-20.0 to 20.0 Hz)\n \\param u_band index, counting from zero, of the frequency band to set\n \\return zero on success, -1 on error\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_set_amp_at_index(
        p_equalizer: *mut libvlc_equalizer_t,
        f_amp: f32,
        u_band: libc::c_uint,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the amplification value for a particular equalizer frequency band.\n\n \\param p_equalizer valid equalizer handle, must not be NULL\n \\param u_band index, counting from zero, of the frequency band to get\n \\return amplification value (Hz); NaN if there is no such frequency band\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_audio_equalizer_get_amp_at_index(
        p_equalizer: *mut libvlc_equalizer_t,
        u_band: libc::c_uint,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " Apply new equalizer settings to a media player.\n\n The equalizer is first created by invoking libvlc_audio_equalizer_new() or\n libvlc_audio_equalizer_new_from_preset().\n\n It is possible to apply new equalizer settings to a media player whether the media\n player is currently playing media or not.\n\n Invoking this method will immediately apply the new equalizer settings to the audio\n output of the currently playing media if there is any.\n\n If there is no currently playing media, the new equalizer settings will be applied\n later if and when new media is played.\n\n Equalizer settings will automatically be applied to subsequently played media.\n\n To disable the equalizer for a media player invoke this method passing NULL for the\n p_equalizer parameter.\n\n The media player does not keep a reference to the supplied equalizer so it is safe\n for an application to release the equalizer reference any time after this method\n returns.\n\n \\param p_mi opaque media player handle\n \\param p_equalizer opaque equalizer handle, or NULL to disable the equalizer for this media player\n \\return zero on success, -1 on error\n \\version LibVLC 2.2.0 or later"]
    pub fn libvlc_media_player_set_equalizer(
        p_mi: *mut libvlc_media_player_t,
        p_equalizer: *mut libvlc_equalizer_t,
    ) -> libc::c_int;
}
#[doc = "< Don't use a media player role"]
pub const libvlc_media_player_role_libvlc_role_None: libvlc_media_player_role = 0;
#[doc = "< Music (or radio) playback"]
pub const libvlc_media_player_role_libvlc_role_Music: libvlc_media_player_role = 1;
#[doc = "< Video playback"]
pub const libvlc_media_player_role_libvlc_role_Video: libvlc_media_player_role = 2;
#[doc = "< Speech, real-time communication"]
pub const libvlc_media_player_role_libvlc_role_Communication: libvlc_media_player_role = 3;
#[doc = "< Video game"]
pub const libvlc_media_player_role_libvlc_role_Game: libvlc_media_player_role = 4;
#[doc = "< User interaction feedback"]
pub const libvlc_media_player_role_libvlc_role_Notification: libvlc_media_player_role = 5;
#[doc = "< Embedded animation (e.g. in web page)"]
pub const libvlc_media_player_role_libvlc_role_Animation: libvlc_media_player_role = 6;
#[doc = "< Audio editting/production"]
pub const libvlc_media_player_role_libvlc_role_Production: libvlc_media_player_role = 7;
#[doc = "< Accessibility"]
pub const libvlc_media_player_role_libvlc_role_Accessibility: libvlc_media_player_role = 8;
pub const libvlc_media_player_role_libvlc_role_Test: libvlc_media_player_role = 9;
#[doc = " Media player roles.\n\n \\version LibVLC 3.0.0 and later.\n\n See \\ref libvlc_media_player_set_role()"]
pub type libvlc_media_player_role = libc::c_uint;
#[doc = " Media player roles.\n\n \\version LibVLC 3.0.0 and later.\n\n See \\ref libvlc_media_player_set_role()"]
pub use self::libvlc_media_player_role as libvlc_media_player_role_t;
unsafe extern "C" {
    #[doc = " Gets the media role.\n\n \\version LibVLC 3.0.0 and later.\n\n \\param p_mi media player\n \\return the media player role (\\ref libvlc_media_player_role_t)"]
    pub fn libvlc_media_player_get_role(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the media role.\n\n \\param p_mi media player\n \\param role the media player role (\\ref libvlc_media_player_role_t)\n \\return 0 on success, -1 on error"]
    pub fn libvlc_media_player_set_role(
        p_mi: *mut libvlc_media_player_t,
        role: libc::c_uint,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Create an empty media list.\n\n \\param p_instance libvlc instance\n \\return empty media list, or NULL on error"]
    pub fn libvlc_media_list_new(p_instance: *mut libvlc_instance_t) -> *mut libvlc_media_list_t;
}
unsafe extern "C" {
    #[doc = " Release media list created with libvlc_media_list_new().\n\n \\param p_ml a media list created with libvlc_media_list_new()"]
    pub fn libvlc_media_list_release(p_ml: *mut libvlc_media_list_t);
}
unsafe extern "C" {
    #[doc = " Retain reference to a media list\n\n \\param p_ml a media list created with libvlc_media_list_new()"]
    pub fn libvlc_media_list_retain(p_ml: *mut libvlc_media_list_t);
}
unsafe extern "C" {
    #[doc = " Associate media instance with this media list instance.\n If another media instance was present it will be released.\n The libvlc_media_list_lock should NOT be held upon entering this function.\n\n \\param p_ml a media list instance\n \\param p_md media instance to add"]
    pub fn libvlc_media_list_set_media(p_ml: *mut libvlc_media_list_t, p_md: *mut libvlc_media_t);
}
unsafe extern "C" {
    #[doc = " Get media instance from this media list instance. This action will increase\n the refcount on the media instance.\n The libvlc_media_list_lock should NOT be held upon entering this function.\n\n \\param p_ml a media list instance\n \\return media instance"]
    pub fn libvlc_media_list_media(p_ml: *mut libvlc_media_list_t) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Add media instance to media list\n The libvlc_media_list_lock should be held upon entering this function.\n\n \\param p_ml a media list instance\n \\param p_md a media instance\n \\return 0 on success, -1 if the media list is read-only"]
    pub fn libvlc_media_list_add_media(
        p_ml: *mut libvlc_media_list_t,
        p_md: *mut libvlc_media_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Insert media instance in media list on a position\n The libvlc_media_list_lock should be held upon entering this function.\n\n \\param p_ml a media list instance\n \\param p_md a media instance\n \\param i_pos position in array where to insert\n \\return 0 on success, -1 if the media list is read-only"]
    pub fn libvlc_media_list_insert_media(
        p_ml: *mut libvlc_media_list_t,
        p_md: *mut libvlc_media_t,
        i_pos: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Remove media instance from media list on a position\n The libvlc_media_list_lock should be held upon entering this function.\n\n \\param p_ml a media list instance\n \\param i_pos position in array where to insert\n \\return 0 on success, -1 if the list is read-only or the item was not found"]
    pub fn libvlc_media_list_remove_index(
        p_ml: *mut libvlc_media_list_t,
        i_pos: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get count on media list items\n The libvlc_media_list_lock should be held upon entering this function.\n\n \\param p_ml a media list instance\n \\return number of items in media list"]
    pub fn libvlc_media_list_count(p_ml: *mut libvlc_media_list_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " List media instance in media list at a position\n The libvlc_media_list_lock should be held upon entering this function.\n\n \\param p_ml a media list instance\n \\param i_pos position in array where to insert\n \\return media instance at position i_pos, or NULL if not found.\n In case of success, libvlc_media_retain() is called to increase the refcount\n on the media."]
    pub fn libvlc_media_list_item_at_index(
        p_ml: *mut libvlc_media_list_t,
        i_pos: libc::c_int,
    ) -> *mut libvlc_media_t;
}
unsafe extern "C" {
    #[doc = " Find index position of List media instance in media list.\n Warning: the function will return the first matched position.\n The libvlc_media_list_lock should be held upon entering this function.\n\n \\param p_ml a media list instance\n \\param p_md media instance\n \\return position of media instance or -1 if media not found"]
    pub fn libvlc_media_list_index_of_item(
        p_ml: *mut libvlc_media_list_t,
        p_md: *mut libvlc_media_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " This indicates if this media list is read-only from a user point of view\n\n \\param p_ml media list instance\n \\return 1 on readonly, 0 on readwrite\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_list_is_readonly(p_ml: *mut libvlc_media_list_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get lock on media list items\n\n \\param p_ml a media list instance"]
    pub fn libvlc_media_list_lock(p_ml: *mut libvlc_media_list_t);
}
unsafe extern "C" {
    #[doc = " Release lock on media list items\n The libvlc_media_list_lock should be held upon entering this function.\n\n \\param p_ml a media list instance"]
    pub fn libvlc_media_list_unlock(p_ml: *mut libvlc_media_list_t);
}
unsafe extern "C" {
    #[doc = " Get libvlc_event_manager from this media list instance.\n The p_event_manager is immutable, so you don't have to hold the lock\n\n \\param p_ml a media list instance\n \\return libvlc_event_manager"]
    pub fn libvlc_media_list_event_manager(
        p_ml: *mut libvlc_media_list_t,
    ) -> *mut libvlc_event_manager_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_list_player_t {
    _unused: [u8; 0],
}
pub const libvlc_playback_mode_t_libvlc_playback_mode_default: libvlc_playback_mode_t = 0;
pub const libvlc_playback_mode_t_libvlc_playback_mode_loop: libvlc_playback_mode_t = 1;
pub const libvlc_playback_mode_t_libvlc_playback_mode_repeat: libvlc_playback_mode_t = 2;
#[doc = "  Defines playback modes for playlist."]
pub type libvlc_playback_mode_t = libc::c_uint;
unsafe extern "C" {
    #[doc = " Create new media_list_player.\n\n \\param p_instance libvlc instance\n \\return media list player instance or NULL on error"]
    pub fn libvlc_media_list_player_new(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_media_list_player_t;
}
unsafe extern "C" {
    #[doc = " Release a media_list_player after use\n Decrement the reference count of a media player object. If the\n reference count is 0, then libvlc_media_list_player_release() will\n release the media player object. If the media player object\n has been released, then it should not be used again.\n\n \\param p_mlp media list player instance"]
    pub fn libvlc_media_list_player_release(p_mlp: *mut libvlc_media_list_player_t);
}
unsafe extern "C" {
    #[doc = " Retain a reference to a media player list object. Use\n libvlc_media_list_player_release() to decrement reference count.\n\n \\param p_mlp media player list object"]
    pub fn libvlc_media_list_player_retain(p_mlp: *mut libvlc_media_list_player_t);
}
unsafe extern "C" {
    #[doc = " Return the event manager of this media_list_player.\n\n \\param p_mlp media list player instance\n \\return the event manager"]
    pub fn libvlc_media_list_player_event_manager(
        p_mlp: *mut libvlc_media_list_player_t,
    ) -> *mut libvlc_event_manager_t;
}
unsafe extern "C" {
    #[doc = " Replace media player in media_list_player with this instance.\n\n \\param p_mlp media list player instance\n \\param p_mi media player instance"]
    pub fn libvlc_media_list_player_set_media_player(
        p_mlp: *mut libvlc_media_list_player_t,
        p_mi: *mut libvlc_media_player_t,
    );
}
unsafe extern "C" {
    #[doc = " Get media player of the media_list_player instance.\n\n \\param p_mlp media list player instance\n \\return media player instance\n \\note the caller is responsible for releasing the returned instance"]
    pub fn libvlc_media_list_player_get_media_player(
        p_mlp: *mut libvlc_media_list_player_t,
    ) -> *mut libvlc_media_player_t;
}
unsafe extern "C" {
    #[doc = " Set the media list associated with the player\n\n \\param p_mlp media list player instance\n \\param p_mlist list of media"]
    pub fn libvlc_media_list_player_set_media_list(
        p_mlp: *mut libvlc_media_list_player_t,
        p_mlist: *mut libvlc_media_list_t,
    );
}
unsafe extern "C" {
    #[doc = " Play media list\n\n \\param p_mlp media list player instance"]
    pub fn libvlc_media_list_player_play(p_mlp: *mut libvlc_media_list_player_t);
}
unsafe extern "C" {
    #[doc = " Toggle pause (or resume) media list\n\n \\param p_mlp media list player instance"]
    pub fn libvlc_media_list_player_pause(p_mlp: *mut libvlc_media_list_player_t);
}
unsafe extern "C" {
    #[doc = " Pause or resume media list\n\n \\param p_mlp media list player instance\n \\param do_pause play/resume if zero, pause if non-zero\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_list_player_set_pause(
        p_mlp: *mut libvlc_media_list_player_t,
        do_pause: libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Is media list playing?\n\n \\param p_mlp media list player instance\n \\return true for playing and false for not playing\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_list_player_is_playing(
        p_mlp: *mut libvlc_media_list_player_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get current libvlc_state of media list player\n\n \\param p_mlp media list player instance\n \\return libvlc_state_t for media list player"]
    pub fn libvlc_media_list_player_get_state(
        p_mlp: *mut libvlc_media_list_player_t,
    ) -> libvlc_state_t;
}
unsafe extern "C" {
    #[doc = " Play media list item at position index\n\n \\param p_mlp media list player instance\n \\param i_index index in media list to play\n \\return 0 upon success -1 if the item wasn't found"]
    pub fn libvlc_media_list_player_play_item_at_index(
        p_mlp: *mut libvlc_media_list_player_t,
        i_index: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Play the given media item\n\n \\param p_mlp media list player instance\n \\param p_md the media instance\n \\return 0 upon success, -1 if the media is not part of the media list"]
    pub fn libvlc_media_list_player_play_item(
        p_mlp: *mut libvlc_media_list_player_t,
        p_md: *mut libvlc_media_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Stop playing media list\n\n \\param p_mlp media list player instance"]
    pub fn libvlc_media_list_player_stop(p_mlp: *mut libvlc_media_list_player_t);
}
unsafe extern "C" {
    #[doc = " Play next item from media list\n\n \\param p_mlp media list player instance\n \\return 0 upon success -1 if there is no next item"]
    pub fn libvlc_media_list_player_next(p_mlp: *mut libvlc_media_list_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Play previous item from media list\n\n \\param p_mlp media list player instance\n \\return 0 upon success -1 if there is no previous item"]
    pub fn libvlc_media_list_player_previous(p_mlp: *mut libvlc_media_list_player_t)
        -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the playback mode for the playlist\n\n \\param p_mlp media list player instance\n \\param e_mode playback mode specification"]
    pub fn libvlc_media_list_player_set_playback_mode(
        p_mlp: *mut libvlc_media_list_player_t,
        e_mode: libvlc_playback_mode_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_library_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Create an new Media Library object\n\n \\param p_instance the libvlc instance\n \\return a new object or NULL on error"]
    pub fn libvlc_media_library_new(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_media_library_t;
}
unsafe extern "C" {
    #[doc = " Release media library object. This functions decrements the\n reference count of the media library object. If it reaches 0,\n then the object will be released.\n\n \\param p_mlib media library object"]
    pub fn libvlc_media_library_release(p_mlib: *mut libvlc_media_library_t);
}
unsafe extern "C" {
    #[doc = " Retain a reference to a media library object. This function will\n increment the reference counting for this object. Use\n libvlc_media_library_release() to decrement the reference count.\n\n \\param p_mlib media library object"]
    pub fn libvlc_media_library_retain(p_mlib: *mut libvlc_media_library_t);
}
unsafe extern "C" {
    #[doc = " Load media library.\n\n \\param p_mlib media library object\n \\return 0 on success, -1 on error"]
    pub fn libvlc_media_library_load(p_mlib: *mut libvlc_media_library_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get media library subitems.\n\n \\param p_mlib media library object\n \\return media list subitems"]
    pub fn libvlc_media_library_media_list(
        p_mlib: *mut libvlc_media_library_t,
    ) -> *mut libvlc_media_list_t;
}
#[doc = " devices, like portable music player"]
pub const libvlc_media_discoverer_category_t_libvlc_media_discoverer_devices:
    libvlc_media_discoverer_category_t = 0;
#[doc = " LAN/WAN services, like Upnp, SMB, or SAP"]
pub const libvlc_media_discoverer_category_t_libvlc_media_discoverer_lan:
    libvlc_media_discoverer_category_t = 1;
#[doc = " Podcasts"]
pub const libvlc_media_discoverer_category_t_libvlc_media_discoverer_podcasts:
    libvlc_media_discoverer_category_t = 2;
#[doc = " Local directories, like Video, Music or Pictures directories"]
pub const libvlc_media_discoverer_category_t_libvlc_media_discoverer_localdirs:
    libvlc_media_discoverer_category_t = 3;
#[doc = " Category of a media discoverer\n \\see libvlc_media_discoverer_list_get()"]
pub type libvlc_media_discoverer_category_t = libc::c_uint;
#[doc = " Media discoverer description\n \\see libvlc_media_discoverer_list_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_discoverer_description_t {
    pub psz_name: *mut libc::c_char,
    pub psz_longname: *mut libc::c_char,
    pub i_cat: libvlc_media_discoverer_category_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_media_discoverer_description_t"]
        [::core::mem::size_of::<libvlc_media_discoverer_description_t>() - 24usize];
    ["Alignment of libvlc_media_discoverer_description_t"]
        [::core::mem::align_of::<libvlc_media_discoverer_description_t>() - 8usize];
    ["Offset of field: libvlc_media_discoverer_description_t::psz_name"]
        [::core::mem::offset_of!(libvlc_media_discoverer_description_t, psz_name) - 0usize];
    ["Offset of field: libvlc_media_discoverer_description_t::psz_longname"]
        [::core::mem::offset_of!(libvlc_media_discoverer_description_t, psz_longname) - 8usize];
    ["Offset of field: libvlc_media_discoverer_description_t::i_cat"]
        [::core::mem::offset_of!(libvlc_media_discoverer_description_t, i_cat) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_media_discoverer_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Create a media discoverer object by name.\n\n After this object is created, you should attach to media_list events in\n order to be notified of new items discovered.\n\n You need to call libvlc_media_discoverer_start() in order to start the\n discovery.\n\n \\see libvlc_media_discoverer_media_list\n \\see libvlc_media_discoverer_event_manager\n \\see libvlc_media_discoverer_start\n\n \\param p_inst libvlc instance\n \\param psz_name service name; use libvlc_media_discoverer_list_get() to get\n a list of the discoverer names available in this libVLC instance\n \\return media discover object or NULL in case of error\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_discoverer_new(
        p_inst: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> *mut libvlc_media_discoverer_t;
}
unsafe extern "C" {
    #[doc = " Start media discovery.\n\n To stop it, call libvlc_media_discoverer_stop() or\n libvlc_media_discoverer_list_release() directly.\n\n \\see libvlc_media_discoverer_stop\n\n \\param p_mdis media discover object\n \\return -1 in case of error, 0 otherwise\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_discoverer_start(p_mdis: *mut libvlc_media_discoverer_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Stop media discovery.\n\n \\see libvlc_media_discoverer_start\n\n \\param p_mdis media discover object\n \\version LibVLC 3.0.0 or later"]
    pub fn libvlc_media_discoverer_stop(p_mdis: *mut libvlc_media_discoverer_t);
}
unsafe extern "C" {
    #[doc = " Release media discover object. If the reference count reaches 0, then\n the object will be released.\n\n \\param p_mdis media service discover object"]
    pub fn libvlc_media_discoverer_release(p_mdis: *mut libvlc_media_discoverer_t);
}
unsafe extern "C" {
    #[doc = " Get media service discover media list.\n\n \\param p_mdis media service discover object\n \\return list of media items"]
    pub fn libvlc_media_discoverer_media_list(
        p_mdis: *mut libvlc_media_discoverer_t,
    ) -> *mut libvlc_media_list_t;
}
unsafe extern "C" {
    #[doc = " Query if media service discover object is running.\n\n \\param p_mdis media service discover object\n \\return true if running, false if not\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_discoverer_is_running(
        p_mdis: *mut libvlc_media_discoverer_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get media discoverer services by category\n\n \\version LibVLC 3.0.0 and later.\n\n \\param p_inst libvlc instance\n \\param i_cat category of services to fetch\n \\param ppp_services address to store an allocated array of media discoverer\n services (must be freed with libvlc_media_discoverer_list_release() by\n the caller) [OUT]\n\n \\return the number of media discoverer services (0 on error)"]
    pub fn libvlc_media_discoverer_list_get(
        p_inst: *mut libvlc_instance_t,
        i_cat: libvlc_media_discoverer_category_t,
        ppp_services: *mut *mut *mut libvlc_media_discoverer_description_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Release an array of media discoverer services\n\n \\version LibVLC 3.0.0 and later.\n\n \\see libvlc_media_discoverer_list_get()\n\n \\param pp_services array to release\n \\param i_count number of elements in the array"]
    pub fn libvlc_media_discoverer_list_release(
        pp_services: *mut *mut libvlc_media_discoverer_description_t,
        i_count: usize,
    );
}
pub const libvlc_event_e_libvlc_MediaMetaChanged: libvlc_event_e = 0;
pub const libvlc_event_e_libvlc_MediaSubItemAdded: libvlc_event_e = 1;
pub const libvlc_event_e_libvlc_MediaDurationChanged: libvlc_event_e = 2;
pub const libvlc_event_e_libvlc_MediaParsedChanged: libvlc_event_e = 3;
pub const libvlc_event_e_libvlc_MediaFreed: libvlc_event_e = 4;
pub const libvlc_event_e_libvlc_MediaStateChanged: libvlc_event_e = 5;
pub const libvlc_event_e_libvlc_MediaSubItemTreeAdded: libvlc_event_e = 6;
pub const libvlc_event_e_libvlc_MediaPlayerMediaChanged: libvlc_event_e = 256;
pub const libvlc_event_e_libvlc_MediaPlayerNothingSpecial: libvlc_event_e = 257;
pub const libvlc_event_e_libvlc_MediaPlayerOpening: libvlc_event_e = 258;
pub const libvlc_event_e_libvlc_MediaPlayerBuffering: libvlc_event_e = 259;
pub const libvlc_event_e_libvlc_MediaPlayerPlaying: libvlc_event_e = 260;
pub const libvlc_event_e_libvlc_MediaPlayerPaused: libvlc_event_e = 261;
pub const libvlc_event_e_libvlc_MediaPlayerStopped: libvlc_event_e = 262;
pub const libvlc_event_e_libvlc_MediaPlayerForward: libvlc_event_e = 263;
pub const libvlc_event_e_libvlc_MediaPlayerBackward: libvlc_event_e = 264;
pub const libvlc_event_e_libvlc_MediaPlayerEndReached: libvlc_event_e = 265;
pub const libvlc_event_e_libvlc_MediaPlayerEncounteredError: libvlc_event_e = 266;
pub const libvlc_event_e_libvlc_MediaPlayerTimeChanged: libvlc_event_e = 267;
pub const libvlc_event_e_libvlc_MediaPlayerPositionChanged: libvlc_event_e = 268;
pub const libvlc_event_e_libvlc_MediaPlayerSeekableChanged: libvlc_event_e = 269;
pub const libvlc_event_e_libvlc_MediaPlayerPausableChanged: libvlc_event_e = 270;
pub const libvlc_event_e_libvlc_MediaPlayerTitleChanged: libvlc_event_e = 271;
pub const libvlc_event_e_libvlc_MediaPlayerSnapshotTaken: libvlc_event_e = 272;
pub const libvlc_event_e_libvlc_MediaPlayerLengthChanged: libvlc_event_e = 273;
pub const libvlc_event_e_libvlc_MediaPlayerVout: libvlc_event_e = 274;
pub const libvlc_event_e_libvlc_MediaPlayerScrambledChanged: libvlc_event_e = 275;
pub const libvlc_event_e_libvlc_MediaPlayerESAdded: libvlc_event_e = 276;
pub const libvlc_event_e_libvlc_MediaPlayerESDeleted: libvlc_event_e = 277;
pub const libvlc_event_e_libvlc_MediaPlayerESSelected: libvlc_event_e = 278;
pub const libvlc_event_e_libvlc_MediaPlayerCorked: libvlc_event_e = 279;
pub const libvlc_event_e_libvlc_MediaPlayerUncorked: libvlc_event_e = 280;
pub const libvlc_event_e_libvlc_MediaPlayerMuted: libvlc_event_e = 281;
pub const libvlc_event_e_libvlc_MediaPlayerUnmuted: libvlc_event_e = 282;
pub const libvlc_event_e_libvlc_MediaPlayerAudioVolume: libvlc_event_e = 283;
pub const libvlc_event_e_libvlc_MediaPlayerAudioDevice: libvlc_event_e = 284;
pub const libvlc_event_e_libvlc_MediaPlayerChapterChanged: libvlc_event_e = 285;
pub const libvlc_event_e_libvlc_MediaListItemAdded: libvlc_event_e = 512;
pub const libvlc_event_e_libvlc_MediaListWillAddItem: libvlc_event_e = 513;
pub const libvlc_event_e_libvlc_MediaListItemDeleted: libvlc_event_e = 514;
pub const libvlc_event_e_libvlc_MediaListWillDeleteItem: libvlc_event_e = 515;
pub const libvlc_event_e_libvlc_MediaListEndReached: libvlc_event_e = 516;
pub const libvlc_event_e_libvlc_MediaListViewItemAdded: libvlc_event_e = 768;
pub const libvlc_event_e_libvlc_MediaListViewWillAddItem: libvlc_event_e = 769;
pub const libvlc_event_e_libvlc_MediaListViewItemDeleted: libvlc_event_e = 770;
pub const libvlc_event_e_libvlc_MediaListViewWillDeleteItem: libvlc_event_e = 771;
pub const libvlc_event_e_libvlc_MediaListPlayerPlayed: libvlc_event_e = 1024;
pub const libvlc_event_e_libvlc_MediaListPlayerNextItemSet: libvlc_event_e = 1025;
pub const libvlc_event_e_libvlc_MediaListPlayerStopped: libvlc_event_e = 1026;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_start()"]
pub const libvlc_event_e_libvlc_MediaDiscovererStarted: libvlc_event_e = 1280;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_MediaDiscovererEnded: libvlc_event_e = 1281;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_RendererDiscovererItemAdded: libvlc_event_e = 1282;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_RendererDiscovererItemDeleted: libvlc_event_e = 1283;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaAdded: libvlc_event_e = 1536;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaRemoved: libvlc_event_e = 1537;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaChanged: libvlc_event_e = 1538;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaInstanceStarted: libvlc_event_e = 1539;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaInstanceStopped: libvlc_event_e = 1540;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaInstanceStatusInit: libvlc_event_e = 1541;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaInstanceStatusOpening: libvlc_event_e = 1542;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaInstanceStatusPlaying: libvlc_event_e = 1543;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaInstanceStatusPause: libvlc_event_e = 1544;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaInstanceStatusEnd: libvlc_event_e = 1545;
#[doc = " \\deprecated Useless event, it will be triggered only when calling\n libvlc_media_discoverer_stop()"]
pub const libvlc_event_e_libvlc_VlmMediaInstanceStatusError: libvlc_event_e = 1546;
#[doc = " Event types"]
pub type libvlc_event_e = libc::c_uint;
#[doc = " A LibVLC event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libvlc_event_t {
    #[doc = "< Event type (see @ref libvlc_event_e)"]
    pub type_: libc::c_int,
    #[doc = "< Object emitting the event"]
    pub p_obj: *mut libc::c_void,
    #[doc = "< Type-dependent event description"]
    pub u: libvlc_event_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union libvlc_event_t__bindgen_ty_1 {
    pub media_meta_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_1,
    pub media_subitem_added: libvlc_event_t__bindgen_ty_1__bindgen_ty_2,
    pub media_duration_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_3,
    pub media_parsed_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_4,
    pub media_freed: libvlc_event_t__bindgen_ty_1__bindgen_ty_5,
    pub media_state_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_6,
    pub media_subitemtree_added: libvlc_event_t__bindgen_ty_1__bindgen_ty_7,
    pub media_player_buffering: libvlc_event_t__bindgen_ty_1__bindgen_ty_8,
    pub media_player_chapter_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_9,
    pub media_player_position_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_10,
    pub media_player_time_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_11,
    pub media_player_title_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_12,
    pub media_player_seekable_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_13,
    pub media_player_pausable_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_14,
    pub media_player_scrambled_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_15,
    pub media_player_vout: libvlc_event_t__bindgen_ty_1__bindgen_ty_16,
    pub media_list_item_added: libvlc_event_t__bindgen_ty_1__bindgen_ty_17,
    pub media_list_will_add_item: libvlc_event_t__bindgen_ty_1__bindgen_ty_18,
    pub media_list_item_deleted: libvlc_event_t__bindgen_ty_1__bindgen_ty_19,
    pub media_list_will_delete_item: libvlc_event_t__bindgen_ty_1__bindgen_ty_20,
    pub media_list_player_next_item_set: libvlc_event_t__bindgen_ty_1__bindgen_ty_21,
    pub media_player_snapshot_taken: libvlc_event_t__bindgen_ty_1__bindgen_ty_22,
    pub media_player_length_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_23,
    pub vlm_media_event: libvlc_event_t__bindgen_ty_1__bindgen_ty_24,
    pub media_player_media_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_25,
    pub media_player_es_changed: libvlc_event_t__bindgen_ty_1__bindgen_ty_26,
    pub media_player_audio_volume: libvlc_event_t__bindgen_ty_1__bindgen_ty_27,
    pub media_player_audio_device: libvlc_event_t__bindgen_ty_1__bindgen_ty_28,
    pub renderer_discoverer_item_added: libvlc_event_t__bindgen_ty_1__bindgen_ty_29,
    pub renderer_discoverer_item_deleted: libvlc_event_t__bindgen_ty_1__bindgen_ty_30,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_1 {
    pub meta_type: libvlc_meta_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_1::meta_type"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_1, meta_type) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_2 {
    pub new_child: *mut libvlc_media_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_2::new_child"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_2, new_child) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_3 {
    pub new_duration: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_3"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_3"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_3::new_duration"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1__bindgen_ty_3,
        new_duration
    ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< see @ref libvlc_media_parsed_status_t"]
    pub new_status: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_4"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_4>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_4"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_4>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_4::new_status"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_4, new_status) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_5 {
    pub md: *mut libvlc_media_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_5"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_5"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_5::md"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_5, md) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "< see @ref libvlc_state_t"]
    pub new_state: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_6"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_6>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_6"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_6>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_6::new_state"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_6, new_state) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_7 {
    pub item: *mut libvlc_media_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_7"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_7"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_7::item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_7, item) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_8 {
    pub new_cache: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_8"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_8>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_8"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_8>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_8::new_cache"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_8, new_cache) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_9 {
    pub new_chapter: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_9"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_9>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_9"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_9>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_9::new_chapter"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_9, new_chapter) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_10 {
    pub new_position: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_10"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_10>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_10"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_10>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_10::new_position"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1__bindgen_ty_10,
        new_position
    ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_11 {
    pub new_time: libvlc_time_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_11"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_11>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_11"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_11>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_11::new_time"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_11, new_time) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_12 {
    pub new_title: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_12"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_12>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_12"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_12>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_12::new_title"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_12, new_title) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_13 {
    pub new_seekable: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_13"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_13>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_13"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_13>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_13::new_seekable"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1__bindgen_ty_13,
        new_seekable
    ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_14 {
    pub new_pausable: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_14"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_14>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_14"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_14>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_14::new_pausable"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1__bindgen_ty_14,
        new_pausable
    ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_15 {
    pub new_scrambled: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_15"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_15>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_15"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_15>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_15::new_scrambled"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1__bindgen_ty_15,
        new_scrambled
    ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_16 {
    pub new_count: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_16"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_16>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_16"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_16>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_16::new_count"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_16, new_count) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_17 {
    pub item: *mut libvlc_media_t,
    pub index: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_17"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_17>() - 16usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_17"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_17>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_17::item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_17, item) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_17::index"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_17, index) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_18 {
    pub item: *mut libvlc_media_t,
    pub index: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_18"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_18>() - 16usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_18"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_18>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_18::item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_18, item) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_18::index"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_18, index) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_19 {
    pub item: *mut libvlc_media_t,
    pub index: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_19"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_19>() - 16usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_19"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_19>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_19::item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_19, item) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_19::index"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_19, index) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_20 {
    pub item: *mut libvlc_media_t,
    pub index: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_20"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_20>() - 16usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_20"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_20>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_20::item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_20, item) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_20::index"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_20, index) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_21 {
    pub item: *mut libvlc_media_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_21"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_21>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_21"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_21>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_21::item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_21, item) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_22 {
    pub psz_filename: *mut libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_22"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_22>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_22"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_22>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_22::psz_filename"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1__bindgen_ty_22,
        psz_filename
    ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_23 {
    pub new_length: libvlc_time_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_23"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_23>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_23"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_23>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_23::new_length"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_23, new_length) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_24 {
    pub psz_media_name: *const libc::c_char,
    pub psz_instance_name: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_24"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_24>() - 16usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_24"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_24>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_24::psz_media_name"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1__bindgen_ty_24,
        psz_media_name
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_24::psz_instance_name"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1__bindgen_ty_24,
        psz_instance_name
    ) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_25 {
    pub new_media: *mut libvlc_media_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_25"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_25>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_25"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_25>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_25::new_media"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_25, new_media) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_26 {
    pub i_type: libvlc_track_type_t,
    pub i_id: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_26"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_26>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_26"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_26>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_26::i_type"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_26, i_type) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_26::i_id"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_26, i_id) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_27 {
    pub volume: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_27"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_27>() - 4usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_27"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_27>() - 4usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_27::volume"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_27, volume) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_28 {
    pub device: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_28"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_28>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_28"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_28>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_28::device"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_28, device) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_29 {
    pub item: *mut libvlc_renderer_item_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_29"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_29>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_29"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_29>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_29::item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_29, item) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_event_t__bindgen_ty_1__bindgen_ty_30 {
    pub item: *mut libvlc_renderer_item_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1__bindgen_ty_30"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_30>() - 8usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1__bindgen_ty_30"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1__bindgen_ty_30>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1__bindgen_ty_30::item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1__bindgen_ty_30, item) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t__bindgen_ty_1"]
        [::core::mem::size_of::<libvlc_event_t__bindgen_ty_1>() - 16usize];
    ["Alignment of libvlc_event_t__bindgen_ty_1"]
        [::core::mem::align_of::<libvlc_event_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_meta_changed"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_meta_changed) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_subitem_added"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_subitem_added) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_duration_changed"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_duration_changed) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_parsed_changed"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_parsed_changed) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_freed"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_freed) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_state_changed"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_state_changed) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_subitemtree_added"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_subitemtree_added) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_buffering"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_player_buffering) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_chapter_changed"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_chapter_changed
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_position_changed"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_position_changed
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_time_changed"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_player_time_changed) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_title_changed"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_title_changed
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_seekable_changed"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_seekable_changed
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_pausable_changed"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_pausable_changed
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_scrambled_changed"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_scrambled_changed
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_vout"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_player_vout) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_list_item_added"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_list_item_added) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_list_will_add_item"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_list_will_add_item) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_list_item_deleted"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_list_item_deleted) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_list_will_delete_item"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_list_will_delete_item
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_list_player_next_item_set"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_list_player_next_item_set
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_snapshot_taken"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_snapshot_taken
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_length_changed"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_length_changed
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::vlm_media_event"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, vlm_media_event) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_media_changed"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        media_player_media_changed
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_es_changed"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_player_es_changed) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_audio_volume"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_player_audio_volume) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::media_player_audio_device"]
        [::core::mem::offset_of!(libvlc_event_t__bindgen_ty_1, media_player_audio_device) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::renderer_discoverer_item_added"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        renderer_discoverer_item_added
    ) - 0usize];
    ["Offset of field: libvlc_event_t__bindgen_ty_1::renderer_discoverer_item_deleted"][::core::mem::offset_of!(
        libvlc_event_t__bindgen_ty_1,
        renderer_discoverer_item_deleted
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_event_t"][::core::mem::size_of::<libvlc_event_t>() - 32usize];
    ["Alignment of libvlc_event_t"][::core::mem::align_of::<libvlc_event_t>() - 8usize];
    ["Offset of field: libvlc_event_t::type_"]
        [::core::mem::offset_of!(libvlc_event_t, type_) - 0usize];
    ["Offset of field: libvlc_event_t::p_obj"]
        [::core::mem::offset_of!(libvlc_event_t, p_obj) - 8usize];
    ["Offset of field: libvlc_event_t::u"][::core::mem::offset_of!(libvlc_event_t, u) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_dialog_id {
    _unused: [u8; 0],
}
pub const libvlc_dialog_question_type_LIBVLC_DIALOG_QUESTION_NORMAL: libvlc_dialog_question_type =
    0;
pub const libvlc_dialog_question_type_LIBVLC_DIALOG_QUESTION_WARNING: libvlc_dialog_question_type =
    1;
pub const libvlc_dialog_question_type_LIBVLC_DIALOG_QUESTION_CRITICAL: libvlc_dialog_question_type =
    2;
#[doc = " @defgroup libvlc_dialog LibVLC dialog\n @ingroup libvlc\n @{\n @file\n LibVLC dialog external API"]
pub type libvlc_dialog_question_type = libc::c_uint;
#[doc = " Dialog callbacks to be implemented"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_dialog_cbs {
    #[doc = " Called when an error message needs to be displayed\n\n @param p_data opaque pointer for the callback\n @param psz_title title of the dialog\n @param psz_text text of the dialog"]
    pub pf_display_error: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            psz_title: *const libc::c_char,
            psz_text: *const libc::c_char,
        ),
    >,
    #[doc = " Called when a login dialog needs to be displayed\n\n You can interact with this dialog by calling libvlc_dialog_post_login()\n to post an answer or libvlc_dialog_dismiss() to cancel this dialog.\n\n @note to receive this callback, libvlc_dialog_cbs.pf_cancel should not be\n NULL.\n\n @param p_data opaque pointer for the callback\n @param p_id id used to interact with the dialog\n @param psz_title title of the dialog\n @param psz_text text of the dialog\n @param psz_default_username user name that should be set on the user form\n @param b_ask_store if true, ask the user if he wants to save the\n credentials"]
    pub pf_display_login: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            p_id: *mut libvlc_dialog_id,
            psz_title: *const libc::c_char,
            psz_text: *const libc::c_char,
            psz_default_username: *const libc::c_char,
            b_ask_store: bool,
        ),
    >,
    #[doc = " Called when a question dialog needs to be displayed\n\n You can interact with this dialog by calling libvlc_dialog_post_action()\n to post an answer or libvlc_dialog_dismiss() to cancel this dialog.\n\n @note to receive this callback, libvlc_dialog_cbs.pf_cancel should not be\n NULL.\n\n @param p_data opaque pointer for the callback\n @param p_id id used to interact with the dialog\n @param psz_title title of the dialog\n @param psz_text text of the dialog\n @param i_type question type (or severity) of the dialog\n @param psz_cancel text of the cancel button\n @param psz_action1 text of the first button, if NULL, don't display this\n button\n @param psz_action2 text of the second button, if NULL, don't display\n this button"]
    pub pf_display_question: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            p_id: *mut libvlc_dialog_id,
            psz_title: *const libc::c_char,
            psz_text: *const libc::c_char,
            i_type: libvlc_dialog_question_type,
            psz_cancel: *const libc::c_char,
            psz_action1: *const libc::c_char,
            psz_action2: *const libc::c_char,
        ),
    >,
    #[doc = " Called when a progress dialog needs to be displayed\n\n If cancellable (psz_cancel != NULL), you can cancel this dialog by\n calling libvlc_dialog_dismiss()\n\n @note to receive this callback, libvlc_dialog_cbs.pf_cancel and\n libvlc_dialog_cbs.pf_update_progress should not be NULL.\n\n @param p_data opaque pointer for the callback\n @param p_id id used to interact with the dialog\n @param psz_title title of the dialog\n @param psz_text text of the dialog\n @param b_indeterminate true if the progress dialog is indeterminate\n @param f_position initial position of the progress bar (between 0.0 and\n 1.0)\n @param psz_cancel text of the cancel button, if NULL the dialog is not\n cancellable"]
    pub pf_display_progress: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            p_id: *mut libvlc_dialog_id,
            psz_title: *const libc::c_char,
            psz_text: *const libc::c_char,
            b_indeterminate: bool,
            f_position: f32,
            psz_cancel: *const libc::c_char,
        ),
    >,
    #[doc = " Called when a displayed dialog needs to be cancelled\n\n The implementation must call libvlc_dialog_dismiss() to really release\n the dialog.\n\n @param p_data opaque pointer for the callback\n @param p_id id of the dialog"]
    pub pf_cancel: ::core::option::Option<
        unsafe extern "C" fn(p_data: *mut libc::c_void, p_id: *mut libvlc_dialog_id),
    >,
    #[doc = " Called when a progress dialog needs to be updated\n\n @param p_data opaque pointer for the callback\n @param p_id id of the dialog\n @param f_position osition of the progress bar (between 0.0 and 1.0)\n @param psz_text new text of the progress dialog"]
    pub pf_update_progress: ::core::option::Option<
        unsafe extern "C" fn(
            p_data: *mut libc::c_void,
            p_id: *mut libvlc_dialog_id,
            f_position: f32,
            psz_text: *const libc::c_char,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_dialog_cbs"][::core::mem::size_of::<libvlc_dialog_cbs>() - 48usize];
    ["Alignment of libvlc_dialog_cbs"][::core::mem::align_of::<libvlc_dialog_cbs>() - 8usize];
    ["Offset of field: libvlc_dialog_cbs::pf_display_error"]
        [::core::mem::offset_of!(libvlc_dialog_cbs, pf_display_error) - 0usize];
    ["Offset of field: libvlc_dialog_cbs::pf_display_login"]
        [::core::mem::offset_of!(libvlc_dialog_cbs, pf_display_login) - 8usize];
    ["Offset of field: libvlc_dialog_cbs::pf_display_question"]
        [::core::mem::offset_of!(libvlc_dialog_cbs, pf_display_question) - 16usize];
    ["Offset of field: libvlc_dialog_cbs::pf_display_progress"]
        [::core::mem::offset_of!(libvlc_dialog_cbs, pf_display_progress) - 24usize];
    ["Offset of field: libvlc_dialog_cbs::pf_cancel"]
        [::core::mem::offset_of!(libvlc_dialog_cbs, pf_cancel) - 32usize];
    ["Offset of field: libvlc_dialog_cbs::pf_update_progress"]
        [::core::mem::offset_of!(libvlc_dialog_cbs, pf_update_progress) - 40usize];
};
unsafe extern "C" {
    #[doc = " Register callbacks in order to handle VLC dialogs\n\n @version LibVLC 3.0.0 and later.\n\n @param p_cbs a pointer to callbacks, or NULL to unregister callbacks.\n @param p_data opaque pointer for the callback"]
    pub fn libvlc_dialog_set_callbacks(
        p_instance: *mut libvlc_instance_t,
        p_cbs: *const libvlc_dialog_cbs,
        p_data: *mut libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Associate an opaque pointer with the dialog id\n\n @version LibVLC 3.0.0 and later."]
    pub fn libvlc_dialog_set_context(p_id: *mut libvlc_dialog_id, p_context: *mut libc::c_void);
}
unsafe extern "C" {
    #[doc = " Return the opaque pointer associated with the dialog id\n\n @version LibVLC 3.0.0 and later."]
    pub fn libvlc_dialog_get_context(p_id: *mut libvlc_dialog_id) -> *mut libc::c_void;
}
unsafe extern "C" {
    #[doc = " Post a login answer\n\n After this call, p_id won't be valid anymore\n\n @see libvlc_dialog_cbs.pf_display_login\n\n @version LibVLC 3.0.0 and later.\n\n @param p_id id of the dialog\n @param psz_username valid and non empty string\n @param psz_password valid string (can be empty)\n @param b_store if true, store the credentials\n @return 0 on success, or -1 on error"]
    pub fn libvlc_dialog_post_login(
        p_id: *mut libvlc_dialog_id,
        psz_username: *const libc::c_char,
        psz_password: *const libc::c_char,
        b_store: bool,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Post a question answer\n\n After this call, p_id won't be valid anymore\n\n @see libvlc_dialog_cbs.pf_display_question\n\n @version LibVLC 3.0.0 and later.\n\n @param p_id id of the dialog\n @param i_action 1 for action1, 2 for action2\n @return 0 on success, or -1 on error"]
    pub fn libvlc_dialog_post_action(
        p_id: *mut libvlc_dialog_id,
        i_action: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Dismiss a dialog\n\n After this call, p_id won't be valid anymore\n\n @see libvlc_dialog_cbs.pf_cancel\n\n @version LibVLC 3.0.0 and later.\n\n @param p_id id of the dialog\n @return 0 on success, or -1 on error"]
    pub fn libvlc_dialog_dismiss(p_id: *mut libvlc_dialog_id) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Release the vlm instance related to the given libvlc_instance_t\n\n \\param p_instance the instance"]
    pub fn libvlc_vlm_release(p_instance: *mut libvlc_instance_t);
}
unsafe extern "C" {
    #[doc = " Add a broadcast, with one input.\n\n \\param p_instance the instance\n \\param psz_name the name of the new broadcast\n \\param psz_input the input MRL\n \\param psz_output the output MRL (the parameter to the \"sout\" variable)\n \\param i_options number of additional options\n \\param ppsz_options additional options\n \\param b_enabled boolean for enabling the new broadcast\n \\param b_loop Should this broadcast be played in loop ?\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_add_broadcast(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        psz_input: *const libc::c_char,
        psz_output: *const libc::c_char,
        i_options: libc::c_int,
        ppsz_options: *const *const libc::c_char,
        b_enabled: libc::c_int,
        b_loop: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Add a vod, with one input.\n\n \\param p_instance the instance\n \\param psz_name the name of the new vod media\n \\param psz_input the input MRL\n \\param i_options number of additional options\n \\param ppsz_options additional options\n \\param b_enabled boolean for enabling the new vod\n \\param psz_mux the muxer of the vod media\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_add_vod(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        psz_input: *const libc::c_char,
        i_options: libc::c_int,
        ppsz_options: *const *const libc::c_char,
        b_enabled: libc::c_int,
        psz_mux: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Delete a media (VOD or broadcast).\n\n \\param p_instance the instance\n \\param psz_name the media to delete\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_del_media(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Enable or disable a media (VOD or broadcast).\n\n \\param p_instance the instance\n \\param psz_name the media to work on\n \\param b_enabled the new status\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_set_enabled(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        b_enabled: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set the output for a media.\n\n \\param p_instance the instance\n \\param psz_name the media to work on\n \\param psz_output the output MRL (the parameter to the \"sout\" variable)\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_set_output(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        psz_output: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set a media's input MRL. This will delete all existing inputs and\n add the specified one.\n\n \\param p_instance the instance\n \\param psz_name the media to work on\n \\param psz_input the input MRL\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_set_input(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        psz_input: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Add a media's input MRL. This will add the specified one.\n\n \\param p_instance the instance\n \\param psz_name the media to work on\n \\param psz_input the input MRL\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_add_input(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        psz_input: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set a media's loop status.\n\n \\param p_instance the instance\n \\param psz_name the media to work on\n \\param b_loop the new status\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_set_loop(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        b_loop: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Set a media's vod muxer.\n\n \\param p_instance the instance\n \\param psz_name the media to work on\n \\param psz_mux the new muxer\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_set_mux(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        psz_mux: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Edit the parameters of a media. This will delete all existing inputs and\n add the specified one.\n\n \\param p_instance the instance\n \\param psz_name the name of the new broadcast\n \\param psz_input the input MRL\n \\param psz_output the output MRL (the parameter to the \"sout\" variable)\n \\param i_options number of additional options\n \\param ppsz_options additional options\n \\param b_enabled boolean for enabling the new broadcast\n \\param b_loop Should this broadcast be played in loop ?\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_change_media(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        psz_input: *const libc::c_char,
        psz_output: *const libc::c_char,
        i_options: libc::c_int,
        ppsz_options: *const *const libc::c_char,
        b_enabled: libc::c_int,
        b_loop: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Play the named broadcast.\n\n \\param p_instance the instance\n \\param psz_name the name of the broadcast\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_play_media(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Stop the named broadcast.\n\n \\param p_instance the instance\n \\param psz_name the name of the broadcast\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_stop_media(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Pause the named broadcast.\n\n \\param p_instance the instance\n \\param psz_name the name of the broadcast\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_pause_media(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Seek in the named broadcast.\n\n \\param p_instance the instance\n \\param psz_name the name of the broadcast\n \\param f_percentage the percentage to seek to\n \\return 0 on success, -1 on error"]
    pub fn libvlc_vlm_seek_media(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        f_percentage: f32,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Return information about the named media as a JSON\n string representation.\n\n This function is mainly intended for debugging use,\n if you want programmatic access to the state of\n a vlm_media_instance_t, please use the corresponding\n libvlc_vlm_get_media_instance_xxx -functions.\n Currently there are no such functions available for\n vlm_media_t though.\n\n \\param p_instance the instance\n \\param psz_name the name of the media,\n      if the name is an empty string, all media is described\n \\return string with information about named media, or NULL on error"]
    pub fn libvlc_vlm_show_media(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> *const libc::c_char;
}
unsafe extern "C" {
    #[doc = " Get vlm_media instance position by name or instance id\n\n \\param p_instance a libvlc instance\n \\param psz_name name of vlm media instance\n \\param i_instance instance id\n \\return position as float or -1. on error"]
    pub fn libvlc_vlm_get_media_instance_position(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        i_instance: libc::c_int,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " Get vlm_media instance time by name or instance id\n\n \\param p_instance a libvlc instance\n \\param psz_name name of vlm media instance\n \\param i_instance instance id\n \\return time as integer or -1 on error"]
    pub fn libvlc_vlm_get_media_instance_time(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        i_instance: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get vlm_media instance length by name or instance id\n\n \\param p_instance a libvlc instance\n \\param psz_name name of vlm media instance\n \\param i_instance instance id\n \\return length of media item or -1 on error"]
    pub fn libvlc_vlm_get_media_instance_length(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        i_instance: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get vlm_media instance playback rate by name or instance id\n\n \\param p_instance a libvlc instance\n \\param psz_name name of vlm media instance\n \\param i_instance instance id\n \\return playback rate or -1 on error"]
    pub fn libvlc_vlm_get_media_instance_rate(
        p_instance: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
        i_instance: libc::c_int,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get libvlc_event_manager from a vlm media.\n The p_event_manager is immutable, so you don't have to hold the lock\n\n \\param p_instance a libvlc instance\n \\return libvlc_event_manager"]
    pub fn libvlc_vlm_get_event_manager(
        p_instance: *mut libvlc_instance_t,
    ) -> *mut libvlc_event_manager_t;
}
unsafe extern "C" {
    #[doc = " Get movie fps rate\n\n This function is provided for backward compatibility. It cannot deal with\n multiple video tracks. In LibVLC versions prior to 3.0, it would also fail\n if the file format did not convey the frame rate explicitly.\n\n \\deprecated Consider using libvlc_media_tracks_get() instead.\n\n \\param p_mi the Media Player\n \\return frames per second (fps) for this playing movie, or 0 if unspecified"]
    pub fn libvlc_media_player_get_fps(p_mi: *mut libvlc_media_player_t) -> f32;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use libvlc_media_player_set_nsobject() instead"]
    pub fn libvlc_media_player_set_agl(p_mi: *mut libvlc_media_player_t, drawable: u32);
}
unsafe extern "C" {
    #[doc = " \\deprecated Use libvlc_media_player_get_nsobject() instead"]
    pub fn libvlc_media_player_get_agl(p_mi: *mut libvlc_media_player_t) -> u32;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use libvlc_track_description_list_release() instead"]
    pub fn libvlc_track_description_release(p_track_description: *mut libvlc_track_description_t);
}
unsafe extern "C" {
    #[doc = " Get current video height.\n \\deprecated Use libvlc_video_get_size() instead.\n\n \\param p_mi the media player\n \\return the video pixel height or 0 if not applicable"]
    pub fn libvlc_video_get_height(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get current video width.\n \\deprecated Use libvlc_video_get_size() instead.\n\n \\param p_mi the media player\n \\return the video pixel width or 0 if not applicable"]
    pub fn libvlc_video_get_width(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get the description of available titles.\n\n \\param p_mi the media player\n \\return list containing description of available titles.\n It must be freed with libvlc_track_description_list_release()"]
    pub fn libvlc_video_get_title_description(
        p_mi: *mut libvlc_media_player_t,
    ) -> *mut libvlc_track_description_t;
}
unsafe extern "C" {
    #[doc = " Get the description of available chapters for specific title.\n\n \\param p_mi the media player\n \\param i_title selected title\n \\return list containing description of available chapter for title i_title.\n It must be freed with libvlc_track_description_list_release()"]
    pub fn libvlc_video_get_chapter_description(
        p_mi: *mut libvlc_media_player_t,
        i_title: libc::c_int,
    ) -> *mut libvlc_track_description_t;
}
unsafe extern "C" {
    #[doc = " Set new video subtitle file.\n \\deprecated Use libvlc_media_player_add_slave() instead.\n\n \\param p_mi the media player\n \\param psz_subtitle new video subtitle file\n \\return the success status (boolean)"]
    pub fn libvlc_video_set_subtitle_file(
        p_mi: *mut libvlc_media_player_t,
        psz_subtitle: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Toggle teletext transparent status on video output.\n \\deprecated use libvlc_video_set_teletext() instead.\n\n \\param p_mi the media player"]
    pub fn libvlc_toggle_teletext(p_mi: *mut libvlc_media_player_t);
}
unsafe extern "C" {
    #[doc = " Backward compatibility stub. Do not use in new code.\n \\deprecated Use libvlc_audio_output_device_list_get() instead.\n \\return always 0."]
    pub fn libvlc_audio_output_device_count(
        p_instance: *mut libvlc_instance_t,
        psz_audio_output: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Backward compatibility stub. Do not use in new code.\n \\deprecated Use libvlc_audio_output_device_list_get() instead.\n \\return always NULL."]
    pub fn libvlc_audio_output_device_longname(
        p_instance: *mut libvlc_instance_t,
        psz_output: *const libc::c_char,
        i_device: libc::c_int,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Backward compatibility stub. Do not use in new code.\n \\deprecated Use libvlc_audio_output_device_list_get() instead.\n \\return always NULL."]
    pub fn libvlc_audio_output_device_id(
        p_instance: *mut libvlc_instance_t,
        psz_audio_output: *const libc::c_char,
        i_device: libc::c_int,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Stub for backward compatibility.\n \\return always -1."]
    pub fn libvlc_audio_output_get_device_type(p_mi: *mut libvlc_media_player_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Stub for backward compatibility."]
    pub fn libvlc_audio_output_set_device_type(
        p_mp: *mut libvlc_media_player_t,
        device_type: libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Parse a media.\n\n This fetches (local) art, meta data and tracks information.\n The method is synchronous.\n\n \\deprecated This function could block indefinitely.\n             Use libvlc_media_parse_with_options() instead\n\n \\see libvlc_media_parse_with_options\n \\see libvlc_media_get_meta\n \\see libvlc_media_get_tracks_info\n\n \\param p_md media descriptor object"]
    pub fn libvlc_media_parse(p_md: *mut libvlc_media_t);
}
unsafe extern "C" {
    #[doc = " Parse a media.\n\n This fetches (local) art, meta data and tracks information.\n The method is the asynchronous of libvlc_media_parse().\n\n To track when this is over you can listen to libvlc_MediaParsedChanged\n event. However if the media was already parsed you will not receive this\n event.\n\n \\deprecated You can't be sure to receive the libvlc_MediaParsedChanged\n             event (you can wait indefinitely for this event).\n             Use libvlc_media_parse_with_options() instead\n\n \\see libvlc_media_parse\n \\see libvlc_MediaParsedChanged\n \\see libvlc_media_get_meta\n \\see libvlc_media_get_tracks_info\n\n \\param p_md media descriptor object"]
    pub fn libvlc_media_parse_async(p_md: *mut libvlc_media_t);
}
unsafe extern "C" {
    #[doc = " Return true is the media descriptor object is parsed\n\n \\deprecated This can return true in case of failure.\n             Use libvlc_media_get_parsed_status() instead\n\n \\see libvlc_MediaParsedChanged\n\n \\param p_md media descriptor object\n \\return true if media object has been parsed otherwise it returns false\n\n \\libvlc_return_bool"]
    pub fn libvlc_media_is_parsed(p_md: *mut libvlc_media_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Get media descriptor's elementary streams description\n\n Note, you need to call libvlc_media_parse() or play the media at least once\n before calling this function.\n Not doing this will result in an empty array.\n\n \\deprecated Use libvlc_media_tracks_get() instead\n\n \\param p_md media descriptor object\n \\param tracks address to store an allocated array of Elementary Streams\n        descriptions (must be freed by the caller) [OUT]\n\n \\return the number of Elementary Streams"]
    pub fn libvlc_media_get_tracks_info(
        p_md: *mut libvlc_media_t,
        tracks: *mut *mut libvlc_media_track_info_t,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " \\ingroup libvlc libvlc_media_list\n @{"]
    pub fn libvlc_media_list_add_file_content(
        p_ml: *mut libvlc_media_list_t,
        psz_uri: *const libc::c_char,
    ) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use libvlc_media_discoverer_new() and libvlc_media_discoverer_start()."]
    pub fn libvlc_media_discoverer_new_from_name(
        p_inst: *mut libvlc_instance_t,
        psz_name: *const libc::c_char,
    ) -> *mut libvlc_media_discoverer_t;
}
unsafe extern "C" {
    #[doc = " Get media service discover object its localized name.\n\n \\deprecated Useless, use libvlc_media_discoverer_list_get() to get the\n longname of the service discovery.\n\n \\param p_mdis media discover object\n \\return localized name or NULL if the media_discoverer is not started"]
    pub fn libvlc_media_discoverer_localized_name(
        p_mdis: *mut libvlc_media_discoverer_t,
    ) -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " Get event manager from media service discover object.\n\n \\deprecated Useless, media_discoverer events are only triggered when calling\n libvlc_media_discoverer_start() and libvlc_media_discoverer_stop().\n\n \\param p_mdis media service discover object\n \\return event manager object."]
    pub fn libvlc_media_discoverer_event_manager(
        p_mdis: *mut libvlc_media_discoverer_t,
    ) -> *mut libvlc_event_manager_t;
}
unsafe extern "C" {
    #[doc = " Waits until an interface causes the instance to exit.\n You should start at least one interface first, using libvlc_add_intf().\n\n \\param p_instance the instance\n \\warning This function wastes one thread doing basically nothing.\n libvlc_set_exit_handler() should be used instead."]
    pub fn libvlc_wait(p_instance: *mut libvlc_instance_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_log_iterator_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libvlc_log_message_t {
    pub i_severity: libc::c_int,
    pub psz_type: *const libc::c_char,
    pub psz_name: *const libc::c_char,
    pub psz_header: *const libc::c_char,
    pub psz_message: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of libvlc_log_message_t"][::core::mem::size_of::<libvlc_log_message_t>() - 40usize];
    ["Alignment of libvlc_log_message_t"][::core::mem::align_of::<libvlc_log_message_t>() - 8usize];
    ["Offset of field: libvlc_log_message_t::i_severity"]
        [::core::mem::offset_of!(libvlc_log_message_t, i_severity) - 0usize];
    ["Offset of field: libvlc_log_message_t::psz_type"]
        [::core::mem::offset_of!(libvlc_log_message_t, psz_type) - 8usize];
    ["Offset of field: libvlc_log_message_t::psz_name"]
        [::core::mem::offset_of!(libvlc_log_message_t, psz_name) - 16usize];
    ["Offset of field: libvlc_log_message_t::psz_header"]
        [::core::mem::offset_of!(libvlc_log_message_t, psz_header) - 24usize];
    ["Offset of field: libvlc_log_message_t::psz_message"]
        [::core::mem::offset_of!(libvlc_log_message_t, psz_message) - 32usize];
};
unsafe extern "C" {
    #[doc = " Always returns minus one.\n This function is only provided for backward compatibility.\n\n \\param p_instance ignored\n \\return always -1"]
    pub fn libvlc_get_log_verbosity(p_instance: *const libvlc_instance_t) -> libc::c_uint;
}
unsafe extern "C" {
    #[doc = " This function does nothing.\n It is only provided for backward compatibility.\n\n \\param p_instance ignored\n \\param level ignored"]
    pub fn libvlc_set_log_verbosity(p_instance: *mut libvlc_instance_t, level: libc::c_uint);
}
unsafe extern "C" {
    #[doc = " This function does nothing useful.\n It is only provided for backward compatibility.\n\n \\param p_instance libvlc instance\n \\return an unique pointer or NULL on error"]
    pub fn libvlc_log_open(p_instance: *mut libvlc_instance_t) -> *mut libvlc_log_t;
}
unsafe extern "C" {
    #[doc = " Frees memory allocated by libvlc_log_open().\n\n \\param p_log libvlc log instance or NULL"]
    pub fn libvlc_log_close(p_log: *mut libvlc_log_t);
}
unsafe extern "C" {
    #[doc = " Always returns zero.\n This function is only provided for backward compatibility.\n\n \\param p_log ignored\n \\return always zero"]
    pub fn libvlc_log_count(p_log: *const libvlc_log_t) -> libc::c_uint;
}
unsafe extern "C" {
    #[doc = " This function does nothing.\n It is only provided for backward compatibility.\n\n \\param p_log ignored"]
    pub fn libvlc_log_clear(p_log: *mut libvlc_log_t);
}
unsafe extern "C" {
    #[doc = " This function does nothing useful.\n It is only provided for backward compatibility.\n\n \\param p_log ignored\n \\return an unique pointer or NULL on error or if the parameter was NULL"]
    pub fn libvlc_log_get_iterator(p_log: *const libvlc_log_t) -> *mut libvlc_log_iterator_t;
}
unsafe extern "C" {
    #[doc = " Frees memory allocated by libvlc_log_get_iterator().\n\n \\param p_iter libvlc log iterator or NULL"]
    pub fn libvlc_log_iterator_free(p_iter: *mut libvlc_log_iterator_t);
}
unsafe extern "C" {
    #[doc = " Always returns zero.\n This function is only provided for backward compatibility.\n\n \\param p_iter ignored\n \\return always zero"]
    pub fn libvlc_log_iterator_has_next(p_iter: *const libvlc_log_iterator_t) -> libc::c_int;
}
unsafe extern "C" {
    #[doc = " Always returns NULL.\n This function is only provided for backward compatibility.\n\n \\param p_iter libvlc log iterator or NULL\n \\param p_buf ignored\n \\return always NULL"]
    pub fn libvlc_log_iterator_next(
        p_iter: *mut libvlc_log_iterator_t,
        p_buf: *mut libvlc_log_message_t,
    ) -> *mut libvlc_log_message_t;
}
unsafe extern "C" {
    #[doc = " Start playing (if there is any item in the playlist).\n\n Additionnal playlist item options can be specified for addition to the\n item before it is played.\n\n \\param p_instance the playlist instance\n \\param i_id the item to play. If this is a negative number, the next\n        item will be selected. Otherwise, the item with the given ID will be\n        played\n \\param i_options the number of options to add to the item\n \\param ppsz_options the options to add to the item"]
    pub fn libvlc_playlist_play(
        p_instance: *mut libvlc_instance_t,
        i_id: libc::c_int,
        i_options: libc::c_int,
        ppsz_options: *mut *mut libc::c_char,
    );
}
pub type __builtin_va_list = *mut libc::c_char;
